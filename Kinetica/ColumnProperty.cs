/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

namespace kinetica
{
    /// <summary>Column properties used for Kinetica types.</summary>
    public struct ColumnProperty
    {
        /// <summary>Default property for all numeric and string type columns;
        /// makes the column available for GPU queries.</summary>
        public const string DATA = "data";

        /// <summary>Valid only for select 'string' columns.</summary>
        /// <remarks><para>Enables full text search--see <a
        /// href="../../../concepts/full_text_search/" target="_top">Full Text
        /// Search</a> for details and applicable string column types. Can be
        /// set independently of <see cref="DATA" /> and <see cref="STORE_ONLY"
        /// />.</para></remarks>
        public const string TEXT_SEARCH = "text_search";

        /// <summary>Persist the column value but do not make it available to
        /// queries (e.g. <see
        /// cref="Kinetica.filter(FilterRequest)">Kinetica.filter</see>)-i.e.
        /// it is mutually exclusive to the <see cref="DATA" /> property.
        /// </summary>
        /// <remarks><para>Any 'bytes' type column must have a <see
        /// cref="STORE_ONLY" /> property. This property reduces system memory
        /// usage.</para></remarks>
        public const string STORE_ONLY = "store_only";

        /// <summary>Works in conjunction with the <see cref="DATA" /> property
        /// for string columns.</summary>
        /// <remarks><para>This property reduces system disk usage by disabling
        /// reverse string lookups. Queries like <see
        /// cref="Kinetica.filter(FilterRequest)">Kinetica.filter</see>, <see
        /// cref="Kinetica.filterByList(FilterByListRequest)">Kinetica.filterByList</see>,
        /// and <see
        /// cref="Kinetica.filterByValue(FilterByValueRequest)">Kinetica.filterByValue</see>
        /// work as usual but <see
        /// cref="Kinetica.aggregateUnique(AggregateUniqueRequest)">Kinetica.aggregateUnique</see>
        /// and <see
        /// cref="Kinetica.aggregateGroupBy(AggregateGroupByRequest)">Kinetica.aggregateGroupBy</see>
        /// are not allowed on columns with this property.</para></remarks>
        public const string DISK_OPTIMIZED = "disk_optimized";

        /// <summary>Valid only for 'long' columns.</summary>
        /// <remarks><para>Indicates that this field represents a timestamp and
        /// will be provided in milliseconds since the Unix epoch: 00:00:00 Jan
        /// 1 1970.  Dates represented by a timestamp must fall between the
        /// year 1000 and the year 2900.</para></remarks>
        public const string TIMESTAMP = "timestamp";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para> It represents an unsigned long integer data type.
        /// The string can only be interpreted as an unsigned long data type
        /// with minimum value of zero, and maximum value of
        /// 18446744073709551615.</para></remarks>
        public const string ULONG = "ulong";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para> It represents an uuid data type. Internally, it is
        /// stored as a 128-bit integer.</para></remarks>
        public const string UUID = "uuid";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para> It represents a SQL type NUMERIC(19, 4) data type.
        /// There can be up to 15 digits before the decimal point and up to
        /// four digits in the fractional part.  The value can be positive or
        /// negative (indicated by a minus sign at the beginning).  This
        /// property is mutually exclusive with the <see cref="TEXT_SEARCH" />
        /// property.</para></remarks>
        public const string DECIMAL = "decimal";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para> Indicates that this field represents a date and
        /// will be provided in the format 'YYYY-MM-DD'.  The allowable range
        /// is 1000-01-01 through 2900-01-01.  This property is mutually
        /// exclusive with the <see cref="TEXT_SEARCH" /> property.</para>
        /// </remarks>
        public const string DATE = "date";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para> Indicates that this field represents a time-of-day
        /// and will be provided in the format 'HH:MM:SS.mmm'.  The allowable
        /// range is 00:00:00.000 through 23:59:59.999.  This property is
        /// mutually exclusive with the <see cref="TEXT_SEARCH" /> property.
        /// </para></remarks>
        public const string TIME = "time";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para> Indicates that this field represents a datetime and
        /// will be provided in the format 'YYYY-MM-DD HH:MM:SS.mmm'.  The
        /// allowable range is 1000-01-01 00:00:00.000 through 2900-01-01
        /// 23:59:59.999.  This property is mutually exclusive with the <see
        /// cref="TEXT_SEARCH" /> property.</para></remarks>
        public const string DATETIME = "datetime";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than 1
        /// character.</para></remarks>
        public const string CHAR1 = "char1";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than 2
        /// characters.</para></remarks>
        public const string CHAR2 = "char2";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than 4
        /// characters.</para></remarks>
        public const string CHAR4 = "char4";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than 8
        /// characters.</para></remarks>
        public const string CHAR8 = "char8";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than 16
        /// characters.</para></remarks>
        public const string CHAR16 = "char16";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than 32
        /// characters.</para></remarks>
        public const string CHAR32 = "char32";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than 64
        /// characters.</para></remarks>
        public const string CHAR64 = "char64";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than
        /// 128 characters.</para></remarks>
        public const string CHAR128 = "char128";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns.</summary>
        /// <remarks><para>Strings with this property must be no longer than
        /// 256 characters.</para></remarks>
        public const string CHAR256 = "char256";

        /// <summary>This property provides optimized memory and query
        /// performance for int columns.</summary>
        /// <remarks><para>Ints with this property must be between 0 and
        /// 1(inclusive)</para></remarks>
        public const string BOOLEAN = "boolean";

        /// <summary>This property provides optimized memory and query
        /// performance for int columns.</summary>
        /// <remarks><para>Ints with this property must be between -128 and
        /// +127 (inclusive)</para></remarks>
        public const string INT8 = "int8";

        /// <summary>This property provides optimized memory and query
        /// performance for int columns.</summary>
        /// <remarks><para>Ints with this property must be between -32768 and
        /// +32767 (inclusive)</para></remarks>
        public const string INT16 = "int16";

        /// <summary>This property provides optimized memory, disk and query
        /// performance for string columns representing IPv4 addresses (i.e.
        /// 192.168.1.1).</summary>
        /// <remarks><para>Strings with this property must be of the form:
        /// A.B.C.D where A, B, C and D are in the range of 0-255.</para>
        /// </remarks>
        public const string IPV4 = "ipv4";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para>Indicates that this field contains an array.  The
        /// value type and (optionally) the item count should be specified in
        /// parenthesis; e.g., 'array(int, 10)' for a 10-integer array.  Both
        /// 'array(int)' and 'array(int, -1)' will designate an
        /// unlimited-length integer array, though no bounds checking is
        /// performed on arrays of any length.</para></remarks>
        public const string ARRAY = "array";

        /// <summary>Valid only for 'string' columns.</summary>
        /// <remarks><para>Indicates that this field contains values in JSON
        /// format.</para></remarks>
        public const string JSON = "json";

        /// <summary>Valid only for 'bytes' columns.</summary>
        /// <remarks><para>Indicates that this field contains a vector of
        /// floats.  The length should be specified in parenthesis, e.g.,
        /// 'vector(1000)'.</para></remarks>
        public const string VECTOR = "vector";

        /// <summary>Valid only for 'string' and 'bytes' columns.</summary>
        /// <remarks><para>Indicates that this field contains geospatial
        /// geometry objects in Well-Known Text (WKT) or Well-Known Binary
        /// (WKB) format.</para></remarks>
        public const string WKT = "wkt";

        /// <summary>This property indicates that this column will be part of
        /// (or the entire) <a href="../../../concepts/tables/#primary-keys"
        /// target="_top">primary key</a>.</summary>
        public const string PRIMARY_KEY = "primary_key";

        /// <summary>This property indicates that this column will be part of
        /// (or the entire) <a href="../../../concepts/tables/#shard-keys"
        /// target="_top">shard key</a>.</summary>
        public const string SHARD_KEY = "shard_key";

        /// <summary>This property indicates that this column is nullable.
        /// </summary>
        /// <remarks><para> However, setting this property is insufficient for
        /// making the column nullable.  The user must declare the type of the
        /// column as a union between its regular type and 'null' in the avro
        /// schema for the record type in <see
        /// cref="CreateTypeRequest.type_definition">type_definition</see>.
        /// For example, if a column is of type integer and is nullable, then
        /// the entry for the column in the avro schema must be: ['int',
        /// 'null'].</para>
        /// <para>The C++, C#, Java, and Python APIs have built-in convenience
        /// for bypassing setting the avro schema by hand.  For those
        /// languages, one can use this property as usual and not have to worry
        /// about the avro schema for the record.</para></remarks>
        public const string NULLABLE = "nullable";

        /// <summary>This property indicates that this column should be <a
        /// href="../../../concepts/dictionary_encoding/"
        /// target="_top">dictionary encoded</a>.</summary>
        /// <remarks><para>It can only be used in conjunction with restricted
        /// string (charN), int, long or date columns. Dictionary encoding is
        /// best for columns where the cardinality (the number of unique
        /// values) is expected to be low. This property can save a large
        /// amount of memory.</para></remarks>
        public const string DICT = "dict";

        /// <summary>For 'date', 'time', 'datetime', or 'timestamp' column
        /// types, replace empty strings and invalid timestamps with 'NOW()'
        /// upon insert.</summary>
        public const string INIT_WITH_NOW = "init_with_now";

        /// <summary>For 'uuid' type, replace empty strings and invalid UUID
        /// values with randomly-generated UUIDs upon insert.</summary>
        public const string INIT_WITH_UUID = "init_with_uuid";
    } // end struct ColumnProperty
} // end namespace kinetica
