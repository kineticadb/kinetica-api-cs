/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */


using Avro;
using System.Collections.Generic;


namespace kinetica
{

    public partial class Kinetica
    {

        // Kinetica Version
        public const string API_VERSION = "6.0.0.0";



        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminDeleteNodeResponse adminDeleteNode( AdminDeleteNodeRequest request_ )
        {
            AdminDeleteNodeResponse actualResponse_ = SubmitRequest<AdminDeleteNodeResponse>("/admin/delete/node", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="rank"></param>
        /// <param name="authorization"></param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminDeleteNodeResponse adminDeleteNode( int rank,
                                                        string authorization,
                                                        IDictionary<string, string> options = null )
        {
            return adminDeleteNode( new AdminDeleteNodeRequest( rank, authorization,
                                                                options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminGetShardAssignmentsResponse adminGetShardAssignments( AdminGetShardAssignmentsRequest request_ )
        {
            AdminGetShardAssignmentsResponse actualResponse_ = SubmitRequest<AdminGetShardAssignmentsResponse>("/admin/getshardassignments", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminGetShardAssignmentsResponse adminGetShardAssignments( IDictionary<string, string> options = null )
        {
            return adminGetShardAssignments( new AdminGetShardAssignmentsRequest( options ) );
        }


        /// <summary>Take the system offline. When the system is offline, no
        /// user operations can be performed with the exception of a system
        /// shutdown.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminOfflineResponse adminOffline( AdminOfflineRequest request_ )
        {
            AdminOfflineResponse actualResponse_ = SubmitRequest<AdminOfflineResponse>("/admin/offline", request_, false);

            return actualResponse_;
        }


        /// <summary>Take the system offline. When the system is offline, no
        /// user operations can be performed with the exception of a system
        /// shutdown.</summary>
        /// 
        /// <param name="offline">Set to true if desired state is offline.
        /// Values: true, false.
        ///   </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminOfflineResponse adminOffline( bool offline,
                                                  IDictionary<string, string> options = null )
        {
            return adminOffline( new AdminOfflineRequest( offline, options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminRebalanceResponse adminRebalance( AdminRebalanceRequest request_ )
        {
            AdminRebalanceResponse actualResponse_ = SubmitRequest<AdminRebalanceResponse>("/admin/rebalance", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="table_names"></param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminRebalanceResponse adminRebalance( IList<string> table_names,
                                                      IDictionary<string, string> options = null )
        {
            return adminRebalance( new AdminRebalanceRequest( table_names, options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminSetShardAssignmentsResponse adminSetShardAssignments( AdminSetShardAssignmentsRequest request_ )
        {
            AdminSetShardAssignmentsResponse actualResponse_ = SubmitRequest<AdminSetShardAssignmentsResponse>("/admin/setshardassignments", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="version"></param>
        /// <param name="partial_reassignment"></param>
        /// <param name="shard_assignments_rank"></param>
        /// <param name="shard_assignments_tom"></param>
        /// <param name="assignment_index"></param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminSetShardAssignmentsResponse adminSetShardAssignments( long version,
                                                                          bool partial_reassignment,
                                                                          IList<int> shard_assignments_rank,
                                                                          IList<int> shard_assignments_tom,
                                                                          IList<int> assignment_index,
                                                                          IDictionary<string, string> options = null )
        {
            return adminSetShardAssignments( new AdminSetShardAssignmentsRequest( version,
                                                                                  partial_reassignment,
                                                                                  shard_assignments_rank,
                                                                                  shard_assignments_tom,
                                                                                  assignment_index,
                                                                                  options ) );
        }


        /// <summary>Exits the database server application.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminShutdownResponse adminShutdown( AdminShutdownRequest request_ )
        {
            AdminShutdownResponse actualResponse_ = SubmitRequest<AdminShutdownResponse>("/admin/shutdown", request_, false);

            return actualResponse_;
        }


        /// <summary>Exits the database server application.</summary>
        /// 
        /// <param name="exit_type">Reserved for future use. User can pass an
        /// empty string.  </param>
        /// <param name="authorization">No longer used. User can pass an empty
        /// string.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminShutdownResponse adminShutdown( string exit_type,
                                                    string authorization,
                                                    IDictionary<string, string> options = null )
        {
            return adminShutdown( new AdminShutdownRequest( exit_type, authorization,
                                                            options ) );
        }


        /// <summary>Verify database is in a consistent state.  When
        /// inconsistencies or errors are found, the verified_ok flag in the
        /// response is set to false and the list of errors found is provided
        /// in the error_list.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminVerifyDbResponse adminVerifyDb( AdminVerifyDbRequest request_ )
        {
            AdminVerifyDbResponse actualResponse_ = SubmitRequest<AdminVerifyDbResponse>("/admin/verifydb", request_, false);

            return actualResponse_;
        }


        /// <summary>Verify database is in a consistent state.  When
        /// inconsistencies or errors are found, the verified_ok flag in the
        /// response is set to false and the list of errors found is provided
        /// in the error_list.</summary>
        /// 
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AdminVerifyDbResponse adminVerifyDb( IDictionary<string, string> options = null )
        {
            return adminVerifyDb( new AdminVerifyDbRequest( options ) );
        }


        /// <summary>Calculates and returns the convex hull for the values in a
        /// table specified by <paramref
        /// cref="AggregateConvexHullRequest.table_name" />.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateConvexHullResponse aggregateConvexHull( AggregateConvexHullRequest request_ )
        {
            AggregateConvexHullResponse actualResponse_ = SubmitRequest<AggregateConvexHullResponse>("/aggregate/convexhull", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates and returns the convex hull for the values in a
        /// table specified by <paramref name="table_name" />.</summary>
        /// 
        /// <param name="table_name">Name of Table on which the operation will
        /// be performed. Must be an existing table.  It can not be a
        /// collection.  </param>
        /// <param name="x_column_name">Name of the column containing the x
        /// coordinates of the points for the operation being performed.
        /// </param>
        /// <param name="y_column_name">Name of the column containing the y
        /// coordinates of the points for the operation being performed.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateConvexHullResponse aggregateConvexHull( string table_name,
                                                                string x_column_name,
                                                                string y_column_name,
                                                                IDictionary<string, string> options = null )
        {
            return aggregateConvexHull( new AggregateConvexHullRequest( table_name,
                                                                        x_column_name,
                                                                        y_column_name,
                                                                        options ) );
        }


        /// <summary>Calculates unique combinations (groups) of values for the
        /// given columns in a given table/view/collection and computes
        /// aggregates on each unique combination. This is somewhat analogous
        /// to an SQL-style SELECT...GROUP BY. Any column(s) can be grouped on,
        /// but only non-string (i.e. numeric) columns may be used for
        /// computing aggregates. The results can be paged via the <paramref
        /// cref="AggregateGroupByRequest.offset" /> and <paramref
        /// cref="AggregateGroupByRequest.limit" /> parameters. For example, to
        /// get 10 groups with the largest counts the inputs would be:
        /// limit=10, options={"sort_order":"descending", "sort_by":"value"}.
        /// <paramref cref="AggregateGroupByRequest.options" /> can be used to
        /// customize behavior of this call e.g. filtering or sorting the
        /// results. To group by 'x' and 'y' and compute the number of objects
        /// within each group, use column_names=['x','y','count(*)'].  To also
        /// compute the sum of 'z' over each group, use
        /// column_names=['x','y','count(*)','sum(z)']. Available aggregation
        /// functions are: 'count(*)', 'sum', 'min', 'max', 'avg', 'mean',
        /// 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop',
        /// 'var_samp', 'arg_min', 'arg_max' and 'count_distinct'. The response
        /// is returned as a dynamic schema. For details see: <a
        /// href="../../../../concepts/dynamic_schemas.html"
        /// target="_top">dynamic schemas documentation</a>. If the
        /// 'result_table' option is provided then the results are stored in a
        /// table with the name given in the option and the results are not
        /// returned in the response.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateGroupByResponse aggregateGroupBy( AggregateGroupByRequest request_ )
        {
            RawAggregateGroupByResponse actualResponse_ = SubmitRequest<RawAggregateGroupByResponse>("/aggregate/groupby", request_, false);

            AggregateGroupByResponse response_ = new AggregateGroupByResponse();
            response_.data = KineticaRecord.DecodeDynamicTableRecords( actualResponse_.response_schema_str, actualResponse_.binary_encoded_response );
            response_.total_number_of_records = actualResponse_.total_number_of_records;
            response_.has_more_records = actualResponse_.has_more_records;
            return response_;
        }


        /// <summary>Calculates unique combinations (groups) of values for the
        /// given columns in a given table/view/collection and computes
        /// aggregates on each unique combination. This is somewhat analogous
        /// to an SQL-style SELECT...GROUP BY. Any column(s) can be grouped on,
        /// but only non-string (i.e. numeric) columns may be used for
        /// computing aggregates. The results can be paged via the <paramref
        /// name="offset" /> and <paramref name="limit" /> parameters. For
        /// example, to get 10 groups with the largest counts the inputs would
        /// be: limit=10, options={"sort_order":"descending",
        /// "sort_by":"value"}. <paramref name="options" /> can be used to
        /// customize behavior of this call e.g. filtering or sorting the
        /// results. To group by 'x' and 'y' and compute the number of objects
        /// within each group, use column_names=['x','y','count(*)'].  To also
        /// compute the sum of 'z' over each group, use
        /// column_names=['x','y','count(*)','sum(z)']. Available aggregation
        /// functions are: 'count(*)', 'sum', 'min', 'max', 'avg', 'mean',
        /// 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop',
        /// 'var_samp', 'arg_min', 'arg_max' and 'count_distinct'. The response
        /// is returned as a dynamic schema. For details see: <a
        /// href="../../../../concepts/dynamic_schemas.html"
        /// target="_top">dynamic schemas documentation</a>. If the
        /// 'result_table' option is provided then the results are stored in a
        /// table with the name given in the option and the results are not
        /// returned in the response.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the operation
        /// will be performed. Must be an existing table/view/collection.
        /// </param>
        /// <param name="column_names">List of one or more column names,
        /// expressions, and aggregate expressions. Must include at least one
        /// 'grouping' column or expression.  If no aggregate is included,
        /// count(*) will be computed as a default.  </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of results to be returned Or END_OF_SET (-9999) to indicate
        /// that the max number of results should be returned.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Filter expression to apply to the table prior
        /// to computing the aggregate group by.</description>
        ///     </item>
        ///     <item>
        ///         <term>having</term>
        ///         <description>Filter expression to apply to the aggregated
        /// results.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted - ascending or descending. Values: ascending,
        /// descending.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>sort_by</term>
        ///         <description>String determining how the results are sorted.
        /// Values: key, value.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>result_table</term>
        ///         <description>The name of the table used to store the
        /// results. Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// Column names (group-by and aggregate fields) need to be given
        /// aliases e.g. ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
        /// present, no results are returned in the response.  This option is
        /// not available if one of the grouping attributes is an unrestricted
        /// string (i.e.; not charN) type.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateGroupByResponse aggregateGroupBy( string table_name,
                                                          IList<string> column_names,
                                                          long offset,
                                                          long limit = 1000,
                                                          IDictionary<string, string> options = null )
        {
            return aggregateGroupBy( new AggregateGroupByRequest( table_name,
                                                                  column_names, offset,
                                                                  limit, options ) );
        }


        /// <summary>Performs a histogram calculation given a table, a column,
        /// and an interval function. The <paramref
        /// cref="AggregateHistogramRequest.interval" /> is used to produce
        /// bins of that size and the result, computed over the records falling
        /// within each bin, is returned.  For each bin, the start value is
        /// inclusive, but the end value is exclusive--except for the very last
        /// bin for which the end value is also inclusive.  The value returned
        /// for each bin is the number of records in it, except when a column
        /// name is provided as a *value_column* in <paramref
        /// cref="AggregateHistogramRequest.options" />.  In this latter case
        /// the sum of the values corresponding to the *value_column* is used
        /// as the result instead.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateHistogramResponse aggregateHistogram( AggregateHistogramRequest request_ )
        {
            AggregateHistogramResponse actualResponse_ = SubmitRequest<AggregateHistogramResponse>("/aggregate/histogram", request_, false);

            return actualResponse_;
        }


        /// <summary>Performs a histogram calculation given a table, a column,
        /// and an interval function. The <paramref name="interval" /> is used
        /// to produce bins of that size and the result, computed over the
        /// records falling within each bin, is returned.  For each bin, the
        /// start value is inclusive, but the end value is exclusive--except
        /// for the very last bin for which the end value is also inclusive.
        /// The value returned for each bin is the number of records in it,
        /// except when a column name is provided as a *value_column* in
        /// <paramref name="options" />.  In this latter case the sum of the
        /// values corresponding to the *value_column* is used as the result
        /// instead.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the operation
        /// will be performed. Must be an existing table or collection.
        /// </param>
        /// <param name="column_name">Name of a column or an expression of one
        /// or more column names over which the histogram will be calculated.
        /// </param>
        /// <param name="start">Lower end value of the histogram interval,
        /// inclusive.  </param>
        /// <param name="end">Upper end value of the histogram interval,
        /// inclusive.  </param>
        /// <param name="interval">The size of each bin within the start and
        /// end parameters.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>value_column</term>
        ///         <description>The name of the column to use when calculating
        /// the bin values (values are summed).  The column must be a numerical
        /// type (int, double, long, float).</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateHistogramResponse aggregateHistogram( string table_name,
                                                              string column_name,
                                                              double start,
                                                              double end,
                                                              double interval,
                                                              IDictionary<string, string> options = null )
        {
            return aggregateHistogram( new AggregateHistogramRequest( table_name,
                                                                      column_name, start,
                                                                      end, interval,
                                                                      options ) );
        }


        /// <summary>This endpoint runs the k-means algorithm - a heuristic
        /// algorithm that attempts to do k-means clustering.  An ideal k-means
        /// clustering algorithm selects k points such that the sum of the mean
        /// squared distances of each member of the set to the nearest of the k
        /// points is minimized.  The k-means algorithm however does not
        /// necessarily produce such an ideal cluster.   It begins with a
        /// randomly selected set of k points and then refines the location of
        /// the points iteratively and settles to a local minimum.  Various
        /// parameters and options are provided to control the heuristic
        /// search.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateKMeansResponse aggregateKMeans( AggregateKMeansRequest request_ )
        {
            AggregateKMeansResponse actualResponse_ = SubmitRequest<AggregateKMeansResponse>("/aggregate/kmeans", request_, false);

            return actualResponse_;
        }


        /// <summary>This endpoint runs the k-means algorithm - a heuristic
        /// algorithm that attempts to do k-means clustering.  An ideal k-means
        /// clustering algorithm selects k points such that the sum of the mean
        /// squared distances of each member of the set to the nearest of the k
        /// points is minimized.  The k-means algorithm however does not
        /// necessarily produce such an ideal cluster.   It begins with a
        /// randomly selected set of k points and then refines the location of
        /// the points iteratively and settles to a local minimum.  Various
        /// parameters and options are provided to control the heuristic
        /// search.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the operation
        /// will be performed. Must be an existing table or collection.
        /// </param>
        /// <param name="column_names">List of column names on which the
        /// operation would be performed. If n columns are provided then each
        /// of the k result points will have n dimensions corresponding to the
        /// n columns.  </param>
        /// <param name="k">The number of mean points to be determined by the
        /// algorithm.  </param>
        /// <param name="tolerance">Stop iterating when the distances between
        /// successive points is less than the given tolerance.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>whiten</term>
        ///         <description>When set to 1 each of the columns is first
        /// normalized by its stdv - default is not to whiten.</description>
        ///     </item>
        ///     <item>
        ///         <term>max_iters</term>
        ///         <description>Number of times to try to hit the tolerance
        /// limit before giving up - default is 10.</description>
        ///     </item>
        ///     <item>
        ///         <term>num_tries</term>
        ///         <description>Number of times to run the k-means algorithm
        /// with a different randomly selected starting points - helps avoid
        /// local minimum. Default is 1.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateKMeansResponse aggregateKMeans( string table_name,
                                                        IList<string> column_names,
                                                        int k,
                                                        double tolerance,
                                                        IDictionary<string, string> options = null )
        {
            return aggregateKMeans( new AggregateKMeansRequest( table_name, column_names,
                                                                k, tolerance, options ) );
        }


        /// <summary>Calculates and returns the minimum and maximum values of a
        /// particular column in a table.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateMinMaxResponse aggregateMinMax( AggregateMinMaxRequest request_ )
        {
            AggregateMinMaxResponse actualResponse_ = SubmitRequest<AggregateMinMaxResponse>("/aggregate/minmax", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates and returns the minimum and maximum values of a
        /// particular column in a table.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the operation
        /// will be performed. Must be an existing table.  </param>
        /// <param name="column_name">Name of a column or an expression of one
        /// or more column on which the min-max will be calculated.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateMinMaxResponse aggregateMinMax( string table_name,
                                                        string column_name,
                                                        IDictionary<string, string> options = null )
        {
            return aggregateMinMax( new AggregateMinMaxRequest( table_name, column_name,
                                                                options ) );
        }


        /// <summary>Calculates the requested statistics of a given column in a
        /// given table.
        /// <br />
        /// The available statistics are count (number of total objects), mean,
        /// stdv (standard deviation), variance, skew, kurtosis, sum, min, max,
        /// weighted_average, cardinality (unique count), estimated
        /// cardinality, percentile and percentile_rank.
        /// <br />
        /// Estimated cardinality is calculated by using the hyperloglog
        /// approximation technique.
        /// <br />
        /// Percentiles and percentile_ranks are approximate and are calculated
        /// using the t-digest algorithm. They must include the desired
        /// percentile/percentile_rank. To compute multiple percentiles each
        /// value must be specified separately (i.e.
        /// 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
        /// <br />
        /// The weighted average statistic requires a weight_attribute to be
        /// specified in <paramref cref="AggregateStatisticsRequest.options"
        /// />. The weighted average is then defined as the sum of the products
        /// of <paramref cref="AggregateStatisticsRequest.column_name" /> times
        /// the weight attribute divided by the sum of the weight attribute.
        /// <br />
        /// The response includes a list of the statistics requested along with
        /// the count of the number of items in the given set.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateStatisticsResponse aggregateStatistics( AggregateStatisticsRequest request_ )
        {
            AggregateStatisticsResponse actualResponse_ = SubmitRequest<AggregateStatisticsResponse>("/aggregate/statistics", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates the requested statistics of a given column in a
        /// given table.
        /// <br />
        /// The available statistics are count (number of total objects), mean,
        /// stdv (standard deviation), variance, skew, kurtosis, sum, min, max,
        /// weighted_average, cardinality (unique count), estimated
        /// cardinality, percentile and percentile_rank.
        /// <br />
        /// Estimated cardinality is calculated by using the hyperloglog
        /// approximation technique.
        /// <br />
        /// Percentiles and percentile_ranks are approximate and are calculated
        /// using the t-digest algorithm. They must include the desired
        /// percentile/percentile_rank. To compute multiple percentiles each
        /// value must be specified separately (i.e.
        /// 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
        /// <br />
        /// The weighted average statistic requires a weight_attribute to be
        /// specified in <paramref name="options" />. The weighted average is
        /// then defined as the sum of the products of <paramref
        /// name="column_name" /> times the weight attribute divided by the sum
        /// of the weight attribute.
        /// <br />
        /// The response includes a list of the statistics requested along with
        /// the count of the number of items in the given set.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the statistics
        /// operation will be performed.  </param>
        /// <param name="column_name">Name of the column for which the
        /// statistics are to be calculated.  </param>
        /// <param name="stats">Comma separated list of the statistics to
        /// calculate, e.g. "sum,mean". Values: count, mean, stdv, variance,
        /// skew, kurtosis, sum, min, max, weighted_average, cardinality,
        /// estimated_cardinality, percentile, percentile_rank.
        ///   </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>additional_column_names</term>
        ///         <description>A list of comma separated column names over
        /// which statistics can be accumulated along with the primary
        /// column.</description>
        ///     </item>
        ///     <item>
        ///         <term>weight_column_name</term>
        ///         <description>Name of column used as weighting attribute for
        /// the weighted average statistic.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateStatisticsResponse aggregateStatistics( string table_name,
                                                                string column_name,
                                                                string stats,
                                                                IDictionary<string, string> options = null )
        {
            return aggregateStatistics( new AggregateStatisticsRequest( table_name,
                                                                        column_name,
                                                                        stats, options ) );
        }


        /// <summary>Divides the given set into bins and calculates statistics
        /// of the values of a value-column in each bin.  The bins are based on
        /// the values of a given binning-column.  The statistics that may be
        /// requested are mean, stdv (standard deviation), variance, skew,
        /// kurtosis, sum, min, max, first, last and weighted average. In
        /// addition to the requested statistics the count of total samples in
        /// each bin is returned. This counts vector is just the histogram of
        /// the column used to divide the set members into bins. The weighted
        /// average statistic requires a weight_column to be specified in
        /// <paramref cref="AggregateStatisticsByRangeRequest.options" />. The
        /// weighted average is then defined as the sum of the products of the
        /// value column times the weight column divided by the sum of the
        /// weight column.
        /// <br />
        /// There are two methods for binning the set members. In the first,
        /// which can be used for numeric valued binning-columns, a min, max
        /// and interval are specified. The number of bins, nbins, is the
        /// integer upper bound of (max-min)/interval. Values that fall in the
        /// range [min+n\*interval,min+(n+1)\*interval) are placed in the nth
        /// bin where n ranges from 0..nbin-2. The final bin is
        /// [min+(nbin-1)\*interval,max]. In the second method, <paramref
        /// cref="AggregateStatisticsByRangeRequest.options" /> bin_values
        /// specifies a list of binning column values. Binning-columns whose
        /// value matches the nth member of the bin_values list are placed in
        /// the nth bin. When a list is provided the binning-column must be of
        /// type string or int.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateStatisticsByRangeResponse aggregateStatisticsByRange( AggregateStatisticsByRangeRequest request_ )
        {
            AggregateStatisticsByRangeResponse actualResponse_ = SubmitRequest<AggregateStatisticsByRangeResponse>("/aggregate/statistics/byrange", request_, false);

            return actualResponse_;
        }


        /// <summary>Divides the given set into bins and calculates statistics
        /// of the values of a value-column in each bin.  The bins are based on
        /// the values of a given binning-column.  The statistics that may be
        /// requested are mean, stdv (standard deviation), variance, skew,
        /// kurtosis, sum, min, max, first, last and weighted average. In
        /// addition to the requested statistics the count of total samples in
        /// each bin is returned. This counts vector is just the histogram of
        /// the column used to divide the set members into bins. The weighted
        /// average statistic requires a weight_column to be specified in
        /// <paramref name="options" />. The weighted average is then defined
        /// as the sum of the products of the value column times the weight
        /// column divided by the sum of the weight column.
        /// <br />
        /// There are two methods for binning the set members. In the first,
        /// which can be used for numeric valued binning-columns, a min, max
        /// and interval are specified. The number of bins, nbins, is the
        /// integer upper bound of (max-min)/interval. Values that fall in the
        /// range [min+n\*interval,min+(n+1)\*interval) are placed in the nth
        /// bin where n ranges from 0..nbin-2. The final bin is
        /// [min+(nbin-1)\*interval,max]. In the second method, <paramref
        /// name="options" /> bin_values specifies a list of binning column
        /// values. Binning-columns whose value matches the nth member of the
        /// bin_values list are placed in the nth bin. When a list is provided
        /// the binning-column must be of type string or int.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the
        /// ranged-statistics operation will be performed.  </param>
        /// <param name="select_expression">For a non-empty expression
        /// statistics are calculated for those records for which the
        /// expression is true.  </param>
        /// <param name="column_name">Name of the binning-column used to divide
        /// the set samples into bins.  </param>
        /// <param name="value_column_name">Name of the value-column for which
        /// statistics are to be computed.  </param>
        /// <param name="stats">A string of comma separated list of the
        /// statistics to calculate, e.g. 'sum,mean'. Available statistics:
        /// mean, stdv (standard deviation), variance, skew, kurtosis, sum.
        /// </param>
        /// <param name="start">The lower bound of the binning-column.
        /// </param>
        /// <param name="end">The upper bound of the binning-column.  </param>
        /// <param name="interval">The interval of a bin. Set members fall into
        /// bin i if the binning-column falls in the range
        /// [start+interval``*``i, start+interval``*``(i+1)).  </param>
        /// <param name="options">Map of optional parameters:
        /// <list type="bullet">
        ///     <item>
        ///         <term>additional_column_names</term>
        ///         <description>A list of comma separated value-column names
        /// over which statistics can be accumulated along with the primary
        /// value_column.</description>
        ///     </item>
        ///     <item>
        ///         <term>bin_values</term>
        ///         <description>A list of comma separated binning-column
        /// values. Values that match the nth bin_values value are placed in
        /// the nth bin.</description>
        ///     </item>
        ///     <item>
        ///         <term>weight_column_name</term>
        ///         <description>Name of the column used as weighting column
        /// for the weighted_average statistic.</description>
        ///     </item>
        ///     <item>
        ///         <term>order_column_name</term>
        ///         <description>Name of the column used for candlestick
        /// charting techniques.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateStatisticsByRangeResponse aggregateStatisticsByRange( string table_name,
                                                                              string select_expression,
                                                                              string column_name,
                                                                              string value_column_name,
                                                                              string stats,
                                                                              double start,
                                                                              double end,
                                                                              double interval,
                                                                              IDictionary<string, string> options = null )
        {
            return aggregateStatisticsByRange( new AggregateStatisticsByRangeRequest(
                                                                                      table_name,
                                                                                      select_expression,
                                                                                      column_name,
                                                                                      value_column_name,
                                                                                      stats,
                                                                                      start,
                                                                                      end,
                                                                                      interval,
                                                                                      options ) );
        }


        /// <summary>Returns all the unique values from a particular column
        /// (specified by <paramref cref="AggregateUniqueRequest.column_name"
        /// />) of a particular table (specified by <paramref
        /// cref="AggregateUniqueRequest.table_name" />). If <paramref
        /// cref="AggregateUniqueRequest.column_name" /> is a numeric column
        /// the values will be in <paramref
        /// cref="RawAggregateUniqueResponse.binary_encoded_response" />.
        /// Otherwise if <paramref cref="AggregateUniqueRequest.column_name" />
        /// is a string column the values will be in <paramref
        /// cref="RawAggregateUniqueResponse.json_encoded_response" />.
        /// <paramref cref="AggregateUniqueRequest.offset" /> and <paramref
        /// cref="AggregateUniqueRequest.limit" /> are used to page through the
        /// results if there are large numbers of unique values. To get the
        /// first 10 unique values sorted in descending order <paramref
        /// cref="AggregateUniqueRequest.options" /> would be::
        /// <br />
        /// {"limit":"10","sort_order":"descending"}.
        /// <br />
        /// The response is returned as a dynamic schema. For details see: <a
        /// href="../../../../concepts/dynamic_schemas.html"
        /// target="_top">dynamic schemas documentation</a>. If the
        /// 'result_table' option is provided then the results are stored in a
        /// table with the name given in the option and the results are not
        /// returned in the response.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateUniqueResponse aggregateUnique( AggregateUniqueRequest request_ )
        {
            RawAggregateUniqueResponse actualResponse_ = SubmitRequest<RawAggregateUniqueResponse>("/aggregate/unique", request_, false);

            AggregateUniqueResponse response_ = new AggregateUniqueResponse();
            response_.table_name = actualResponse_.table_name;
            response_.data = KineticaRecord.DecodeDynamicTableRecords( actualResponse_.response_schema_str, actualResponse_.binary_encoded_response );
            response_.has_more_records = actualResponse_.has_more_records;
            return response_;
        }


        /// <summary>Returns all the unique values from a particular column
        /// (specified by <paramref name="column_name" />) of a particular
        /// table (specified by <paramref name="table_name" />). If <paramref
        /// name="column_name" /> is a numeric column the values will be in
        /// <paramref cref="RawAggregateUniqueResponse.binary_encoded_response"
        /// />. Otherwise if <paramref name="column_name" /> is a string column
        /// the values will be in <paramref
        /// cref="RawAggregateUniqueResponse.json_encoded_response" />.
        /// <paramref name="offset" /> and <paramref name="limit" /> are used
        /// to page through the results if there are large numbers of unique
        /// values. To get the first 10 unique values sorted in descending
        /// order <paramref name="options" /> would be::
        /// <br />
        /// {"limit":"10","sort_order":"descending"}.
        /// <br />
        /// The response is returned as a dynamic schema. For details see: <a
        /// href="../../../../concepts/dynamic_schemas.html"
        /// target="_top">dynamic schemas documentation</a>. If the
        /// 'result_table' option is provided then the results are stored in a
        /// table with the name given in the option and the results are not
        /// returned in the response.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the operation
        /// will be performed. Must be an existing table.  </param>
        /// <param name="column_name">Name of the column or an expression
        /// containing one or more column names on which the unique function
        /// would be applied.  </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of results to be returned. Or END_OF_SET (-9999) to indicate
        /// that the max number of results should be returned.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Optional filter expression to apply to the
        /// table.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted. Values: ascending, descending.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>result_table</term>
        ///         <description>The name of the table used to store the
        /// results. If present no results are returned in the response. Has
        /// the same naming restrictions as <a
        /// href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AggregateUniqueResponse aggregateUnique( string table_name,
                                                        string column_name,
                                                        long offset,
                                                        long limit = 10000,
                                                        IDictionary<string, string> options = null )
        {
            return aggregateUnique( new AggregateUniqueRequest( table_name, column_name,
                                                                offset, limit, options ) );
        }


        /// <summary>The <see
        /// cref="Kinetica.alterSystemProperties(AlterSystemPropertiesRequest)"
        /// /> endpoint is primarily used to simplify the testing of the system
        /// and is not expected to be used during normal execution.  Commands
        /// are given through the <paramref
        /// cref="AlterSystemPropertiesRequest.property_updates_map" /> whose
        /// keys are commands and values are strings representing integer
        /// values (for example '8000') or boolean values ('true' or
        /// 'false').</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterSystemPropertiesResponse alterSystemProperties( AlterSystemPropertiesRequest request_ )
        {
            AlterSystemPropertiesResponse actualResponse_ = SubmitRequest<AlterSystemPropertiesResponse>("/alter/system/properties", request_, false);

            return actualResponse_;
        }


        /// <summary>The <see
        /// cref="Kinetica.alterSystemProperties(IDictionary{string, string},IDictionary{string, string})"
        /// /> endpoint is primarily used to simplify the testing of the system
        /// and is not expected to be used during normal execution.  Commands
        /// are given through the <paramref name="property_updates_map" />
        /// whose keys are commands and values are strings representing integer
        /// values (for example '8000') or boolean values ('true' or
        /// 'false').</summary>
        /// 
        /// <param name="property_updates_map">Map containing the properties of
        /// the system to be updated. Error if empty.
        /// <list type="bullet">
        ///     <item>
        ///         <term>sm_omp_threads</term>
        ///         <description>Set the number of OpenMP threads that will be
        /// used to service filter & aggregation requests against collections
        /// to the specified integer value.</description>
        ///     </item>
        ///     <item>
        ///         <term>kernel_omp_threads</term>
        ///         <description>Set the number of kernel OpenMP threads to the
        /// specified integer value.</description>
        ///     </item>
        ///     <item>
        ///         <term>concurrent_kernel_execution</term>
        ///         <description>Enables concurrent kernel execution if the
        /// value is <i>true</i> and disables it if the value is <i>false</i>.
        /// Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>chunk_size</term>
        ///         <description>Sets the chunk size of all new sets to the
        /// specified integer value.</description>
        ///     </item>
        ///     <item>
        ///         <term>flush_to_disk</term>
        ///         <description>Flushes any changes to any tables to the
        /// persistent store.  These changes include updates to the vector
        /// store, object store, and text search store, Value string is
        /// ignored</description>
        ///     </item>
        ///     <item>
        ///         <term>clear_cache</term>
        ///         <description>Clears cached results.  Useful to allow
        /// repeated timing of endpoints. Value string is ignored</description>
        ///     </item>
        ///     <item>
        ///         <term>communicator_test</term>
        ///         <description>Invoke the communicator test and report timing
        /// results. Value string is is a comma separated list of <key>=<value>
        /// expressions.  Expressions are: num_transactions=<num> where num is
        /// the number of request reply transactions to invoke per test;
        /// message_size=<bytes> where bytes is the size of the messages to
        /// send in bytes; check_values=<enabled> where if enabled is true the
        /// value of the messages received are verified.</description>
        ///     </item>
        ///     <item>
        ///         <term>set_message_timers_enabled</term>
        ///         <description>Enables the communicator test to collect
        /// additional timing statistics when the value string is <i>true</i>.
        /// Disables the collection when the value string is <i>false</i>
        /// Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>bulk_add_test</term>
        ///         <description>Invoke the bulk add test and report timing
        /// results. Value string is ignored.</description>
        ///     </item>
        ///     <item>
        ///         <term>network_speed</term>
        ///         <description>Invoke the network speed test and report
        /// timing results. Value string is a semicolon-separated list of
        /// <key>=<value> expressions.  Valid expressions are: seconds=<time>
        /// where time is the time in seconds to run the test; data_size=<size>
        /// where size is the size in bytes of the block to be transferred;
        /// threads=<number of threads>; to_ranks=<space-separated list of
        /// ranks> where the list of ranks is the ranks that rank 0 will send
        /// data to and get data from. If to_ranks is unspecified then all
        /// worker ranks are used.</description>
        ///     </item>
        ///     <item>
        ///         <term>request_timeout</term>
        ///         <description>Number of minutes after which filtering (e.g.,
        /// /filter) and aggregating (e.g., /aggregate/groupby) queries will
        /// timeout.</description>
        ///     </item>
        ///     <item>
        ///         <term>max_get_records_size</term>
        ///         <description>The maximum number of records the database
        /// will serve for a given data retrieval call</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterSystemPropertiesResponse alterSystemProperties( IDictionary<string, string> property_updates_map,
                                                                    IDictionary<string, string> options = null )
        {
            return alterSystemProperties( new AlterSystemPropertiesRequest(
                                                                            property_updates_map,
                                                                            options ) );
        }


        /// <summary>Apply various modifications to a table or collection.
        /// Available modifications include:
        /// <br />
        ///      Creating or deleting an index on a particular column. This can
        /// speed up certain search queries (such as <see
        /// cref="Kinetica.getRecords{T}(GetRecordsRequest)" />, <see
        /// cref="Kinetica.deleteRecords(DeleteRecordsRequest)" />, <see
        /// cref="Kinetica.updateRecordsRaw(RawUpdateRecordsRequest)" />) when
        /// using expressions containing equality or relational operators on
        /// indexed columns. This only applies to tables.
        /// <br />
        ///      Setting the time-to-live (TTL). This can be applied to tables,
        /// views, or collections.  When applied to collections, every table &
        /// view within the collection will have its TTL set to the given
        /// value.
        /// <br />
        ///      Making a table protected or not. Protected tables have their
        /// TTLs set to not automatically expire. This can be applied to
        /// tables, views, and collections.
        /// <br />
        ///      Allowing homogeneous tables within a collection.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterTableResponse alterTable( AlterTableRequest request_ )
        {
            AlterTableResponse actualResponse_ = SubmitRequest<AlterTableResponse>("/alter/table", request_, false);

            return actualResponse_;
        }


        /// <summary>Apply various modifications to a table or collection.
        /// Available modifications include:
        /// <br />
        ///      Creating or deleting an index on a particular column. This can
        /// speed up certain search queries (such as <see
        /// cref="Kinetica.getRecords{T}(string,long,long,IDictionary{string, string})"
        /// />, <see
        /// cref="Kinetica.deleteRecords(string,IList{string},IDictionary{string, string})"
        /// />, <see
        /// cref="Kinetica.updateRecords{T}(string,IList{string},IList{IDictionary{string, string}},IList{T},IDictionary{string, string})"
        /// />) when using expressions containing equality or relational
        /// operators on indexed columns. This only applies to tables.
        /// <br />
        ///      Setting the time-to-live (TTL). This can be applied to tables,
        /// views, or collections.  When applied to collections, every table &
        /// view within the collection will have its TTL set to the given
        /// value.
        /// <br />
        ///      Making a table protected or not. Protected tables have their
        /// TTLs set to not automatically expire. This can be applied to
        /// tables, views, and collections.
        /// <br />
        ///      Allowing homogeneous tables within a collection.</summary>
        /// 
        /// <param name="table_name">Table on which the operation will be
        /// performed. Must be an existing table, view, or collection.
        /// </param>
        /// <param name="action">Modification operation to be applied Values:
        /// create_index, delete_index, allow_homogeneous_tables, protected,
        /// ttl, add_column, delete_column, change_column, rename_table.
        ///   </param>
        /// <param name="_value">The value of the modification. May be a column
        /// name, 'true' or 'false', or a TTL depending on <paramref
        /// cref="AlterTableRequest.action" />.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>column_default_value</term>
        ///         <description>when adding a column: set a default value, for
        /// existing data.</description>
        ///     </item>
        ///     <item>
        ///         <term>column_properties</term>
        ///         <description>when adding or changing a column: set the
        /// column properties (strings, separated by a comma: data, store_only,
        /// text_search, char8, int8 etc).</description>
        ///     </item>
        ///     <item>
        ///         <term>column_type</term>
        ///         <description>when adding or changing a column: set the
        /// column type (strings, separated by a comma: int, double, string,
        /// null etc).</description>
        ///     </item>
        ///     <item>
        ///         <term>validate_change_column</term>
        ///         <description>Validate the type change before applying
        /// column_change request. Default is true (if option is missing). If
        /// True, then validate all values. A value too large (or too long) for
        /// the new type will prevent any change. If False, then when a value
        /// is too large or long, it will be truncated. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>copy_values_from_column</term>
        ///         <description>when adding or changing a column: enter column
        /// name - from where to copy values.</description>
        ///     </item>
        ///     <item>
        ///         <term>rename_column</term>
        ///         <description>new column name (using
        /// change_column).</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterTableResponse alterTable( string table_name,
                                              string action,
                                              string _value,
                                              IDictionary<string, string> options = null )
        {
            return alterTable( new AlterTableRequest( table_name, action, _value, options ) );
        }


        /// <summary>Updates (adds or changes) metadata for tables. The
        /// metadata key and values must both be strings. This is an easy way
        /// to annotate whole tables rather than single records within tables.
        /// Some examples of metadata are owner of the table, table creation
        /// timestamp etc.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterTableMetadataResponse alterTableMetadata( AlterTableMetadataRequest request_ )
        {
            AlterTableMetadataResponse actualResponse_ = SubmitRequest<AlterTableMetadataResponse>("/alter/table/metadata", request_, false);

            return actualResponse_;
        }


        /// <summary>Updates (adds or changes) metadata for tables. The
        /// metadata key and values must both be strings. This is an easy way
        /// to annotate whole tables rather than single records within tables.
        /// Some examples of metadata are owner of the table, table creation
        /// timestamp etc.</summary>
        /// 
        /// <param name="table_names">Names of the tables whose metadata will
        /// be updated. All specified tables must exist, or an error will be
        /// returned.  </param>
        /// <param name="metadata_map">A map which contains the metadata of the
        /// tables that are to be updated. Note that only one map is provided
        /// for all the tables; so the change will be applied to every table.
        /// If the provided map is empty, then all existing metadata for the
        /// table(s) will be cleared.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterTableMetadataResponse alterTableMetadata( IList<string> table_names,
                                                              IDictionary<string, string> metadata_map,
                                                              IDictionary<string, string> options = null )
        {
            return alterTableMetadata( new AlterTableMetadataRequest( table_names,
                                                                      metadata_map,
                                                                      options ) );
        }


        /// <summary>Alters a user.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterUserResponse alterUser( AlterUserRequest request_ )
        {
            AlterUserResponse actualResponse_ = SubmitRequest<AlterUserResponse>("/alter/user", request_, false);

            return actualResponse_;
        }


        /// <summary>Alters a user.</summary>
        /// 
        /// <param name="name">Name of the user to be altered. Must be an
        /// existing user.  </param>
        /// <param name="action">Modification operation to be applied to the
        /// user. Values: set_password.
        ///   </param>
        /// <param name="_value">The value of the modification, depending on
        /// <paramref cref="AlterUserRequest.action" />.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public AlterUserResponse alterUser( string name,
                                            string action,
                                            string _value,
                                            IDictionary<string, string> options )
        {
            return alterUser( new AlterUserRequest( name, action, _value, options ) );
        }


        /// <summary>Clears (drops) one or all tables in the database cluster.
        /// The operation is synchronous meaning that the table will be cleared
        /// before the function returns. The response payload returns the
        /// status of the operation along with the name of the table that was
        /// cleared.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ClearTableResponse clearTable( ClearTableRequest request_ )
        {
            ClearTableResponse actualResponse_ = SubmitRequest<ClearTableResponse>("/clear/table", request_, false);

            return actualResponse_;
        }


        /// <summary>Clears (drops) one or all tables in the database cluster.
        /// The operation is synchronous meaning that the table will be cleared
        /// before the function returns. The response payload returns the
        /// status of the operation along with the name of the table that was
        /// cleared.</summary>
        /// 
        /// <param name="table_name">Name of the table to be cleared. Must be
        /// an existing table. Empty string clears all available tables.
        /// </param>
        /// <param name="authorization">No longer used. User can pass an empty
        /// string.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ClearTableResponse clearTable( string table_name = "",
                                              string authorization = "",
                                              IDictionary<string, string> options = null )
        {
            return clearTable( new ClearTableRequest( table_name, authorization, options ) );
        }


        /// <summary>Deactivates a table monitor previously created with <see
        /// cref="Kinetica.createTableMonitor(CreateTableMonitorRequest)"
        /// />.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ClearTableMonitorResponse clearTableMonitor( ClearTableMonitorRequest request_ )
        {
            ClearTableMonitorResponse actualResponse_ = SubmitRequest<ClearTableMonitorResponse>("/clear/tablemonitor", request_, false);

            return actualResponse_;
        }


        /// <summary>Deactivates a table monitor previously created with <see
        /// cref="Kinetica.createTableMonitor(string,IDictionary{string, string})"
        /// />.</summary>
        /// 
        /// <param name="topic_id">The topic ID returned by
        /// /create/tablemonitor.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ClearTableMonitorResponse clearTableMonitor( string topic_id,
                                                            IDictionary<string, string> options = null )
        {
            return clearTableMonitor( new ClearTableMonitorRequest( topic_id, options ) );
        }


        /// <summary>Clears or cancels the trigger identified by the specified
        /// handle. The output returns the handle of the trigger cleared as
        /// well as indicating success or failure of the trigger
        /// deactivation.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ClearTriggerResponse clearTrigger( ClearTriggerRequest request_ )
        {
            ClearTriggerResponse actualResponse_ = SubmitRequest<ClearTriggerResponse>("/clear/trigger", request_, false);

            return actualResponse_;
        }


        /// <summary>Clears or cancels the trigger identified by the specified
        /// handle. The output returns the handle of the trigger cleared as
        /// well as indicating success or failure of the trigger
        /// deactivation.</summary>
        /// 
        /// <param name="trigger_id">ID for the trigger to be deactivated.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ClearTriggerResponse clearTrigger( string trigger_id,
                                                  IDictionary<string, string> options = null )
        {
            return clearTrigger( new ClearTriggerRequest( trigger_id, options ) );
        }


        /// <summary>Creates a table that is the result of a SQL JOIN.  For
        /// details see: <a href="../../../../concepts/joins.html"
        /// target="_top">join concept documentation</a>.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateJoinTableResponse createJoinTable( CreateJoinTableRequest request_ )
        {
            CreateJoinTableResponse actualResponse_ = SubmitRequest<CreateJoinTableResponse>("/create/jointable", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a table that is the result of a SQL JOIN.  For
        /// details see: <a href="../../../../concepts/joins.html"
        /// target="_top">join concept documentation</a>.</summary>
        /// 
        /// <param name="join_table_name">Name of the join table to be created.
        /// Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// </param>
        /// <param name="table_names">The list of table names making up the
        /// joined set.  Corresponds to a SQL statement FROM clause  </param>
        /// <param name="column_names">List of columns to be included in the
        /// join table. Can be the column_names from the member sets if unique
        /// or can be prefixed by the table id as <id>.<column_name> where <id>
        /// is the table name or alias. Can be specified as aliased via the
        /// syntax '<column_name> as <alias>. Can use wild cards as '*'
        /// (include all columns), or <id>.* (include all columns from table
        /// with name or alias <id>)  </param>
        /// <param name="expressions">An optional list of expressions to
        /// combine and filter the joined set.  Corresponds to a SQL statement
        /// WHERE clause. For details see: <a
        /// href="../../../../concepts/expressions.html"
        /// target="_top">expressions</a>.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection which is to contain the
        /// join table. If empty, then the join table will be a top-level
        /// table.</description>
        ///     </item>
        ///     <item>
        ///         <term>max_query_dimensions</term>
        ///         <description>The maximum number of tables in a joined table
        /// that can be accessed by a query and are not equated by a
        /// foreign-key to primary-key equality predicate</description>
        ///     </item>
        ///     <item>
        ///         <term>optimize_lookups</term>
        ///         <description>Use the applied filters to precalculate the
        /// lookup table to get data from the primary key sets</description>
        ///     </item>
        ///     <item>
        ///         <term>refresh_method</term>
        ///         <description>Method by which the join table can be
        /// refreshed when underlying member tables have changed. Values:
        /// manual, on_query, on_insert.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>refresh</term>
        ///         <description>Do a manual refresh of the join table if it
        /// exists - throws an error otherwise Values: no_refresh, refresh,
        /// full_refresh.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateJoinTableResponse createJoinTable( string join_table_name,
                                                        IList<string> table_names = null,
                                                        IList<string> column_names = null,
                                                        IList<string> expressions = null,
                                                        IDictionary<string, string> options = null )
        {
            return createJoinTable( new CreateJoinTableRequest( join_table_name,
                                                                table_names, column_names,
                                                                expressions, options ) );
        }


        /// <summary>Creates an instance (proc) of the user-defined function
        /// (UDF) specified by the given command, options, and files, and makes
        /// it available for execution.  For details on UDFs, see: <a
        /// href="../../../../concepts/udf.html" target="_top">User-Defined
        /// Functions</a></summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateProcResponse createProc( CreateProcRequest request_ )
        {
            CreateProcResponse actualResponse_ = SubmitRequest<CreateProcResponse>("/create/proc", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates an instance (proc) of the user-defined function
        /// (UDF) specified by the given command, options, and files, and makes
        /// it available for execution.  For details on UDFs, see: <a
        /// href="../../../../concepts/udf.html" target="_top">User-Defined
        /// Functions</a></summary>
        /// 
        /// <param name="proc_name">Name of the proc to be created. Must not be
        /// the name of a currently existing proc.  </param>
        /// <param name="execution_mode">The execution mode of the proc.
        /// Values: distributed, nondistributed.
        ///   </param>
        /// <param name="files">A map of the files that make up the proc. The
        /// keys of the map are file names, and the values are the binary
        /// contents of the files. The file names may include subdirectory
        /// names (e.g. 'subdir/file') but must not resolve to a directory
        /// above the root for the proc.  </param>
        /// <param name="command">The command (excluding arguments) that will
        /// be invoked when the proc is executed. It will be invoked from the
        /// directory containing the proc <paramref
        /// cref="CreateProcRequest.files" /> and may be any command that can
        /// be resolved from that directory. It need not refer to a file
        /// actually in that directory; for example, it could be 'java' if the
        /// proc is a Java application; however, any necessary external
        /// programs must be preinstalled on every database node. If the
        /// command refers to a file in that directory, it must be preceded
        /// with './' as per Linux convention. If not specified, and exactly
        /// one file is provided in <paramref cref="CreateProcRequest.files"
        /// />, that file will be invoked.  </param>
        /// <param name="args">An array of command-line arguments that will be
        /// passed to <paramref cref="CreateProcRequest.command" /> when the
        /// proc is executed.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateProcResponse createProc( string proc_name,
                                              string execution_mode = CreateProcRequest.ExecutionMode.DISTRIBUTED,
                                              IDictionary<string, byte[]> files = null,
                                              string command = "",
                                              IList<string> args = null,
                                              IDictionary<string, string> options = null )
        {
            return createProc( new CreateProcRequest( proc_name, execution_mode, files,
                                                      command, args, options ) );
        }


        /// <summary>Creates a new projection of an existing table. A
        /// projection represents a subset of the columns (potentially
        /// including derived columns) of a table.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateProjectionResponse createProjection( CreateProjectionRequest request_ )
        {
            CreateProjectionResponse actualResponse_ = SubmitRequest<CreateProjectionResponse>("/create/projection", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a new projection of an existing table. A
        /// projection represents a subset of the columns (potentially
        /// including derived columns) of a table.</summary>
        /// 
        /// <param name="table_name">Name of the existing table on which the
        /// projection is to be applied.  </param>
        /// <param name="projection_name">Name of the projection to be created.
        /// Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// </param>
        /// <param name="column_names">List of columns from <paramref
        /// cref="CreateProjectionRequest.table_name" /> to be included in the
        /// projection. Can include derived columns. Can be specified as
        /// aliased via the syntax '<column_name> as <alias>.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection to which the projection
        /// is to be assigned as a child.</description>
        ///     </item>
        ///     <item>
        ///         <term>expression</term>
        ///         <description>An optional filter expression to be applied to
        /// the source table prior to the projection.</description>
        ///     </item>
        ///     <item>
        ///         <term>limit</term>
        ///         <description>The number of records to keep.</description>
        ///     </item>
        ///     <item>
        ///         <term>order_by</term>
        ///         <description>Comma-separated list of the columns to be
        /// sorted by; i.e 'timestamp asc, x desc'.</description>
        ///     </item>
        ///     <item>
        ///         <term>materialize_on_gpu</term>
        ///         <description>If 'true' then the columns of the projection
        /// will be cached on the GPU. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>chunk_size</term>
        ///         <description>Chunk size for this projection</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateProjectionResponse createProjection( string table_name,
                                                          string projection_name,
                                                          IList<string> column_names,
                                                          IDictionary<string, string> options = null )
        {
            return createProjection( new CreateProjectionRequest( table_name,
                                                                  projection_name,
                                                                  column_names, options ) );
        }


        /// <summary>Creates a new role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateRoleResponse createRole( CreateRoleRequest request_ )
        {
            CreateRoleResponse actualResponse_ = SubmitRequest<CreateRoleResponse>("/create/role", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a new role.</summary>
        /// 
        /// <param name="name">Name of the role to be created. Must contain
        /// only lowercase letters, digits, and underscores, and cannot begin
        /// with a digit. Must not be the same name as an existing user or
        /// role.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateRoleResponse createRole( string name,
                                              IDictionary<string, string> options )
        {
            return createRole( new CreateRoleRequest( name, options ) );
        }


        /// <summary>Creates a new table or collection. If a new table is being
        /// created, the type of the table is given by <paramref
        /// cref="CreateTableRequest.type_id" />, which must the be the ID of a
        /// currently registered type (i.e. one created via <see
        /// cref="Kinetica.createType(CreateTypeRequest)" />). The table will
        /// be created inside a collection if the option <i>collection_name</i>
        /// is specified. If that collection does not already exist, it will be
        /// created.
        /// <br />
        /// To create a new collection, specify the name of the collection in
        /// <paramref cref="CreateTableRequest.table_name" /> and set the
        /// <i>is_collection</i> option to <i>true</i>; <paramref
        /// cref="CreateTableRequest.type_id" /> will be ignored.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTableResponse createTable( CreateTableRequest request_ )
        {
            CreateTableResponse actualResponse_ = SubmitRequest<CreateTableResponse>("/create/table", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a new table or collection. If a new table is being
        /// created, the type of the table is given by <paramref name="type_id"
        /// />, which must the be the ID of a currently registered type (i.e.
        /// one created via <see
        /// cref="Kinetica.createType(string,string,IDictionary{string, IList{string}},IDictionary{string, string})"
        /// />). The table will be created inside a collection if the option
        /// <i>collection_name</i> is specified. If that collection does not
        /// already exist, it will be created.
        /// <br />
        /// To create a new collection, specify the name of the collection in
        /// <paramref name="table_name" /> and set the <i>is_collection</i>
        /// option to <i>true</i>; <paramref name="type_id" /> will be
        /// ignored.</summary>
        /// 
        /// <param name="table_name">Name of the table to be created. Error for
        /// requests with existing table of the same name and type id may be
        /// suppressed by using the <i>no_error_if_exists</i> option.  See <a
        /// href="../../../../concepts/tables.html" target="_top">Tables</a>
        /// for naming restrictions.  </param>
        /// <param name="type_id">ID of a currently registered type. All
        /// objects added to the newly created table will be of this type.
        /// Ignored if <i>is_collection</i> is <i>true</i>.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>no_error_if_exists</term>
        ///         <description>If <i>true</i>, prevents an error from
        /// occurring if the table already exists and is of the given type.  If
        /// a table with the same ID but a different type exists, it is still
        /// an error. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection which is to contain the
        /// newly created table. If empty, then the newly created table will be
        /// a top-level table. If the collection does not allow duplicate types
        /// and it contains a table of the same type as the given one, then
        /// this table creation request will fail.</description>
        ///     </item>
        ///     <item>
        ///         <term>is_collection</term>
        ///         <description>Indicates whether the new table to be created
        /// will be a collection. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>disallow_homogeneous_tables</term>
        ///         <description>For a collection, indicates whether the
        /// collection prohibits containment of multiple tables of exactly the
        /// same data type. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>is_replicated</term>
        ///         <description>For a table, indicates whether the table is to
        /// be replicated to all the database ranks. This may be necessary when
        /// the table is to be joined with other tables in a query. Values:
        /// true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>foreign_keys</term>
        ///         <description>Semicolon-separated list of foreign key
        /// constraints, of the format 'source_column references
        /// target_table(primary_key_column)'.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTableResponse createTable( string table_name,
                                                string type_id,
                                                IDictionary<string, string> options = null )
        {
            return createTable( new CreateTableRequest( table_name, type_id, options ) );
        }


        /// <summary>Creates a monitor that watches for new records inserted
        /// into a particular table (identified by <paramref
        /// cref="CreateTableMonitorRequest.table_name" />) and forwards copies
        /// to subscribers via ZMQ. After this call completes, subscribe to the
        /// returned <paramref cref="CreateTableMonitorResponse.topic_id" /> on
        /// the ZMQ table monitor port (default 9002). Each time an insert
        /// operation on the table completes, a multipart message is published
        /// for that topic; the first part contains only the topic ID, and each
        /// subsequent part contains one binary-encoded Avro object that was
        /// inserted. The monitor will continue to run (regardless of whether
        /// or not there are any subscribers) until deactivated with <see
        /// cref="Kinetica.clearTableMonitor(ClearTableMonitorRequest)"
        /// />.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTableMonitorResponse createTableMonitor( CreateTableMonitorRequest request_ )
        {
            CreateTableMonitorResponse actualResponse_ = SubmitRequest<CreateTableMonitorResponse>("/create/tablemonitor", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a monitor that watches for new records inserted
        /// into a particular table (identified by <paramref name="table_name"
        /// />) and forwards copies to subscribers via ZMQ. After this call
        /// completes, subscribe to the returned <paramref
        /// cref="CreateTableMonitorResponse.topic_id" /> on the ZMQ table
        /// monitor port (default 9002). Each time an insert operation on the
        /// table completes, a multipart message is published for that topic;
        /// the first part contains only the topic ID, and each subsequent part
        /// contains one binary-encoded Avro object that was inserted. The
        /// monitor will continue to run (regardless of whether or not there
        /// are any subscribers) until deactivated with <see
        /// cref="Kinetica.clearTableMonitor(string,IDictionary{string, string})"
        /// />.</summary>
        /// 
        /// <param name="table_name">Name of the table to monitor. Must not
        /// refer to a collection.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTableMonitorResponse createTableMonitor( string table_name,
                                                              IDictionary<string, string> options = null )
        {
            return createTableMonitor( new CreateTableMonitorRequest( table_name, options ) );
        }


        /// <summary>Sets up an area trigger mechanism for two column_names for
        /// one or more tables. (This function is essentially the
        /// two-dimensional version of <see
        /// cref="Kinetica.createTriggerByRange(CreateTriggerByRangeRequest)"
        /// />.) Once the trigger has been activated, any record added to the
        /// listed tables(s) via <see
        /// cref="Kinetica.insertRecordsRaw(RawInsertRecordsRequest)" /> with
        /// the chosen columns' values falling within the specified region will
        /// trip the trigger. All such records will be queued at the trigger
        /// port (by default '9001', but able to be retrieved via <see
        /// cref="Kinetica.showSystemStatus(ShowSystemStatusRequest)" />) for
        /// any listening client to collect. Active triggers can be cancelled
        /// by using the <see cref="Kinetica.clearTrigger(ClearTriggerRequest)"
        /// /> endpoint or by clearing all relevant tables.
        /// <br />
        /// The output returns the trigger handle as well as indicating success
        /// or failure of the trigger activation.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTriggerByAreaResponse createTriggerByArea( CreateTriggerByAreaRequest request_ )
        {
            CreateTriggerByAreaResponse actualResponse_ = SubmitRequest<CreateTriggerByAreaResponse>("/create/trigger/byarea", request_, false);

            return actualResponse_;
        }


        /// <summary>Sets up an area trigger mechanism for two column_names for
        /// one or more tables. (This function is essentially the
        /// two-dimensional version of <see
        /// cref="Kinetica.createTriggerByRange(string,IList{string},string,double,double,IDictionary{string, string})"
        /// />.) Once the trigger has been activated, any record added to the
        /// listed tables(s) via <see
        /// cref="Kinetica.insertRecords{T}(string,IList{T},IDictionary{string, string})"
        /// /> with the chosen columns' values falling within the specified
        /// region will trip the trigger. All such records will be queued at
        /// the trigger port (by default '9001', but able to be retrieved via
        /// <see
        /// cref="Kinetica.showSystemStatus(IDictionary{string, string})" />)
        /// for any listening client to collect. Active triggers can be
        /// cancelled by using the <see
        /// cref="Kinetica.clearTrigger(string,IDictionary{string, string})"
        /// /> endpoint or by clearing all relevant tables.
        /// <br />
        /// The output returns the trigger handle as well as indicating success
        /// or failure of the trigger activation.</summary>
        /// 
        /// <param name="request_id">ID for the trigger to be activated.
        /// </param>
        /// <param name="table_names">Names of the tables on which the trigger
        /// will be activated and maintained.  </param>
        /// <param name="x_column_name">Name of a numeric column on which the
        /// trigger is activated. Usually 'x' for geospatial data points.
        /// </param>
        /// <param name="x_vector">The respective coordinate values for the
        /// region on which the trigger is activated. This usually translates
        /// to the x-coordinates of a geospatial region.  </param>
        /// <param name="y_column_name">Name of a second numeric column on
        /// which the trigger is activated. Usually 'y' for geospatial data
        /// points.  </param>
        /// <param name="y_vector">The respective coordinate values for the
        /// region on which the trigger is activated. This usually translates
        /// to the y-coordinates of a geospatial region. Must be the same
        /// length as xvals.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTriggerByAreaResponse createTriggerByArea( string request_id,
                                                                IList<string> table_names,
                                                                string x_column_name,
                                                                IList<double> x_vector,
                                                                string y_column_name,
                                                                IList<double> y_vector,
                                                                IDictionary<string, string> options = null )
        {
            return createTriggerByArea( new CreateTriggerByAreaRequest( request_id,
                                                                        table_names,
                                                                        x_column_name,
                                                                        x_vector,
                                                                        y_column_name,
                                                                        y_vector, options ) );
        }


        /// <summary>Sets up a simple range trigger for a column_name for one
        /// or more tables. Once the trigger has been activated, any record
        /// added to the listed tables(s) via <see
        /// cref="Kinetica.insertRecordsRaw(RawInsertRecordsRequest)" /> with
        /// the chosen column_name's value falling within the specified range
        /// will trip the trigger. All such records will be queued at the
        /// trigger port (by default '9001', but able to be retrieved via <see
        /// cref="Kinetica.showSystemStatus(ShowSystemStatusRequest)" />) for
        /// any listening client to collect. Active triggers can be cancelled
        /// by using the <see cref="Kinetica.clearTrigger(ClearTriggerRequest)"
        /// /> endpoint or by clearing all relevant tables.
        /// <br />
        /// The output returns the trigger handle as well as indicating success
        /// or failure of the trigger activation.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTriggerByRangeResponse createTriggerByRange( CreateTriggerByRangeRequest request_ )
        {
            CreateTriggerByRangeResponse actualResponse_ = SubmitRequest<CreateTriggerByRangeResponse>("/create/trigger/byrange", request_, false);

            return actualResponse_;
        }


        /// <summary>Sets up a simple range trigger for a column_name for one
        /// or more tables. Once the trigger has been activated, any record
        /// added to the listed tables(s) via <see
        /// cref="Kinetica.insertRecords{T}(string,IList{T},IDictionary{string, string})"
        /// /> with the chosen column_name's value falling within the specified
        /// range will trip the trigger. All such records will be queued at the
        /// trigger port (by default '9001', but able to be retrieved via <see
        /// cref="Kinetica.showSystemStatus(IDictionary{string, string})" />)
        /// for any listening client to collect. Active triggers can be
        /// cancelled by using the <see
        /// cref="Kinetica.clearTrigger(string,IDictionary{string, string})"
        /// /> endpoint or by clearing all relevant tables.
        /// <br />
        /// The output returns the trigger handle as well as indicating success
        /// or failure of the trigger activation.</summary>
        /// 
        /// <param name="request_id">ID for the trigger request.  </param>
        /// <param name="table_names">Tables on which the trigger will be
        /// active.  </param>
        /// <param name="column_name">Name of a numeric column_name on which
        /// the trigger is activated.  </param>
        /// <param name="min">The lower bound (inclusive) for the trigger
        /// range.  </param>
        /// <param name="max">The upper bound (inclusive) for the trigger
        /// range.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTriggerByRangeResponse createTriggerByRange( string request_id,
                                                                  IList<string> table_names,
                                                                  string column_name,
                                                                  double min,
                                                                  double max,
                                                                  IDictionary<string, string> options = null )
        {
            return createTriggerByRange( new CreateTriggerByRangeRequest( request_id,
                                                                          table_names,
                                                                          column_name,
                                                                          min, max,
                                                                          options ) );
        }


        /// <summary>Creates a new type describing the layout or schema of a
        /// table. The type definition is a JSON string describing the fields
        /// (i.e. columns) of the type. Each field consists of a name and a
        /// data type. Supported data types are: double, float, int, long,
        /// string, and bytes. In addition one or more properties can be
        /// specified for each column which customize the memory usage and
        /// query availability of that column.  Note that some properties are
        /// mutually exclusive--i.e. they cannot be specified for any given
        /// column simultaneously.  One example of mutually exclusive
        /// properties are <i>data</i> and <i>store_only</i>.
        /// <br />
        /// To set a *primary key* on one or more columns include the property
        /// 'primary_key' on the desired column_names. If a primary key is
        /// specified, then a uniqueness constraint is enforced, in that only a
        /// single object can exist with a given primary key. When <see
        /// cref="Kinetica.insertRecordsRaw(RawInsertRecordsRequest)">inserting</see>
        /// data into a table with a primary key, depending on the parameters
        /// in the request, incoming objects with primary keys that match
        /// existing objects will either overwrite (i.e. update) the existing
        /// object or will be skipped and not added into the set.
        /// <br />
        /// Example of a type definition with some of the parameters::
        /// <br />
        ///         {"type":"record",
        ///         "name":"point",
        ///         "fields":[{"name":"msg_id","type":"string"},
        ///                         {"name":"x","type":"double"},
        ///                         {"name":"y","type":"double"},
        ///                         {"name":"TIMESTAMP","type":"double"},
        ///                         {"name":"source","type":"string"},
        ///                         {"name":"group_id","type":"string"},
        ///                         {"name":"OBJECT_ID","type":"string"}]
        ///         }
        /// <br />
        /// Properties::
        /// <br />
        ///         {"group_id":["store_only"],
        ///         "msg_id":["store_only","text_search"]
        ///         }</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTypeResponse createType( CreateTypeRequest request_ )
        {
            CreateTypeResponse actualResponse_ = SubmitRequest<CreateTypeResponse>("/create/type", request_, false);

            SetDecoderIfMissing( actualResponse_.type_id,
                                 actualResponse_.label,
                                 actualResponse_.type_definition,
                                 actualResponse_.properties );
            return actualResponse_;
        }


        /// <summary>Creates a new type describing the layout or schema of a
        /// table. The type definition is a JSON string describing the fields
        /// (i.e. columns) of the type. Each field consists of a name and a
        /// data type. Supported data types are: double, float, int, long,
        /// string, and bytes. In addition one or more properties can be
        /// specified for each column which customize the memory usage and
        /// query availability of that column.  Note that some properties are
        /// mutually exclusive--i.e. they cannot be specified for any given
        /// column simultaneously.  One example of mutually exclusive
        /// properties are <i>data</i> and <i>store_only</i>.
        /// <br />
        /// To set a *primary key* on one or more columns include the property
        /// 'primary_key' on the desired column_names. If a primary key is
        /// specified, then a uniqueness constraint is enforced, in that only a
        /// single object can exist with a given primary key. When <see
        /// cref="Kinetica.insertRecords{T}(string,IList{T},IDictionary{string, string})">inserting</see>
        /// data into a table with a primary key, depending on the parameters
        /// in the request, incoming objects with primary keys that match
        /// existing objects will either overwrite (i.e. update) the existing
        /// object or will be skipped and not added into the set.
        /// <br />
        /// Example of a type definition with some of the parameters::
        /// <br />
        ///         {"type":"record",
        ///         "name":"point",
        ///         "fields":[{"name":"msg_id","type":"string"},
        ///                         {"name":"x","type":"double"},
        ///                         {"name":"y","type":"double"},
        ///                         {"name":"TIMESTAMP","type":"double"},
        ///                         {"name":"source","type":"string"},
        ///                         {"name":"group_id","type":"string"},
        ///                         {"name":"OBJECT_ID","type":"string"}]
        ///         }
        /// <br />
        /// Properties::
        /// <br />
        ///         {"group_id":["store_only"],
        ///         "msg_id":["store_only","text_search"]
        ///         }</summary>
        /// 
        /// <param name="type_definition">a JSON string describing the columns
        /// of the type to be registered.  </param>
        /// <param name="label">A user-defined description string which can be
        /// used to differentiate between tables and types with otherwise
        /// identical schemas.  </param>
        /// <param name="properties">Each key-value pair specifies the
        /// properties to use for a given column where the key is the column
        /// name.  All keys used must be relevant column names for the given
        /// table.  Specifying any property overrides the default properties
        /// for that column (which is based on the column's data type).
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateTypeResponse createType( string type_definition,
                                              string label,
                                              IDictionary<string, IList<string>> properties = null,
                                              IDictionary<string, string> options = null )
        {
            return createType( new CreateTypeRequest( type_definition, label, properties,
                                                      options ) );
        }


        /// <summary>Creates a table that is the concatenation of one or more
        /// existing tables. It is equivalent to the SQL UNION ALL operator.
        /// Non-charN 'string' and 'bytes' column types cannot be included in a
        /// union, neither can columns with the property
        /// 'store_only'.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateUnionResponse createUnion( CreateUnionRequest request_ )
        {
            CreateUnionResponse actualResponse_ = SubmitRequest<CreateUnionResponse>("/create/union", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a table that is the concatenation of one or more
        /// existing tables. It is equivalent to the SQL UNION ALL operator.
        /// Non-charN 'string' and 'bytes' column types cannot be included in a
        /// union, neither can columns with the property
        /// 'store_only'.</summary>
        /// 
        /// <param name="table_name">Name of the table to be created. Has the
        /// same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// </param>
        /// <param name="table_names">The list of table names making up the
        /// union. Must contain the names of one or more existing tables.
        /// </param>
        /// <param name="input_column_names">The list of columns from each of
        /// the corresponding input tables.  </param>
        /// <param name="output_column_names">The list of names of the columns
        /// to be stored in the union.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection which is to contain the
        /// union. If empty, then the union will be a top-level
        /// table.</description>
        ///     </item>
        ///     <item>
        ///         <term>materialize_on_gpu</term>
        ///         <description>If 'true' then the columns of the union will
        /// be cached on the GPU. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>mode</term>
        ///         <description>If 'merge_views' then this operation will
        /// merge (i.e. union) the provided views. All 'table_names' must be
        /// views from the same underlying base table. Values: union_all,
        /// union, union_distinct, except, intersect, merge_views.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>chunk_size</term>
        ///         <description>Chunk size for this union</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateUnionResponse createUnion( string table_name,
                                                IList<string> table_names,
                                                IList<IList<string>> input_column_names,
                                                IList<string> output_column_names,
                                                IDictionary<string, string> options = null )
        {
            return createUnion( new CreateUnionRequest( table_name, table_names,
                                                        input_column_names,
                                                        output_column_names, options ) );
        }


        /// <summary>Creates a new external user (a user whose credentials are
        /// managed by an external LDAP).</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateUserExternalResponse createUserExternal( CreateUserExternalRequest request_ )
        {
            CreateUserExternalResponse actualResponse_ = SubmitRequest<CreateUserExternalResponse>("/create/user/external", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a new external user (a user whose credentials are
        /// managed by an external LDAP).</summary>
        /// 
        /// <param name="name">Name of the user to be created. Must exactly
        /// match the user's name in the external LDAP, prefixed with a @. Must
        /// not be the same name as an existing user.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateUserExternalResponse createUserExternal( string name,
                                                              IDictionary<string, string> options )
        {
            return createUserExternal( new CreateUserExternalRequest( name, options ) );
        }


        /// <summary>Creates a new internal user (a user whose credentials are
        /// managed by the database system).</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateUserInternalResponse createUserInternal( CreateUserInternalRequest request_ )
        {
            CreateUserInternalResponse actualResponse_ = SubmitRequest<CreateUserInternalResponse>("/create/user/internal", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates a new internal user (a user whose credentials are
        /// managed by the database system).</summary>
        /// 
        /// <param name="name">Name of the user to be created. Must contain
        /// only lowercase letters, digits, and underscores, and cannot begin
        /// with a digit. Must not be the same name as an existing user or
        /// role.  </param>
        /// <param name="password">Initial password of the user to be created.
        /// May be an empty string for no password.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public CreateUserInternalResponse createUserInternal( string name,
                                                              string password,
                                                              IDictionary<string, string> options )
        {
            return createUserInternal( new CreateUserInternalRequest( name, password,
                                                                      options ) );
        }


        /// <summary>Deletes a proc. Any currently running instances of the
        /// proc will be killed.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteProcResponse deleteProc( DeleteProcRequest request_ )
        {
            DeleteProcResponse actualResponse_ = SubmitRequest<DeleteProcResponse>("/delete/proc", request_, false);

            return actualResponse_;
        }


        /// <summary>Deletes a proc. Any currently running instances of the
        /// proc will be killed.</summary>
        /// 
        /// <param name="proc_name">Name of the proc to be deleted. Must be the
        /// name of a currently existing proc.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteProcResponse deleteProc( string proc_name,
                                              IDictionary<string, string> options = null )
        {
            return deleteProc( new DeleteProcRequest( proc_name, options ) );
        }


        /// <summary>Deletes record(s) matching the provided criteria from the
        /// given table. The record selection criteria can either be one or
        /// more  <paramref cref="DeleteRecordsRequest.expressions" />
        /// (matching multiple records) or a single record identified by
        /// <i>record_id</i> options.  Note that the two selection criteria are
        /// mutually exclusive.  This operation cannot be run on a collection
        /// or a view.  The operation is synchronous meaning that a response
        /// will not be available until the request is completely processed and
        /// all the matching records are deleted.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteRecordsResponse deleteRecords( DeleteRecordsRequest request_ )
        {
            DeleteRecordsResponse actualResponse_ = SubmitRequest<DeleteRecordsResponse>("/delete/records", request_, false);

            return actualResponse_;
        }


        /// <summary>Deletes record(s) matching the provided criteria from the
        /// given table. The record selection criteria can either be one or
        /// more  <paramref name="expressions" /> (matching multiple records)
        /// or a single record identified by <i>record_id</i> options.  Note
        /// that the two selection criteria are mutually exclusive.  This
        /// operation cannot be run on a collection or a view.  The operation
        /// is synchronous meaning that a response will not be available until
        /// the request is completely processed and all the matching records
        /// are deleted.</summary>
        /// 
        /// <param name="table_name">Name of the table from which to delete
        /// records. The set must be a currently existing table and not a
        /// collection or a view.  </param>
        /// <param name="expressions">A list of the actual predicates, one for
        /// each select; format should follow the guidelines provided /filter.
        /// Specifying one or more <paramref
        /// cref="DeleteRecordsRequest.expressions" /> is mutually exclusive to
        /// specifying <i>record_id</i> in the <paramref
        /// cref="DeleteRecordsRequest.options" />.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>global_expression</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the <paramref
        /// cref="DeleteRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term>record_id</term>
        ///         <description>A record id identifying a single record,
        /// obtained at the time of /insert/records or by calling
        /// /get/records/fromcollection with the *return_record_ids*
        /// option.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteRecordsResponse deleteRecords( string table_name,
                                                    IList<string> expressions,
                                                    IDictionary<string, string> options = null )
        {
            return deleteRecords( new DeleteRecordsRequest( table_name, expressions,
                                                            options ) );
        }


        /// <summary>Deletes an existing role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteRoleResponse deleteRole( DeleteRoleRequest request_ )
        {
            DeleteRoleResponse actualResponse_ = SubmitRequest<DeleteRoleResponse>("/delete/role", request_, false);

            return actualResponse_;
        }


        /// <summary>Deletes an existing role.</summary>
        /// 
        /// <param name="name">Name of the role to be deleted. Must be an
        /// existing role.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteRoleResponse deleteRole( string name,
                                              IDictionary<string, string> options )
        {
            return deleteRole( new DeleteRoleRequest( name, options ) );
        }


        /// <summary>Deletes an existing user.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteUserResponse deleteUser( DeleteUserRequest request_ )
        {
            DeleteUserResponse actualResponse_ = SubmitRequest<DeleteUserResponse>("/delete/user", request_, false);

            return actualResponse_;
        }


        /// <summary>Deletes an existing user.</summary>
        /// 
        /// <param name="name">Name of the user to be deleted. Must be an
        /// existing user.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public DeleteUserResponse deleteUser( string name,
                                              IDictionary<string, string> options )
        {
            return deleteUser( new DeleteUserRequest( name, options ) );
        }


        /// <summary>Executes a proc. This endpoint is asynchronous and does
        /// not wait for the proc to complete before returning.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ExecuteProcResponse executeProc( ExecuteProcRequest request_ )
        {
            ExecuteProcResponse actualResponse_ = SubmitRequest<ExecuteProcResponse>("/execute/proc", request_, false);

            return actualResponse_;
        }


        /// <summary>Executes a proc. This endpoint is asynchronous and does
        /// not wait for the proc to complete before returning.</summary>
        /// 
        /// <param name="proc_name">Name of the proc to execute. Must be the
        /// name of a currently existing proc.  </param>
        /// <param name="_params">A map containing named parameters to pass to
        /// the proc. Each key/value pair specifies the name of a parameter and
        /// its value.  </param>
        /// <param name="bin_params">A map containing named binary parameters
        /// to pass to the proc. Each key/value pair specifies the name of a
        /// parameter and its value.  </param>
        /// <param name="input_table_names">Names of the tables containing data
        /// to be passed to the proc. Each name specified must be the name of a
        /// currently existing table. If no table names are specified, no data
        /// will be passed to the proc.  </param>
        /// <param name="input_column_names">Map of table names from <paramref
        /// cref="ExecuteProcRequest.input_table_names" /> to lists of names of
        /// columns from those tables that will be passed to the proc. Each
        /// column name specified must be the name of an existing column in the
        /// corresponding table. If a table name from <paramref
        /// cref="ExecuteProcRequest.input_table_names" /> is not included, all
        /// columns from that table will be passed to the proc.  </param>
        /// <param name="output_table_names">Names of the tables to which
        /// output data from the proc will be written. If a specified table
        /// does not exist, it will automatically be created with the same
        /// schema as the corresponding table (by order) from <paramref
        /// cref="ExecuteProcRequest.input_table_names" />, excluding any
        /// primary and shard keys. If no table names are specified, no output
        /// data can be returned from the proc.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>cache_input</term>
        ///         <description>A comma-delimited list of table names from
        /// <paramref cref="ExecuteProcRequest.input_table_names" /> from which
        /// input data will be cached for use in subsequent calls to
        /// /execute/proc with the <i>use_cached_input</i> option. Cached input
        /// data will be retained until the proc status is cleared with the
        /// /show/proc/status option of /show/proc/status and all proc
        /// instances using the cached data have completed.</description>
        ///     </item>
        ///     <item>
        ///         <term>use_cached_input</term>
        ///         <description>A comma-delimited list of run IDs (as returned
        /// from prior calls to /execute/proc) of running or completed proc
        /// instances from which input data cached using the <i>cache_input</i>
        /// option will be used. Cached input data will not be used for any
        /// tables specified in <paramref
        /// cref="ExecuteProcRequest.input_table_names" />, but data from all
        /// other tables cached for the specified run IDs will be passed to the
        /// proc. If the same table was cached for multiple specified run IDs,
        /// the cached data from the first run ID specified in the list that
        /// includes that table will be used.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ExecuteProcResponse executeProc( string proc_name,
                                                IDictionary<string, string> _params = null,
                                                IDictionary<string, byte[]> bin_params = null,
                                                IList<string> input_table_names = null,
                                                IDictionary<string, IList<string>> input_column_names = null,
                                                IList<string> output_table_names = null,
                                                IDictionary<string, string> options = null )
        {
            return executeProc( new ExecuteProcRequest( proc_name, _params, bin_params,
                                                        input_table_names,
                                                        input_column_names,
                                                        output_table_names, options ) );
        }


        /// <summary>Filters data based on the specified expression.  The
        /// results are stored in a result set with the given <paramref
        /// cref="FilterRequest.view_name" />.
        /// <br />
        /// For details see <a href="../../../../concepts/expressions.html"
        /// target="_top">concepts</a>.
        /// <br />
        /// The response message contains the number of points for which the
        /// expression evaluated to be true, which is equivalent to the size of
        /// the result view.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterResponse filter( FilterRequest request_ )
        {
            FilterResponse actualResponse_ = SubmitRequest<FilterResponse>("/filter", request_, false);

            return actualResponse_;
        }


        /// <summary>Filters data based on the specified expression.  The
        /// results are stored in a result set with the given <paramref
        /// name="view_name" />.
        /// <br />
        /// For details see <a href="../../../../concepts/expressions.html"
        /// target="_top">concepts</a>.
        /// <br />
        /// The response message contains the number of points for which the
        /// expression evaluated to be true, which is equivalent to the size of
        /// the result view.</summary>
        /// 
        /// <param name="table_name">Name of the table to filter.  This may be
        /// the ID of a collection, table or a result set (for chaining
        /// queries).  Collections may be filtered only if all tables within
        /// the collection have the same type ID.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="expression">The select expression to filter the
        /// specified table.  For details see <a
        /// href="../../../../concepts/expressions.html"
        /// target="_top">concepts</a>.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterResponse filter( string table_name,
                                      string view_name,
                                      string expression,
                                      IDictionary<string, string> options = null )
        {
            return filter( new FilterRequest( table_name, view_name, expression, options ) );
        }


        /// <summary>Calculates which objects from a table are within a named
        /// area of interest (NAI/polygon). The operation is synchronous,
        /// meaning that a response will not be returned until all the matching
        /// objects are fully available. The response payload provides the
        /// count of the resulting set. A new resultant set (view) which
        /// satisfies the input NAI restriction specification is created with
        /// the name <paramref cref="FilterByAreaRequest.view_name" /> passed
        /// in as part of the input.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByAreaResponse filterByArea( FilterByAreaRequest request_ )
        {
            FilterByAreaResponse actualResponse_ = SubmitRequest<FilterByAreaResponse>("/filter/byarea", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates which objects from a table are within a named
        /// area of interest (NAI/polygon). The operation is synchronous,
        /// meaning that a response will not be returned until all the matching
        /// objects are fully available. The response payload provides the
        /// count of the resulting set. A new resultant set (view) which
        /// satisfies the input NAI restriction specification is created with
        /// the name <paramref name="view_name" /> passed in as part of the
        /// input.</summary>
        /// 
        /// <param name="table_name">Name of the table to filter.  This may be
        /// the name of a collection, a table or a view (when chaining
        /// queries).  Collections may be filtered only if all tables within
        /// the collection have the same type ID.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="x_column_name">Name of the column containing the x
        /// values to be filtered.  </param>
        /// <param name="x_vector">List of x coordinates of the vertices of the
        /// polygon representing the area to be filtered.  </param>
        /// <param name="y_column_name">Name of the column containing the y
        /// values to be filtered.  </param>
        /// <param name="y_vector">List of y coordinates of the vertices of the
        /// polygon representing the area to be filtered.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByAreaResponse filterByArea( string table_name,
                                                  string view_name,
                                                  string x_column_name,
                                                  IList<double> x_vector,
                                                  string y_column_name,
                                                  IList<double> y_vector,
                                                  IDictionary<string, string> options = null )
        {
            return filterByArea( new FilterByAreaRequest( table_name, view_name,
                                                          x_column_name, x_vector,
                                                          y_column_name, y_vector, options ) );
        }


        /// <summary>Calculates how many objects within the given table lie in
        /// a rectangular box. The operation is synchronous, meaning that a
        /// response will not be returned until all the objects are fully
        /// available. The response payload provides the count of the resulting
        /// set. A new resultant set which satisfies the input NAI restriction
        /// specification is also created when a <paramref
        /// cref="FilterByBoxRequest.view_name" /> is passed in as part of the
        /// input payload.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByBoxResponse filterByBox( FilterByBoxRequest request_ )
        {
            FilterByBoxResponse actualResponse_ = SubmitRequest<FilterByBoxResponse>("/filter/bybox", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates how many objects within the given table lie in
        /// a rectangular box. The operation is synchronous, meaning that a
        /// response will not be returned until all the objects are fully
        /// available. The response payload provides the count of the resulting
        /// set. A new resultant set which satisfies the input NAI restriction
        /// specification is also created when a <paramref name="view_name" />
        /// is passed in as part of the input payload.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the bounding
        /// box operation will be performed. Must be an existing table.
        /// </param>
        /// <param name="view_name">Optional name of the result view that will
        /// be created containing the results of the query. Has the same naming
        /// restrictions as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="x_column_name">Name of the column on which to perform
        /// the bounding box query. If the table's data type is not a shape
        /// type, must be a valid numeric column.  </param>
        /// <param name="min_x">Lower bound for the column chosen by <paramref
        /// cref="FilterByBoxRequest.x_column_name" />.  Must be less than or
        /// equal to <paramref cref="FilterByBoxRequest.max_x" />.  </param>
        /// <param name="max_x">Upper bound for <paramref
        /// cref="FilterByBoxRequest.x_column_name" />.  Must be greater than
        /// or equal to <paramref cref="FilterByBoxRequest.min_x" />.  </param>
        /// <param name="y_column_name">Name of a column on which to perform
        /// the bounding box query. If the table's data type is not a shape
        /// type, must be a valid numeric column.  </param>
        /// <param name="min_y">Lower bound for <paramref
        /// cref="FilterByBoxRequest.y_column_name" />. Must be less than or
        /// equal to <paramref cref="FilterByBoxRequest.max_y" />.  </param>
        /// <param name="max_y">Upper bound for <paramref
        /// cref="FilterByBoxRequest.y_column_name" />. Must be greater than or
        /// equal to <paramref cref="FilterByBoxRequest.min_y" />.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByBoxResponse filterByBox( string table_name,
                                                string view_name,
                                                string x_column_name,
                                                double min_x,
                                                double max_x,
                                                string y_column_name,
                                                double min_y,
                                                double max_y,
                                                IDictionary<string, string> options = null )
        {
            return filterByBox( new FilterByBoxRequest( table_name, view_name,
                                                        x_column_name, min_x, max_x,
                                                        y_column_name, min_y, max_y,
                                                        options ) );
        }


        /// <summary>Applies a geometry filter against a spatial column named
        /// WKT in a given table, collection or view. The filtering geometry is
        /// provided by <paramref cref="FilterByGeometryRequest.input_wkt"
        /// />.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByGeometryResponse filterByGeometry( FilterByGeometryRequest request_ )
        {
            FilterByGeometryResponse actualResponse_ = SubmitRequest<FilterByGeometryResponse>("/filter/bygeometry", request_, false);

            return actualResponse_;
        }


        /// <summary>Applies a geometry filter against a spatial column named
        /// WKT in a given table, collection or view. The filtering geometry is
        /// provided by <paramref name="input_wkt" />.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the filter by
        /// geometry will be performed.  Must be an existing table, collection
        /// or view containing a column named WKT.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="column_name">Name of the column to be used in the
        /// filter. Must be 'WKT'  </param>
        /// <param name="input_wkt">A geometry in WKT format that will be used
        /// to filter the objects in <paramref
        /// cref="FilterByGeometryRequest.table_name" />.  </param>
        /// <param name="operation">The geometric filtering operation to
        /// perform Values: contains, crosses, disjoint, equals, intersects,
        /// overlaps, touches, within.
        ///   </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByGeometryResponse filterByGeometry( string table_name,
                                                          string view_name,
                                                          string column_name,
                                                          string input_wkt,
                                                          string operation,
                                                          IDictionary<string, string> options = null )
        {
            return filterByGeometry( new FilterByGeometryRequest( table_name, view_name,
                                                                  column_name, input_wkt,
                                                                  operation, options ) );
        }


        /// <summary>Calculates which records from a table have values in the
        /// given list for the corresponding column. The operation is
        /// synchronous, meaning that a response will not be returned until all
        /// the objects are fully available. The response payload provides the
        /// count of the resulting set. A new resultant set (view) which
        /// satisfies the input filter specification is also created if a
        /// <paramref cref="FilterByListRequest.view_name" /> is passed in as
        /// part of the request.
        /// <br />
        /// For example, if a type definition has the columns 'x' and 'y', then
        /// a filter by list query with the column map {"x":["10.1", "2.3"],
        /// "y":["0.0", "-31.5", "42.0"]} will return the count of all data
        /// points whose x and y values match one of the values in the
        /// respective x- and y-lists. If the filter_mode option is set to
        /// 'not_in_list' then the filter will match all items that are not in
        /// the provided list(s).</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByListResponse filterByList( FilterByListRequest request_ )
        {
            FilterByListResponse actualResponse_ = SubmitRequest<FilterByListResponse>("/filter/bylist", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates which records from a table have values in the
        /// given list for the corresponding column. The operation is
        /// synchronous, meaning that a response will not be returned until all
        /// the objects are fully available. The response payload provides the
        /// count of the resulting set. A new resultant set (view) which
        /// satisfies the input filter specification is also created if a
        /// <paramref name="view_name" /> is passed in as part of the request.
        /// <br />
        /// For example, if a type definition has the columns 'x' and 'y', then
        /// a filter by list query with the column map {"x":["10.1", "2.3"],
        /// "y":["0.0", "-31.5", "42.0"]} will return the count of all data
        /// points whose x and y values match one of the values in the
        /// respective x- and y-lists. If the filter_mode option is set to
        /// 'not_in_list' then the filter will match all items that are not in
        /// the provided list(s).</summary>
        /// 
        /// <param name="table_name">Name of the table to filter.  This may be
        /// the ID of a collection, table or a result set (for chaining
        /// queries).  Collections may be filtered only if all tables within
        /// the collection have the same type ID.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="column_values_map">List of values for the
        /// corresponding column in the table  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>filter_mode</term>
        ///         <description>String indicating the filter mode, either
        /// 'in_list' or 'not_in_list'. Values: in_list, not_in_list.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByListResponse filterByList( string table_name,
                                                  string view_name,
                                                  IDictionary<string, IList<string>> column_values_map,
                                                  IDictionary<string, string> options = null )
        {
            return filterByList( new FilterByListRequest( table_name, view_name,
                                                          column_values_map, options ) );
        }


        /// <summary>Calculates which objects from a table lie within a circle
        /// with the given radius and center point (i.e. circular NAI). The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all the objects are fully available. The response
        /// payload provides the count of the resulting set. A new resultant
        /// set (view) which satisfies the input circular NAI restriction
        /// specification is also created if a <paramref
        /// cref="FilterByRadiusRequest.view_name" /> is passed in as part of
        /// the request.
        /// <br />
        /// For track data, all track points that lie within the circle plus
        /// one point on either side of the circle (if the track goes beyond
        /// the circle) will be included in the result. For shapes, e.g.
        /// polygons, all polygons that intersect the circle will be included
        /// (even if none of the points of the polygon fall within the
        /// circle).</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByRadiusResponse filterByRadius( FilterByRadiusRequest request_ )
        {
            FilterByRadiusResponse actualResponse_ = SubmitRequest<FilterByRadiusResponse>("/filter/byradius", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates which objects from a table lie within a circle
        /// with the given radius and center point (i.e. circular NAI). The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all the objects are fully available. The response
        /// payload provides the count of the resulting set. A new resultant
        /// set (view) which satisfies the input circular NAI restriction
        /// specification is also created if a <paramref name="view_name" /> is
        /// passed in as part of the request.
        /// <br />
        /// For track data, all track points that lie within the circle plus
        /// one point on either side of the circle (if the track goes beyond
        /// the circle) will be included in the result. For shapes, e.g.
        /// polygons, all polygons that intersect the circle will be included
        /// (even if none of the points of the polygon fall within the
        /// circle).</summary>
        /// 
        /// <param name="table_name">Name of the table on which the filter by
        /// radius operation will be performed.  Must be an existing table.
        /// </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="x_column_name">Name of the column to be used for the
        /// x-coordinate (the longitude) of the center.  </param>
        /// <param name="x_center">Value of the longitude of the center. Must
        /// be within [-180.0, 180.0].  The minimum allowed value is -180. The
        /// maximum allowed value is 180. </param>
        /// <param name="y_column_name">Name of the column to be used for the
        /// y-coordinate-the latitude-of the center.  </param>
        /// <param name="y_center">Value of the latitude of the center. Must be
        /// within [-90.0, 90.0].  The minimum allowed value is -90. The
        /// maximum allowed value is 90. </param>
        /// <param name="radius">The radius of the circle within which the
        /// search will be performed. Must be a non-zero positive value. It is
        /// in meters; so, for example, a value of '42000' means 42 km.  The
        /// minimum allowed value is 0. The maximum allowed value is MAX_INT.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByRadiusResponse filterByRadius( string table_name,
                                                      string view_name,
                                                      string x_column_name,
                                                      double x_center,
                                                      string y_column_name,
                                                      double y_center,
                                                      double radius,
                                                      IDictionary<string, string> options = null )
        {
            return filterByRadius( new FilterByRadiusRequest( table_name, view_name,
                                                              x_column_name, x_center,
                                                              y_column_name, y_center,
                                                              radius, options ) );
        }


        /// <summary>Calculates which objects from a table have a column that
        /// is within the given bounds. An object from the table identified by
        /// <paramref cref="FilterByRangeRequest.table_name" /> is added to the
        /// view <paramref cref="FilterByRangeRequest.view_name" /> if its
        /// column is within [<paramref cref="FilterByRangeRequest.lower_bound"
        /// />, <paramref cref="FilterByRangeRequest.upper_bound" />]
        /// (inclusive). The operation is synchronous. The response provides a
        /// count of the number of objects which passed the bound filter.
        /// Although this functionality can also be accomplished with the
        /// standard filter function, it is more efficient.
        /// <br />
        /// For track objects, the count reflects how many points fall within
        /// the given bounds (which may not include all the track points of any
        /// given track).</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByRangeResponse filterByRange( FilterByRangeRequest request_ )
        {
            FilterByRangeResponse actualResponse_ = SubmitRequest<FilterByRangeResponse>("/filter/byrange", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates which objects from a table have a column that
        /// is within the given bounds. An object from the table identified by
        /// <paramref name="table_name" /> is added to the view <paramref
        /// name="view_name" /> if its column is within [<paramref
        /// name="lower_bound" />, <paramref name="upper_bound" />]
        /// (inclusive). The operation is synchronous. The response provides a
        /// count of the number of objects which passed the bound filter.
        /// Although this functionality can also be accomplished with the
        /// standard filter function, it is more efficient.
        /// <br />
        /// For track objects, the count reflects how many points fall within
        /// the given bounds (which may not include all the track points of any
        /// given track).</summary>
        /// 
        /// <param name="table_name">Name of the table on which the filter by
        /// range operation will be performed.  Must be an existing table.
        /// </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="column_name">Name of a column on which the operation
        /// would be applied.  </param>
        /// <param name="lower_bound">Value of the lower bound (inclusive).
        /// </param>
        /// <param name="upper_bound">Value of the upper bound (inclusive).
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByRangeResponse filterByRange( string table_name,
                                                    string view_name,
                                                    string column_name,
                                                    double lower_bound,
                                                    double upper_bound,
                                                    IDictionary<string, string> options = null )
        {
            return filterByRange( new FilterByRangeRequest( table_name, view_name,
                                                            column_name, lower_bound,
                                                            upper_bound, options ) );
        }


        /// <summary>Filters objects matching all points of the given track
        /// (works only on track type data).  It allows users to specify a
        /// particular track to find all other points in the table that fall
        /// within specified ranges-spatial and temporal-of all points of the
        /// given track. Additionally, the user can specify another track to
        /// see if the two intersect (or go close to each other within the
        /// specified ranges). The user also has the flexibility of using
        /// different metrics for the spatial distance calculation: Euclidean
        /// (flat geometry) or Great Circle (spherical geometry to approximate
        /// the Earth's surface distances). The filtered points are stored in a
        /// newly created result set. The return value of the function is the
        /// number of points in the resultant set (view).
        /// <br />
        /// This operation is synchronous, meaning that a response will not be
        /// returned until all the objects are fully available.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterBySeriesResponse filterBySeries( FilterBySeriesRequest request_ )
        {
            FilterBySeriesResponse actualResponse_ = SubmitRequest<FilterBySeriesResponse>("/filter/byseries", request_, false);

            return actualResponse_;
        }


        /// <summary>Filters objects matching all points of the given track
        /// (works only on track type data).  It allows users to specify a
        /// particular track to find all other points in the table that fall
        /// within specified ranges-spatial and temporal-of all points of the
        /// given track. Additionally, the user can specify another track to
        /// see if the two intersect (or go close to each other within the
        /// specified ranges). The user also has the flexibility of using
        /// different metrics for the spatial distance calculation: Euclidean
        /// (flat geometry) or Great Circle (spherical geometry to approximate
        /// the Earth's surface distances). The filtered points are stored in a
        /// newly created result set. The return value of the function is the
        /// number of points in the resultant set (view).
        /// <br />
        /// This operation is synchronous, meaning that a response will not be
        /// returned until all the objects are fully available.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the filter by
        /// track operation will be performed. Must be a currently existing
        /// table with track semantic type.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="track_id">The ID of the track which will act as the
        /// filtering points. Must be an existing track within the given table.
        /// </param>
        /// <param name="target_track_ids">Up to one track ID to intersect with
        /// the "filter" track. If any provided, it must be an valid track ID
        /// within the given set.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>spatial_radius</term>
        ///         <description>A positive number passed as a string
        /// representing the radius of the search area centered around each
        /// track point's geospatial coordinates. The value is interpreted in
        /// meters. Required parameter.</description>
        ///     </item>
        ///     <item>
        ///         <term>time_radius</term>
        ///         <description>A positive number passed as a string
        /// representing the maximum allowable time difference between the
        /// timestamps of a filtered object and the given track's points. The
        /// value is interpreted in seconds. Required parameter.</description>
        ///     </item>
        ///     <item>
        ///         <term>spatial_distance_metric</term>
        ///         <description>A string representing the coordinate system to
        /// use for the spatial search criteria. Acceptable values are
        /// 'euclidean' and 'great_circle'. Optional parameter; default is
        /// 'euclidean'. Values: euclidean, great_circle.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterBySeriesResponse filterBySeries( string table_name,
                                                      string view_name,
                                                      string track_id,
                                                      IList<string> target_track_ids,
                                                      IDictionary<string, string> options = null )
        {
            return filterBySeries( new FilterBySeriesRequest( table_name, view_name,
                                                              track_id, target_track_ids,
                                                              options ) );
        }


        /// <summary>Calculates which objects from a table, collection, or view
        /// match a string expression for the given string columns. The 'mode'
        /// may be:
        /// <br />
        /// * search : full text search query with wildcards and boolean
        /// operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this
        /// mode, no column can be specified in <paramref
        /// cref="FilterByStringRequest.column_names" />; all string columns of
        /// the table that have text search enabled will be searched. Also, the
        /// first character of a search term cannot be a wildcard (* or ?), and
        /// search terms cannot be any of the following:  "a", "an", "and",
        /// "are", "as", "at", "be", "but", "by", "for", "if", "in", "into",
        /// "is", "it", "no", "not", "of", "on", "or", "such", "that", "the",
        /// "their", "then", "there", "these", "they", "this", "to", "was",
        /// "will", "with".
        ///     Search query types:
        ///         * Multiple search terms
        ///             ex. perfect union - will match any record containing
        /// "perfect", "union", or both.
        ///         * Exact phrases
        ///             ex. "Perfect Union" - will only match the exact phrase
        /// "Perfect Union"
        ///         * Boolean (NOT, AND, OR, parentheses. OR assumed if no
        /// operator specified)
        ///             ex. justice AND tranquility - will match only those
        /// records containing both justice and tranquility
        ///         * Zero or more char wildcard - (specified with '*')
        ///             ex, est*is* - will match any records containing a word
        /// that starts with "est" and ends with "sh", such as "establish",
        /// "establishable", and "establishment"
        ///         * Exactly one char wildcard - (specified with ?)
        ///             ex. est???is* - will only match strings that start with
        /// "est", followed by exactly three letters, followed by "is",
        /// followed by one more letter.  This would only match "establish"
        ///         * Fuzzy search (term~)
        ///             ex. rear~ will match rear,fear,bear,read,etc.
        ///         * Proximity - match two words within a specified distance
        /// of eachother
        ///             ex. "Union Tranquility"~10 will match any record that
        /// has the words Union and Tranquility within 10 words of eachother
        ///         * Range - inclusive [<term1> TO <term2>] and exclusive
        /// {<term1> TO <term2>}.  Note: This is a string search, so numbers
        /// will be seen as a string of numeric characters, not as a number.
        /// Ex. 2 > 123
        ///             ex. [100 TO 200] will find all strings between 100 and
        /// 200 inclusive.
        ///             ex. {alpha to beta} will find all strings between alpha
        /// and beta, but not the words alpha or beta
        ///         * escaping special characters - Special characters are
        /// escaped with a backslash(\), special characters are: + - && || ! (
        /// ) { } [ ] ^ " ~ * ? : \
        /// <br />
        /// * equals: exact whole-string match (accelerated)
        /// * contains: partial substring match (not accelerated).  If the
        /// column is a string type (non-charN) and the number of records is
        /// too large, it will return 0.
        /// * starts_with: strings that start with the given expression (not
        /// accelerated), If the column is a string type (non-charN) and the
        /// number of records is too large, it will return 0.
        /// * regex: full regular expression search (not accelerated). If the
        /// column is a string type (non-charN) and the number of records is
        /// too large, it will return 0.
        /// <br />
        /// The options 'case_sensitive' can be used to modify the behavior for
        /// all modes except 'search'</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByStringResponse filterByString( FilterByStringRequest request_ )
        {
            FilterByStringResponse actualResponse_ = SubmitRequest<FilterByStringResponse>("/filter/bystring", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates which objects from a table, collection, or view
        /// match a string expression for the given string columns. The 'mode'
        /// may be:
        /// <br />
        /// * search : full text search query with wildcards and boolean
        /// operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this
        /// mode, no column can be specified in <paramref name="column_names"
        /// />; all string columns of the table that have text search enabled
        /// will be searched. Also, the first character of a search term cannot
        /// be a wildcard (* or ?), and search terms cannot be any of the
        /// following:  "a", "an", "and", "are", "as", "at", "be", "but", "by",
        /// "for", "if", "in", "into", "is", "it", "no", "not", "of", "on",
        /// "or", "such", "that", "the", "their", "then", "there", "these",
        /// "they", "this", "to", "was", "will", "with".
        ///     Search query types:
        ///         * Multiple search terms
        ///             ex. perfect union - will match any record containing
        /// "perfect", "union", or both.
        ///         * Exact phrases
        ///             ex. "Perfect Union" - will only match the exact phrase
        /// "Perfect Union"
        ///         * Boolean (NOT, AND, OR, parentheses. OR assumed if no
        /// operator specified)
        ///             ex. justice AND tranquility - will match only those
        /// records containing both justice and tranquility
        ///         * Zero or more char wildcard - (specified with '*')
        ///             ex, est*is* - will match any records containing a word
        /// that starts with "est" and ends with "sh", such as "establish",
        /// "establishable", and "establishment"
        ///         * Exactly one char wildcard - (specified with ?)
        ///             ex. est???is* - will only match strings that start with
        /// "est", followed by exactly three letters, followed by "is",
        /// followed by one more letter.  This would only match "establish"
        ///         * Fuzzy search (term~)
        ///             ex. rear~ will match rear,fear,bear,read,etc.
        ///         * Proximity - match two words within a specified distance
        /// of eachother
        ///             ex. "Union Tranquility"~10 will match any record that
        /// has the words Union and Tranquility within 10 words of eachother
        ///         * Range - inclusive [<term1> TO <term2>] and exclusive
        /// {<term1> TO <term2>}.  Note: This is a string search, so numbers
        /// will be seen as a string of numeric characters, not as a number.
        /// Ex. 2 > 123
        ///             ex. [100 TO 200] will find all strings between 100 and
        /// 200 inclusive.
        ///             ex. {alpha to beta} will find all strings between alpha
        /// and beta, but not the words alpha or beta
        ///         * escaping special characters - Special characters are
        /// escaped with a backslash(\), special characters are: + - && || ! (
        /// ) { } [ ] ^ " ~ * ? : \
        /// <br />
        /// * equals: exact whole-string match (accelerated)
        /// * contains: partial substring match (not accelerated).  If the
        /// column is a string type (non-charN) and the number of records is
        /// too large, it will return 0.
        /// * starts_with: strings that start with the given expression (not
        /// accelerated), If the column is a string type (non-charN) and the
        /// number of records is too large, it will return 0.
        /// * regex: full regular expression search (not accelerated). If the
        /// column is a string type (non-charN) and the number of records is
        /// too large, it will return 0.
        /// <br />
        /// The options 'case_sensitive' can be used to modify the behavior for
        /// all modes except 'search'</summary>
        /// 
        /// <param name="table_name">Name of the table on which the filter
        /// operation will be performed.  Must be an existing table, collection
        /// or view.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="expression">The expression with which to filter the
        /// table.  </param>
        /// <param name="mode">The string filtering mode to apply. See above
        /// for details. Values: search, equals, contains, starts_with, regex.
        ///   </param>
        /// <param name="column_names">List of columns on which to apply the
        /// filter. Ignored for 'search' mode.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>case_sensitive</term>
        ///         <description>If 'false' then string filtering will ignore
        /// case. Does not apply to 'search' mode. Values: true, false.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByStringResponse filterByString( string table_name,
                                                      string view_name,
                                                      string expression,
                                                      string mode,
                                                      IList<string> column_names,
                                                      IDictionary<string, string> options = null )
        {
            return filterByString( new FilterByStringRequest( table_name, view_name,
                                                              expression, mode,
                                                              column_names, options ) );
        }


        /// <summary>Filters objects in one table based on objects in another
        /// table. The user must specify matching column types from the two
        /// tables (i.e. the target table from which objects will be filtered
        /// and the source table based on which the filter will be created);
        /// the column names need not be the same. If a <paramref
        /// cref="FilterByTableRequest.view_name" /> is specified, then the
        /// filtered objects will then be put in a newly created view. The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all objects are fully available in the result view.
        /// The return value contains the count (i.e. the size) of the
        /// resulting view.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByTableResponse filterByTable( FilterByTableRequest request_ )
        {
            FilterByTableResponse actualResponse_ = SubmitRequest<FilterByTableResponse>("/filter/bytable", request_, false);

            return actualResponse_;
        }


        /// <summary>Filters objects in one table based on objects in another
        /// table. The user must specify matching column types from the two
        /// tables (i.e. the target table from which objects will be filtered
        /// and the source table based on which the filter will be created);
        /// the column names need not be the same. If a <paramref
        /// name="view_name" /> is specified, then the filtered objects will
        /// then be put in a newly created view. The operation is synchronous,
        /// meaning that a response will not be returned until all objects are
        /// fully available in the result view. The return value contains the
        /// count (i.e. the size) of the resulting view.</summary>
        /// 
        /// <param name="table_name">Name of the table whose data will be
        /// filtered. Must be an existing table.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="column_name">Name of the column by whose value the
        /// data will be filtered from the table designated by <paramref
        /// cref="FilterByTableRequest.table_name" />.  </param>
        /// <param name="source_table_name">Name of the table whose data will
        /// be compared against in the table called <paramref
        /// cref="FilterByTableRequest.table_name" />. Must be an existing
        /// table.  </param>
        /// <param name="source_table_column_name">Name of the column in the
        /// <paramref cref="FilterByTableRequest.source_table_name" /> whose
        /// values will be used as the filter for table <paramref
        /// cref="FilterByTableRequest.table_name" />. Must match the type of
        /// the <paramref cref="FilterByTableRequest.column_name" />.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>filter_mode</term>
        ///         <description>String indicating the filter mode, either
        /// <i>in_table</i> or <i>not_in_table</i>. Values: in_table,
        /// not_in_table.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>mode</term>
        ///         <description>Mode - should be either <i>spatial</i> or
        /// <i>normal</i>. Values: normal, spatial.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>buffer</term>
        ///         <description>Buffer size, in meters. Only relevant for
        /// <i>spatial</i> mode.</description>
        ///     </item>
        ///     <item>
        ///         <term>buffer_method</term>
        ///         <description>Method used to buffer polygons.  Only relevant
        /// for <i>spatial</i> mode. Values: normal, geos.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>max_partition_size</term>
        ///         <description>Maximum number of points in a partition. Only
        /// relevant for <i>spatial</i> mode.</description>
        ///     </item>
        ///     <item>
        ///         <term>max_partition_score</term>
        ///         <description>Maximum number of points * edges in a
        /// partition. Only relevant for <i>spatial</i> mode.</description>
        ///     </item>
        ///     <item>
        ///         <term>x_column_name</term>
        ///         <description>Name of column containing x value of point
        /// being filtered in <i>spatial</i> mode.</description>
        ///     </item>
        ///     <item>
        ///         <term>y_column_name</term>
        ///         <description>Name of column containing y value of point
        /// being filtered in <i>spatial</i> mode.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByTableResponse filterByTable( string table_name,
                                                    string view_name,
                                                    string column_name,
                                                    string source_table_name,
                                                    string source_table_column_name,
                                                    IDictionary<string, string> options = null )
        {
            return filterByTable( new FilterByTableRequest( table_name, view_name,
                                                            column_name,
                                                            source_table_name,
                                                            source_table_column_name,
                                                            options ) );
        }


        /// <summary>Calculates which objects from a table has a particular
        /// value for a particular column. The input parameters provide a way
        /// to specify either a String or a Double valued column and a desired
        /// value for the column on which the filter is performed. The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all the objects are fully available. The response
        /// payload provides the count of the resulting set. A new result view
        /// which satisfies the input filter restriction specification is also
        /// created with a view name passed in as part of the input payload.
        /// Although this functionality can also be accomplished with the
        /// standard filter function, it is more efficient.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByValueResponse filterByValue( FilterByValueRequest request_ )
        {
            FilterByValueResponse actualResponse_ = SubmitRequest<FilterByValueResponse>("/filter/byvalue", request_, false);

            return actualResponse_;
        }


        /// <summary>Calculates which objects from a table has a particular
        /// value for a particular column. The input parameters provide a way
        /// to specify either a String or a Double valued column and a desired
        /// value for the column on which the filter is performed. The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all the objects are fully available. The response
        /// payload provides the count of the resulting set. A new result view
        /// which satisfies the input filter restriction specification is also
        /// created with a view name passed in as part of the input payload.
        /// Although this functionality can also be accomplished with the
        /// standard filter function, it is more efficient.</summary>
        /// 
        /// <param name="table_name">Name of an existing table on which to
        /// perform the calculation.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="is_string">Indicates whether the value being searched
        /// for is string or numeric.  </param>
        /// <param name="_value">The value to search for.  </param>
        /// <param name="value_str">The string value to search for.  </param>
        /// <param name="column_name">Name of a column on which the filter by
        /// value would be applied.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public FilterByValueResponse filterByValue( string table_name,
                                                    string view_name,
                                                    bool is_string,
                                                    double _value,
                                                    string value_str,
                                                    string column_name,
                                                    IDictionary<string, string> options = null )
        {
            return filterByValue( new FilterByValueRequest( table_name, view_name,
                                                            is_string, _value, value_str,
                                                            column_name, options ) );
        }


        /// <summary>Retrieves records from a given table, optionally filtered
        /// by an expression and/or sorted by a column. This operation can be
        /// performed on tables, views, or on homogeneous collections
        /// (collections containing tables of all the same type). Records can
        /// be returned encoded as binary or json.
        /// <br />
        /// This operation supports paging through the data via the <paramref
        /// cref="GetRecordsRequest.offset" /> and <paramref
        /// cref="GetRecordsRequest.limit" /> parameters. Note that when paging
        /// through a table, if the table (or the underlying table in case of a
        /// view) is updated (records are inserted, deleted or modified) the
        /// records retrieved may differ between calls based on the updates
        /// applied.</summary>
        /// 
        /// <typeparam name="T">The type of object being retrieved.</typeparam>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsResponse<T> getRecords<T>( GetRecordsRequest request_ ) where T : new()
        {
            RawGetRecordsResponse actualResponse_ = SubmitRequest<RawGetRecordsResponse>("/get/records", request_, false);

            GetRecordsResponse<T> response_ = new GetRecordsResponse<T>();
            response_.table_name = actualResponse_.table_name;
            response_.type_name = actualResponse_.type_name;
            response_.type_schema = actualResponse_.type_schema;
            response_.data = new List<T>();
            this.DecodeRawBinaryDataUsingSchemaString<T>( response_.type_schema, actualResponse_.records_binary, response_.data );
            response_.total_number_of_records = actualResponse_.total_number_of_records;
            response_.has_more_records = actualResponse_.has_more_records;
            return response_;
        }


        /// <summary>Retrieves records from a given table, optionally filtered
        /// by an expression and/or sorted by a column. This operation can be
        /// performed on tables, views, or on homogeneous collections
        /// (collections containing tables of all the same type). Records can
        /// be returned encoded as binary or json.
        /// <br />
        /// This operation supports paging through the data via the <paramref
        /// name="offset" /> and <paramref name="limit" /> parameters. Note
        /// that when paging through a table, if the table (or the underlying
        /// table in case of a view) is updated (records are inserted, deleted
        /// or modified) the records retrieved may differ between calls based
        /// on the updates applied.</summary>
        /// 
        /// <typeparam name="T">The type of object being retrieved.</typeparam>
        /// 
        /// <param name="table_name">Name of the table from which the records
        /// will be fetched. Must be a table, view or homogeneous collection.
        /// </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of results to be returned. Or END_OF_SET (-9999) to indicate
        /// that the max number of results should be returned.  </param>
        /// <param name="options">
        /// <list type="bullet">
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Optional filter expression to apply to the
        /// table.</description>
        ///     </item>
        ///     <item>
        ///         <term>fast_index_lookup</term>
        ///         <description>Indicates if indexes should be used to perform
        /// the lookup for a given expression if possible. Only applicable if
        /// there is no sorting, the expression contains only equivalence
        /// comparisons based on existing tables indexes and the range of
        /// requested values is from [0 to END_OF_SET]. The default value is
        /// true.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_by</term>
        ///         <description>Optional column that the data should be sorted
        /// by. Empty by default (i.e. no sorting is applied).</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted - ascending or descending. If sort_order is
        /// provided, sort_by has to be provided. Values: ascending,
        /// descending.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsResponse<T> getRecords<T>( string table_name,
                                                    long offset = 0,
                                                    long limit = 10000,
                                                    IDictionary<string, string> options = null ) where T : new()
        {
            return getRecords<T>( new GetRecordsRequest( table_name, offset, limit,
                                                         options ) );
        }


        /// <summary>For a given table, retrieves the values of the given
        /// columns within a given range. It returns maps of column name to the
        /// vector of values for each supported data type (double, float, long,
        /// int and string). This operation supports pagination feature, i.e.
        /// values that are retrieved are those associated with the indices
        /// between the start (offset) and end value (offset + limit)
        /// parameters (inclusive). If there are num_points values in the table
        /// then each of the indices between 0 and num_points-1 retrieves a
        /// unique value.
        /// <br />
        /// Note that when using the pagination feature, if the table (or the
        /// underlying table in case of a view) is updated (records are
        /// inserted, deleted or modified) the records or values retrieved may
        /// differ between calls (discontiguous or overlap) based on the type
        /// of the update.
        /// <br />
        /// The response is returned as a dynamic schema. For details see: <a
        /// href="../../../../concepts/dynamic_schemas.html"
        /// target="_top">dynamic schemas documentation</a>.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsByColumnResponse getRecordsByColumn( GetRecordsByColumnRequest request_ )
        {
            RawGetRecordsByColumnResponse actualResponse_ = SubmitRequest<RawGetRecordsByColumnResponse>("/get/records/bycolumn", request_, false);

            GetRecordsByColumnResponse response_ = new GetRecordsByColumnResponse();
            response_.table_name = actualResponse_.table_name;
            response_.data = KineticaRecord.DecodeDynamicTableRecords( actualResponse_.response_schema_str, actualResponse_.binary_encoded_response );
            response_.total_number_of_records = actualResponse_.total_number_of_records;
            response_.has_more_records = actualResponse_.has_more_records;
            return response_;
        }


        /// <summary>For a given table, retrieves the values of the given
        /// columns within a given range. It returns maps of column name to the
        /// vector of values for each supported data type (double, float, long,
        /// int and string). This operation supports pagination feature, i.e.
        /// values that are retrieved are those associated with the indices
        /// between the start (offset) and end value (offset + limit)
        /// parameters (inclusive). If there are num_points values in the table
        /// then each of the indices between 0 and num_points-1 retrieves a
        /// unique value.
        /// <br />
        /// Note that when using the pagination feature, if the table (or the
        /// underlying table in case of a view) is updated (records are
        /// inserted, deleted or modified) the records or values retrieved may
        /// differ between calls (discontiguous or overlap) based on the type
        /// of the update.
        /// <br />
        /// The response is returned as a dynamic schema. For details see: <a
        /// href="../../../../concepts/dynamic_schemas.html"
        /// target="_top">dynamic schemas documentation</a>.</summary>
        /// 
        /// <param name="table_name">Name of the table on which this operation
        /// will be performed. The table cannot be a parent set.  </param>
        /// <param name="column_names">The list of column values to retrieve.
        /// </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of results to be returned (if not provided the default is
        /// 10000), or END_OF_SET (-9999) to indicate that the maximum number
        /// of results allowed by the server should be returned.  </param>
        /// <param name="options">
        /// <list type="bullet">
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Optional filter expression to apply to the
        /// table.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_by</term>
        ///         <description>Optional column that the data should be sorted
        /// by. Empty by default (i.e. no sorting is applied).</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted - ascending or descending. Default is 'ascending'.
        /// If sort_order is provided, sort_by has to be provided. Values:
        /// ascending, descending.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsByColumnResponse getRecordsByColumn( string table_name,
                                                              IList<string> column_names,
                                                              long offset,
                                                              long limit,
                                                              IDictionary<string, string> options = null )
        {
            return getRecordsByColumn( new GetRecordsByColumnRequest( table_name,
                                                                      column_names,
                                                                      offset, limit,
                                                                      options ) );
        }


        /// <summary>Retrieves the complete series/track records from the given
        /// <paramref cref="GetRecordsBySeriesRequest.world_table_name" />
        /// based on the partial track information contained in the <paramref
        /// cref="GetRecordsBySeriesRequest.table_name" />.
        /// <br />
        /// This operation supports paging through the data via the <paramref
        /// cref="GetRecordsBySeriesRequest.offset" /> and <paramref
        /// cref="GetRecordsBySeriesRequest.limit" /> parameters.
        /// <br />
        /// In contrast to <see
        /// cref="Kinetica.getRecords{T}(GetRecordsRequest)" /> this returns
        /// records grouped by series/track. So if <paramref
        /// cref="GetRecordsBySeriesRequest.offset" /> is 0 and <paramref
        /// cref="GetRecordsBySeriesRequest.limit" /> is 5 this operation would
        /// return the first 5 series/tracks in <paramref
        /// cref="GetRecordsBySeriesRequest.table_name" />. Each series/track
        /// will be returned sorted by their TIMESTAMP column.</summary>
        /// 
        /// <typeparam name="T">The type of object being retrieved.</typeparam>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsBySeriesResponse<T> getRecordsBySeries<T>( GetRecordsBySeriesRequest request_ ) where T : new()
        {
            RawGetRecordsBySeriesResponse actualResponse_ = SubmitRequest<RawGetRecordsBySeriesResponse>("/get/records/byseries", request_, false);

            GetRecordsBySeriesResponse<T> response_ = new GetRecordsBySeriesResponse<T>();
            response_.table_names = actualResponse_.table_names;
            response_.type_names = actualResponse_.type_names;
            response_.type_schemas = actualResponse_.type_schemas;
            response_.data = new List<IList<T>>();
            this.DecodeRawBinaryDataUsingTypeIDs<T>( response_.type_names, actualResponse_.list_records_binary, response_.data );
            return response_;
        }


        /// <summary>Retrieves the complete series/track records from the given
        /// <paramref name="world_table_name" /> based on the partial track
        /// information contained in the <paramref name="table_name" />.
        /// <br />
        /// This operation supports paging through the data via the <paramref
        /// name="offset" /> and <paramref name="limit" /> parameters.
        /// <br />
        /// In contrast to <see
        /// cref="Kinetica.getRecords{T}(string,long,long,IDictionary{string, string})"
        /// /> this returns records grouped by series/track. So if <paramref
        /// name="offset" /> is 0 and <paramref name="limit" /> is 5 this
        /// operation would return the first 5 series/tracks in <paramref
        /// name="table_name" />. Each series/track will be returned sorted by
        /// their TIMESTAMP column.</summary>
        /// 
        /// <typeparam name="T">The type of object being retrieved.</typeparam>
        /// 
        /// <param name="table_name">Name of the collection/table/view for
        /// which series/tracks will be fetched.  </param>
        /// <param name="world_table_name">Name of the table containing the
        /// complete series/track information to be returned for the tracks
        /// present in the <paramref
        /// cref="GetRecordsBySeriesRequest.table_name" />. Typically this is
        /// used when retrieving series/tracks from a view (which contains
        /// partial series/tracks) but the user wants to retrieve the entire
        /// original series/tracks. Can be blank.  </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial series/tracks to skip (useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of series/tracks to be returned. Or END_OF_SET (-9999) to
        /// indicate that the max number of results should be returned.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsBySeriesResponse<T> getRecordsBySeries<T>( string table_name,
                                                                    string world_table_name,
                                                                    int offset = 0,
                                                                    int limit = 10000,
                                                                    IDictionary<string, string> options = null ) where T : new()
        {
            return getRecordsBySeries<T>( new GetRecordsBySeriesRequest( table_name,
                                                                         world_table_name,
                                                                         offset, limit,
                                                                         options ) );
        }


        /// <summary>Retrieves records from a collection. The operation can
        /// optionally return the record IDs which can be used in certain
        /// queries such as <see
        /// cref="Kinetica.deleteRecords(DeleteRecordsRequest)" />.
        /// <br />
        /// This operation supports paging through the data via the <paramref
        /// cref="GetRecordsFromCollectionRequest.offset" /> and <paramref
        /// cref="GetRecordsFromCollectionRequest.limit" /> parameters.
        /// <br />
        /// Note that when using the Java API, it is not possible to retrieve
        /// records from join tables using this operation.</summary>
        /// 
        /// <typeparam name="T">The type of object being retrieved.</typeparam>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsFromCollectionResponse<T> getRecordsFromCollection<T>( GetRecordsFromCollectionRequest request_ ) where T : new()
        {
            RawGetRecordsFromCollectionResponse actualResponse_ = SubmitRequest<RawGetRecordsFromCollectionResponse>("/get/records/fromcollection", request_, false);

            GetRecordsFromCollectionResponse<T> response_ = new GetRecordsFromCollectionResponse<T>();
            response_.table_name = actualResponse_.table_name;
            response_.type_names = actualResponse_.type_names;
            response_.data = new List<T>();
            this.DecodeRawBinaryDataUsingTypeIDs<T>( response_.type_names, actualResponse_.records_binary, response_.data );
            response_.record_ids = actualResponse_.record_ids;
            return response_;
        }


        /// <summary>Retrieves records from a collection. The operation can
        /// optionally return the record IDs which can be used in certain
        /// queries such as <see
        /// cref="Kinetica.deleteRecords(string,IList{string},IDictionary{string, string})"
        /// />.
        /// <br />
        /// This operation supports paging through the data via the <paramref
        /// name="offset" /> and <paramref name="limit" /> parameters.
        /// <br />
        /// Note that when using the Java API, it is not possible to retrieve
        /// records from join tables using this operation.</summary>
        /// 
        /// <typeparam name="T">The type of object being retrieved.</typeparam>
        /// 
        /// <param name="table_name">Name of the collection or table from which
        /// records are to be retrieved. Must be an existing collection or
        /// table.  </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of results to be returned, or END_OF_SET (-9999) to indicate
        /// that the max number of results should be returned.  </param>
        /// <param name="options">
        /// <list type="bullet">
        ///     <item>
        ///         <term>return_record_ids</term>
        ///         <description>If 'true' then return the internal record ID
        /// along with each returned record. Default is 'false'. Values: true,
        /// false.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GetRecordsFromCollectionResponse<T> getRecordsFromCollection<T>( string table_name,
                                                                                long offset = 0,
                                                                                long limit = 10000,
                                                                                IDictionary<string, string> options = null ) where T : new()
        {
            return getRecordsFromCollection<T>( new GetRecordsFromCollectionRequest(
                                                                                     table_name,
                                                                                     offset,
                                                                                     limit,
                                                                                     options ) );
        }


        /// <summary>Grants a system-level permission to a user or
        /// role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GrantPermissionSystemResponse grantPermissionSystem( GrantPermissionSystemRequest request_ )
        {
            GrantPermissionSystemResponse actualResponse_ = SubmitRequest<GrantPermissionSystemResponse>("/grant/permission/system", request_, false);

            return actualResponse_;
        }


        /// <summary>Grants a system-level permission to a user or
        /// role.</summary>
        /// 
        /// <param name="name">Name of the user or role to which the permission
        /// will be granted. Must be an existing user or role.  </param>
        /// <param name="permission">Permission to grant to the user or role.
        /// Values: system_admin, system_write, system_read.
        ///   </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GrantPermissionSystemResponse grantPermissionSystem( string name,
                                                                    string permission,
                                                                    IDictionary<string, string> options )
        {
            return grantPermissionSystem( new GrantPermissionSystemRequest( name,
                                                                            permission,
                                                                            options ) );
        }


        /// <summary>Grants a table-level permission to a user or
        /// role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GrantPermissionTableResponse grantPermissionTable( GrantPermissionTableRequest request_ )
        {
            GrantPermissionTableResponse actualResponse_ = SubmitRequest<GrantPermissionTableResponse>("/grant/permission/table", request_, false);

            return actualResponse_;
        }


        /// <summary>Grants a table-level permission to a user or
        /// role.</summary>
        /// 
        /// <param name="name">Name of the user or role to which the permission
        /// will be granted. Must be an existing user or role.  </param>
        /// <param name="permission">Permission to grant to the user or role.
        /// Values: table_admin, table_insert, table_update, table_delete,
        /// table_read.
        ///   </param>
        /// <param name="table_name">Name of the table to which the permission
        /// grants access. Must be an existing table, collection, or view. If a
        /// collection, the permission also applies to tables and views in the
        /// collection.  </param>
        /// <param name="filter_expression">Reserved for future use.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GrantPermissionTableResponse grantPermissionTable( string name,
                                                                  string permission,
                                                                  string table_name,
                                                                  string filter_expression,
                                                                  IDictionary<string, string> options )
        {
            return grantPermissionTable( new GrantPermissionTableRequest( name,
                                                                          permission,
                                                                          table_name,
                                                                          filter_expression,
                                                                          options ) );
        }


        /// <summary>Grants membership in a role to a user or role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GrantRoleResponse grantRole( GrantRoleRequest request_ )
        {
            GrantRoleResponse actualResponse_ = SubmitRequest<GrantRoleResponse>("/grant/role", request_, false);

            return actualResponse_;
        }


        /// <summary>Grants membership in a role to a user or role.</summary>
        /// 
        /// <param name="role">Name of the role in which membership will be
        /// granted. Must be an existing role.  </param>
        /// <param name="member">Name of the user or role that will be granted
        /// membership in <paramref cref="GrantRoleRequest.role" />. Must be an
        /// existing user or role.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public GrantRoleResponse grantRole( string role,
                                            string member,
                                            IDictionary<string, string> options )
        {
            return grantRole( new GrantRoleRequest( role, member, options ) );
        }


        /// <summary>Checks the existence of a proc with the given
        /// name.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public HasProcResponse hasProc( HasProcRequest request_ )
        {
            HasProcResponse actualResponse_ = SubmitRequest<HasProcResponse>("/has/proc", request_, false);

            return actualResponse_;
        }


        /// <summary>Checks the existence of a proc with the given
        /// name.</summary>
        /// 
        /// <param name="proc_name">Name of the proc to check for existence.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public HasProcResponse hasProc( string proc_name,
                                        IDictionary<string, string> options = null )
        {
            return hasProc( new HasProcRequest( proc_name, options ) );
        }


        /// <summary>Checks for the existence of a table with the given
        /// name.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public HasTableResponse hasTable( HasTableRequest request_ )
        {
            HasTableResponse actualResponse_ = SubmitRequest<HasTableResponse>("/has/table", request_, false);

            return actualResponse_;
        }


        /// <summary>Checks for the existence of a table with the given
        /// name.</summary>
        /// 
        /// <param name="table_name">Name of the table to check for existence.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public HasTableResponse hasTable( string table_name,
                                          IDictionary<string, string> options = null )
        {
            return hasTable( new HasTableRequest( table_name, options ) );
        }


        /// <summary>Check for the existence of a type.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public HasTypeResponse hasType( HasTypeRequest request_ )
        {
            HasTypeResponse actualResponse_ = SubmitRequest<HasTypeResponse>("/has/type", request_, false);

            return actualResponse_;
        }


        /// <summary>Check for the existence of a type.</summary>
        /// 
        /// <param name="type_id">Id of the type returned in response to
        /// /create/type request.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public HasTypeResponse hasType( string type_id,
                                        IDictionary<string, string> options = null )
        {
            return hasType( new HasTypeRequest( type_id, options ) );
        }


        /// <summary>Adds multiple records to the specified table. The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all the records are fully inserted and available.
        /// The response payload provides the counts of the number of records
        /// actually inserted and/or updated, and can provide the unique
        /// identifier of each added record.
        /// <br />
        /// The <paramref cref="RawInsertRecordsRequest.options" /> parameter
        /// can be used to customize this function's behavior.  The
        /// <i>update_on_existing_pk</i> option specifies the primary-key
        /// collision policy.  If the table has a <see
        /// cref="Kinetica.createType(CreateTypeRequest)">primary key</see> and
        /// if <i>update_on_existing_pk</i> is <i>true</i>, then if any of the
        /// records being added have the same primary key as existing records,
        /// the existing records are replaced (i.e. updated) with the given
        /// records.  If <i>update_on_existing_pk</i> is <i>false</i> and if
        /// the records being added have the same primary key as existing
        /// records, they are ignored (the existing records are left
        /// unchanged).  It is quite possible that in this case some of the
        /// given records will be inserted and some (those having existing
        /// primary keys) will be ignored (or updated).  If the specified table
        /// does not have a primary key column, then the
        /// <i>update_on_existing_pk</i> option is ignored.
        /// <br />
        /// The <i>return_record_ids</i> option indicates that the database
        /// should return the unique identifiers of inserted records.
        /// <br />
        /// The <i>route_to_address</i> option directs that inserted records
        /// should be targeted for a particular database node.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public InsertRecordsResponse insertRecordsRaw( RawInsertRecordsRequest request_ )
        {
            InsertRecordsResponse actualResponse_ = SubmitRequest<InsertRecordsResponse>("/insert/records", request_, true);

            return actualResponse_;
        }


        /// <summary>Adds multiple records to the specified table. The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all the records are fully inserted and available.
        /// The response payload provides the counts of the number of records
        /// actually inserted and/or updated, and can provide the unique
        /// identifier of each added record.
        /// <br />
        /// The <paramref cref="RawInsertRecordsRequest.options" /> parameter
        /// can be used to customize this function's behavior.  The
        /// <i>update_on_existing_pk</i> option specifies the primary-key
        /// collision policy.  If the table has a <see
        /// cref="Kinetica.createType(CreateTypeRequest)">primary key</see> and
        /// if <i>update_on_existing_pk</i> is <i>true</i>, then if any of the
        /// records being added have the same primary key as existing records,
        /// the existing records are replaced (i.e. updated) with the given
        /// records.  If <i>update_on_existing_pk</i> is <i>false</i> and if
        /// the records being added have the same primary key as existing
        /// records, they are ignored (the existing records are left
        /// unchanged).  It is quite possible that in this case some of the
        /// given records will be inserted and some (those having existing
        /// primary keys) will be ignored (or updated).  If the specified table
        /// does not have a primary key column, then the
        /// <i>update_on_existing_pk</i> option is ignored.
        /// <br />
        /// The <i>return_record_ids</i> option indicates that the database
        /// should return the unique identifiers of inserted records.
        /// <br />
        /// The <i>route_to_address</i> option directs that inserted records
        /// should be targeted for a particular database node.</summary>
        /// 
        /// <typeparam name="T">The type of object being added.</typeparam>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public InsertRecordsResponse insertRecords<T>( InsertRecordsRequest<T> request_ )
        {
            RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest();
            actualRequest_.table_name = request_.table_name;
            foreach (var thisObj in request_.data) actualRequest_.list.Add( AvroEncode( thisObj ) );
            actualRequest_.options = request_.options;
            InsertRecordsResponse actualResponse_ = SubmitRequest<InsertRecordsResponse>("/insert/records", actualRequest_, true);

            return actualResponse_;
        }


        /// <summary>Adds multiple records to the specified table. The
        /// operation is synchronous, meaning that a response will not be
        /// returned until all the records are fully inserted and available.
        /// The response payload provides the counts of the number of records
        /// actually inserted and/or updated, and can provide the unique
        /// identifier of each added record.
        /// <br />
        /// The <paramref name="options" /> parameter can be used to customize
        /// this function's behavior.  The <i>update_on_existing_pk</i> option
        /// specifies the primary-key collision policy.  If the table has a
        /// <see
        /// cref="Kinetica.createType(string,string,IDictionary{string, IList{string}},IDictionary{string, string})">primary
        /// key</see> and if <i>update_on_existing_pk</i> is <i>true</i>, then
        /// if any of the records being added have the same primary key as
        /// existing records, the existing records are replaced (i.e. updated)
        /// with the given records.  If <i>update_on_existing_pk</i> is
        /// <i>false</i> and if the records being added have the same primary
        /// key as existing records, they are ignored (the existing records are
        /// left unchanged).  It is quite possible that in this case some of
        /// the given records will be inserted and some (those having existing
        /// primary keys) will be ignored (or updated).  If the specified table
        /// does not have a primary key column, then the
        /// <i>update_on_existing_pk</i> option is ignored.
        /// <br />
        /// The <i>return_record_ids</i> option indicates that the database
        /// should return the unique identifiers of inserted records.
        /// <br />
        /// The <i>route_to_address</i> option directs that inserted records
        /// should be targeted for a particular database node.</summary>
        /// 
        /// <typeparam name="T">The type of object being added.</typeparam>
        /// 
        /// <param name="table_name">Table to which the records are to be
        /// added. Must be an existing table.  </param>
        /// <param name="data">An array of binary-encoded data for the records
        /// to be added. All records must be of the same type as that of the
        /// table. Empty array if <paramref
        /// cref="RawInsertRecordsRequest.list_encoding" /> is <i>json</i>.
        /// </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>update_on_existing_pk</term>
        ///         <description>If the table has a /create/type, then if the
        /// value is <i>true</i> then if any of the records being added have
        /// the same primary key as existing records, the existing records are
        /// replaced (i.e. updated) with the given records. If <i>false</i>,
        /// and if the records being added have the same primary key as
        /// existing records, they are ignored (the existing records are left
        /// unchanged).  It is quite possible that in this case some of the
        /// given records will be inserted and some (those having existing
        /// primary keys) will be ignored (or updated). If the specified table
        /// does not have a primary key column then this optional parameter is
        /// ignored. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>return_record_ids</term>
        ///         <description>If <i>true</i> then return the internal record
        /// id along for each inserted record. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>route_to_address</term>
        ///         <description>Route to a specific rank/tom. Option not
        /// suitable for tables using primary/shard keys</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public InsertRecordsResponse insertRecords<T>( string table_name,
                                                       IList<T> data,
                                                       IDictionary<string, string> options = null )
        {
            return insertRecords<T>( new InsertRecordsRequest<T>( table_name, data,
                                                                  options ) );
        }


        /// <summary>Generates a specified number of random records and adds
        /// them to the given table. There is an optional parameter that allows
        /// the user to customize the ranges of the column values. It also
        /// allows the user to specify linear profiles for some or all columns
        /// in which case linear values are generated rather than random ones.
        /// Only individual tables are supported for this operation.
        /// <br />
        /// This operation is synchronous, meaning that a response will not be
        /// returned until all random records are fully available.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public InsertRecordsRandomResponse insertRecordsRandom( InsertRecordsRandomRequest request_ )
        {
            InsertRecordsRandomResponse actualResponse_ = SubmitRequest<InsertRecordsRandomResponse>("/insert/records/random", request_, false);

            return actualResponse_;
        }


        /// <summary>Generates a specified number of random records and adds
        /// them to the given table. There is an optional parameter that allows
        /// the user to customize the ranges of the column values. It also
        /// allows the user to specify linear profiles for some or all columns
        /// in which case linear values are generated rather than random ones.
        /// Only individual tables are supported for this operation.
        /// <br />
        /// This operation is synchronous, meaning that a response will not be
        /// returned until all random records are fully available.</summary>
        /// 
        /// <param name="table_name">Table to which random records will be
        /// added. Must be an existing table.  Also, must be an individual
        /// table, not a collection of tables, nor a view of a table.  </param>
        /// <param name="count">Number of records to generate.  </param>
        /// <param name="options">Optional parameter to pass in specifications
        /// for the randomness of the values.  This map is different from the
        /// *options* parameter of most other endpoints in that it is a map of
        /// string to map of string to doubles, while most others are maps of
        /// string to string.  In this map, the top level keys represent which
        /// column's parameters are being specified, while the internal keys
        /// represents which parameter is being specified.  The parameters that
        /// can be specified are: *min*, *max*, and *interval*.  These
        /// parameters take on different meanings depending on the type of the
        /// column.  Below follows a more detailed description of the map:
        /// <list type="bullet">
        ///     <item>
        ///         <term>seed</term>
        ///         <description>If provided, the internal random number
        /// generator will be initialized with the given value.  The minimum is
        /// 0.  This allows for the same set of random numbers to be generated
        /// across invocation of this endpoint in case the user wants to repeat
        /// the test.  Since <paramref
        /// cref="InsertRecordsRandomRequest.options" />, is a map of maps, we
        /// need an internal map to provide the seed value.  For example, to
        /// pass 100 as the seed value through this parameter, you need
        /// something equivalent to: 'options' = {'seed': { 'value': 100 } }
        /// <list type="bullet">
        ///     <item>
        ///         <term>value</term>
        ///         <description>Pass the seed value here.</description>
        ///     </item>
        /// </list>
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>all</term>
        ///         <description>This key indicates that the specifications
        /// relayed in the internal map are to be applied to all columns of the
        /// records.
        /// <list type="bullet">
        ///     <item>
        ///         <term>min</term>
        ///         <description>For numerical columns, the minimum of the
        /// generated values is set to this value.  Default is -99999.  For
        /// point, shape, and track semantic types, min for numeric 'x' and 'y'
        /// columns needs to be within [-180, 180] and [-90, 90], respectively.
        /// The default minimum possible values for these columns in such cases
        /// are -180.0 and -90.0. For the 'TIMESTAMP' column, the default
        /// minimum corresponds to Jan 1, 2010.
        /// For string columns, the minimum length of the randomly generated
        /// strings is set to this value (default is 1). If both minimum and
        /// maximum are provided, minimum must be less than or equal to max.
        /// Value needs to be within [1, 200].
        /// If the min is outside the accepted ranges for strings columns and
        /// 'x' and 'y' columns for point/shape/track types, then those
        /// parameters will not be set; however, an error will not be thrown in
        /// such a case. It is the responsibility of the user to use the
        /// <i>all</i> parameter judiciously.</description>
        ///     </item>
        ///     <item>
        ///         <term>max</term>
        ///         <description>For numerical columns, the maximum of the
        /// generated values is set to this value. Default is 99999. For point,
        /// shape, and track semantic types, max for numeric 'x' and 'y'
        /// columns needs to be within [-180, 180] and [-90, 90], respectively.
        /// The default minimum possible values for these columns in such cases
        /// are 180.0 and 90.0.
        /// For string columns, the maximum length of the randomly generated
        /// strings is set to this value (default is 200). If both minimum and
        /// maximum are provided, *max* must be greater than or equal to *min*.
        /// Value needs to be within [1, 200].
        /// If the *max* is outside the accepted ranges for strings columns and
        /// 'x' and 'y' columns for point/shape/track types, then those
        /// parameters will not be set; however, an error will not be thrown in
        /// such a case. It is the responsibility of the user to use the
        /// <i>all</i> parameter judiciously.</description>
        ///     </item>
        ///     <item>
        ///         <term>interval</term>
        ///         <description>If specified, then generate values for all
        /// columns linearly and evenly spaced with the given interval value
        /// starting at the minimum value (instead of generating random data).
        /// *Any provided max value is disregarded.*  For string-type columns,
        /// the interval value is ignored but the string values would be
        /// generated following the pattern: 'attrname_creationIndex#', i.e.
        /// the column name suffixed with an underscore and a running counter
        /// (starting at 0).  No nulls would be generated for nullable
        /// columns.</description>
        ///     </item>
        ///     <item>
        ///         <term>null_percentage</term>
        ///         <description>If specified, then generate the given
        /// percentage of the count as nulls for all nullable columns.  This
        /// option will be ignored for non-nullable columns.  The value must be
        /// within the range [0, 1.0].  The default value is 5%
        /// (0.05).</description>
        ///     </item>
        /// </list>
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>attr_name</term>
        ///         <description>Set the following parameters for the column
        /// specified by the key. This overrides any parameter set by
        /// <i>all</i>.
        /// <list type="bullet">
        ///     <item>
        ///         <term>min</term>
        ///         <description>For numerical columns, the minimum of the
        /// generated values is set to this value.  Default is -99999.  For
        /// point, shape, and track semantic types, min for numeric 'x' and 'y'
        /// columns needs to be within [-180, 180] and [-90, 90], respectively.
        /// The default minimum possible values for these columns in such cases
        /// are -180.0 and -90.0. For the 'TIMESTAMP' column, the default
        /// minimum corresponds to Jan 1, 2010.
        /// For string columns, the minimum length of the randomly generated
        /// strings is set to this value (default is 1). If both minimum and
        /// maximum are provided, minimum must be less than or equal to max.
        /// Value needs to be within [1, 200].
        /// If the min is outside the accepted ranges for strings columns and
        /// 'x' and 'y' columns for point/shape/track types, then those
        /// parameters will not be set; however, an error will not be thrown in
        /// such a case. It is the responsibility of the user to use the
        /// <i>all</i> parameter judiciously.</description>
        ///     </item>
        ///     <item>
        ///         <term>max</term>
        ///         <description>For numerical columns, the maximum of the
        /// generated values is set to this value. Default is 99999. For point,
        /// shape, and track semantic types, max for numeric 'x' and 'y'
        /// columns needs to be within [-180, 180] and [-90, 90], respectively.
        /// The default minimum possible values for these columns in such cases
        /// are 180.0 and 90.0.
        /// For string columns, the maximum length of the randomly generated
        /// strings is set to this value (default is 200). If both minimum and
        /// maximum are provided, *max* must be greater than or equal to *min*.
        /// Value needs to be within [1, 200].
        /// If the *max* is outside the accepted ranges for strings columns and
        /// 'x' and 'y' columns for point/shape/track types, then those
        /// parameters will not be set; however, an error will not be thrown in
        /// such a case. It is the responsibility of the user to use the
        /// <i>all</i> parameter judiciously.</description>
        ///     </item>
        ///     <item>
        ///         <term>interval</term>
        ///         <description>If specified, then generate values for all
        /// columns linearly and evenly spaced with the given interval value
        /// starting at the minimum value (instead of generating random data).
        /// *Any provided max value is disregarded.*  For string-type columns,
        /// the interval value is ignored but the string values would be
        /// generated following the pattern: 'attrname_creationIndex#', i.e.
        /// the column name suffixed with an underscore and a running counter
        /// (starting at 0).  No nulls would be generated for nullable
        /// columns.</description>
        ///     </item>
        ///     <item>
        ///         <term>null_percentage</term>
        ///         <description>If specified and if this column is nullable,
        /// then generate the given percentage of the count as nulls.  This
        /// option will result in an error if the column is not nullable.  The
        /// value must be within the range [0, 1.0].  The default value is 5%
        /// (0.05).</description>
        ///     </item>
        /// </list>
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>track_length</term>
        ///         <description>This key-map pair is only valid for track type
        /// data sets (an error is thrown otherwise).  No nulls would be
        /// generated for nullable columns.
        /// <list type="bullet">
        ///     <item>
        ///         <term>min</term>
        ///         <description>Minimum possible length for generated series;
        /// default is 100 records per series. Must be an integral value within
        /// the range [1, 500]. If both min and max are specified, min must be
        /// less than or equal to max.</description>
        ///     </item>
        ///     <item>
        ///         <term>max</term>
        ///         <description>Maximum possible length for generated series;
        /// default is 500 records per series. Must be an integral value within
        /// the range [1, 500]. If both min and max are specified, max must be
        /// greater than or equal to min.</description>
        ///     </item>
        /// </list>
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public InsertRecordsRandomResponse insertRecordsRandom( string table_name,
                                                                long count,
                                                                IDictionary<string, IDictionary<string, double>> options = null )
        {
            return insertRecordsRandom( new InsertRecordsRandomRequest( table_name, count,
                                                                        options ) );
        }


        /// <summary>Adds a symbol or icon (i.e. an image) to represent data
        /// points when data is rendered visually. Users must provide the
        /// symbol identifier (string), a format (currently supported: 'svg'
        /// and 'svg_path'), the data for the symbol, and any additional
        /// optional parameter (e.g. color). To have a symbol used for
        /// rendering create a table with a string column named 'SYMBOLCODE'
        /// (along with 'x' or 'y' for example). Then when the table is
        /// rendered (via <a href="../../../../api/rest/wms_rest.html"
        /// target="_top">WMS</a>) if the 'dosymbology' parameter is 'true'
        /// then the value of the 'SYMBOLCODE' column is used to pick the
        /// symbol displayed for each point.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public InsertSymbolResponse insertSymbol( InsertSymbolRequest request_ )
        {
            InsertSymbolResponse actualResponse_ = SubmitRequest<InsertSymbolResponse>("/insert/symbol", request_, false);

            return actualResponse_;
        }


        /// <summary>Adds a symbol or icon (i.e. an image) to represent data
        /// points when data is rendered visually. Users must provide the
        /// symbol identifier (string), a format (currently supported: 'svg'
        /// and 'svg_path'), the data for the symbol, and any additional
        /// optional parameter (e.g. color). To have a symbol used for
        /// rendering create a table with a string column named 'SYMBOLCODE'
        /// (along with 'x' or 'y' for example). Then when the table is
        /// rendered (via <a href="../../../../api/rest/wms_rest.html"
        /// target="_top">WMS</a>) if the 'dosymbology' parameter is 'true'
        /// then the value of the 'SYMBOLCODE' column is used to pick the
        /// symbol displayed for each point.</summary>
        /// 
        /// <param name="symbol_id">The id of the symbol being added. This is
        /// the same id that should be in the 'SYMBOLCODE' column for objects
        /// using this symbol  </param>
        /// <param name="symbol_format">Specifies the symbol format. Must be
        /// either 'svg' or 'svg_path'. Values: svg, svg_path.
        ///   </param>
        /// <param name="symbol_data">The actual symbol data. If <paramref
        /// cref="InsertSymbolRequest.symbol_format" /> is 'svg' then this
        /// should be the raw bytes representing an svg file. If <paramref
        /// cref="InsertSymbolRequest.symbol_format" /> is svg path then this
        /// should be an svg path string, for example:
        /// 'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>color</term>
        ///         <description>If <paramref
        /// cref="InsertSymbolRequest.symbol_format" /> is 'svg' this is
        /// ignored. If <paramref cref="InsertSymbolRequest.symbol_format" />
        /// is 'svg_path' then this option specifies the color (in RRGGBB hex
        /// format) of the path. For example, to have the path rendered in red,
        /// used 'FF0000'. If 'color' is not provided then '00FF00' (i.e.
        /// green) is used by default.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public InsertSymbolResponse insertSymbol( string symbol_id,
                                                  string symbol_format,
                                                  byte[] symbol_data,
                                                  IDictionary<string, string> options = null )
        {
            return insertSymbol( new InsertSymbolRequest( symbol_id, symbol_format,
                                                          symbol_data, options ) );
        }


        /// <summary>Kills a running proc instance.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public KillProcResponse killProc( KillProcRequest request_ )
        {
            KillProcResponse actualResponse_ = SubmitRequest<KillProcResponse>("/kill/proc", request_, false);

            return actualResponse_;
        }


        /// <summary>Kills a running proc instance.</summary>
        /// 
        /// <param name="run_id">The run ID of the running proc instance. If
        /// the run ID is not found or the proc instance has already completed,
        /// this does nothing. If not specified, all running proc instances
        /// will be killed.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public KillProcResponse killProc( string run_id = "",
                                          IDictionary<string, string> options = null )
        {
            return killProc( new KillProcRequest( run_id, options ) );
        }


        /// <summary>Manages global access to a table's data.  By default a
        /// table has a <paramref cref="LockTableRequest.lock_type" /> of
        /// <i>unlock</i>, indicating all operations are permitted.  A user may
        /// request a <i>read-only</i> or a <i>write-only</i> lock, after which
        /// only read or write operations, respectively, are permitted on the
        /// table until the lock is removed.  When <paramref
        /// cref="LockTableRequest.lock_type" /> is <i>disable</i> then no
        /// operations are permitted on the table.  The lock status can be
        /// queried by setting <paramref cref="LockTableRequest.lock_type" />
        /// to <i>status</i>.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public LockTableResponse lockTable( LockTableRequest request_ )
        {
            LockTableResponse actualResponse_ = SubmitRequest<LockTableResponse>("/lock/table", request_, false);

            return actualResponse_;
        }


        /// <summary>Manages global access to a table's data.  By default a
        /// table has a <paramref name="lock_type" /> of <i>unlock</i>,
        /// indicating all operations are permitted.  A user may request a
        /// <i>read-only</i> or a <i>write-only</i> lock, after which only read
        /// or write operations, respectively, are permitted on the table until
        /// the lock is removed.  When <paramref name="lock_type" /> is
        /// <i>disable</i> then no operations are permitted on the table.  The
        /// lock status can be queried by setting <paramref name="lock_type" />
        /// to <i>status</i>.</summary>
        /// 
        /// <param name="table_name">Name of the table to be locked. It must be
        /// a currently existing table, collection, or view.  </param>
        /// <param name="lock_type">The type of lock being applied to the
        /// table. Setting it to <i>status</i> will return the current lock
        /// status of the table without changing it. Values: status, disable,
        /// read-only, write-only, unlock.
        ///   </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public LockTableResponse lockTable( string table_name,
                                            string lock_type = LockTableRequest.LockType.STATUS,
                                            IDictionary<string, string> options = null )
        {
            return lockTable( new LockTableRequest( table_name, lock_type, options ) );
        }


        /// <summary>Revokes a system-level permission from a user or
        /// role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public RevokePermissionSystemResponse revokePermissionSystem( RevokePermissionSystemRequest request_ )
        {
            RevokePermissionSystemResponse actualResponse_ = SubmitRequest<RevokePermissionSystemResponse>("/revoke/permission/system", request_, false);

            return actualResponse_;
        }


        /// <summary>Revokes a system-level permission from a user or
        /// role.</summary>
        /// 
        /// <param name="name">Name of the user or role from which the
        /// permission will be revoked. Must be an existing user or role.
        /// </param>
        /// <param name="permission">Permission to revoke from the user or
        /// role. Values: system_admin, system_write, system_read.
        ///   </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public RevokePermissionSystemResponse revokePermissionSystem( string name,
                                                                      string permission,
                                                                      IDictionary<string, string> options )
        {
            return revokePermissionSystem( new RevokePermissionSystemRequest( name,
                                                                              permission,
                                                                              options ) );
        }


        /// <summary>Revokes a table-level permission from a user or
        /// role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public RevokePermissionTableResponse revokePermissionTable( RevokePermissionTableRequest request_ )
        {
            RevokePermissionTableResponse actualResponse_ = SubmitRequest<RevokePermissionTableResponse>("/revoke/permission/table", request_, false);

            return actualResponse_;
        }


        /// <summary>Revokes a table-level permission from a user or
        /// role.</summary>
        /// 
        /// <param name="name">Name of the user or role from which the
        /// permission will be revoked. Must be an existing user or role.
        /// </param>
        /// <param name="permission">Permission to revoke from the user or
        /// role. Values: table_admin, table_insert, table_update,
        /// table_delete, table_read.
        ///   </param>
        /// <param name="table_name">Name of the table to which the permission
        /// grants access. Must be an existing table, collection, or view.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public RevokePermissionTableResponse revokePermissionTable( string name,
                                                                    string permission,
                                                                    string table_name,
                                                                    IDictionary<string, string> options )
        {
            return revokePermissionTable( new RevokePermissionTableRequest( name,
                                                                            permission,
                                                                            table_name,
                                                                            options ) );
        }


        /// <summary>Revokes membership in a role from a user or
        /// role.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public RevokeRoleResponse revokeRole( RevokeRoleRequest request_ )
        {
            RevokeRoleResponse actualResponse_ = SubmitRequest<RevokeRoleResponse>("/revoke/role", request_, false);

            return actualResponse_;
        }


        /// <summary>Revokes membership in a role from a user or
        /// role.</summary>
        /// 
        /// <param name="role">Name of the role in which membership will be
        /// revoked. Must be an existing role.  </param>
        /// <param name="member">Name of the user or role that will be revoked
        /// membership in <paramref cref="RevokeRoleRequest.role" />. Must be
        /// an existing user or role.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public RevokeRoleResponse revokeRole( string role,
                                              string member,
                                              IDictionary<string, string> options )
        {
            return revokeRole( new RevokeRoleRequest( role, member, options ) );
        }


        /// <summary>Shows information about a proc.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowProcResponse showProc( ShowProcRequest request_ )
        {
            ShowProcResponse actualResponse_ = SubmitRequest<ShowProcResponse>("/show/proc", request_, false);

            return actualResponse_;
        }


        /// <summary>Shows information about a proc.</summary>
        /// 
        /// <param name="proc_name">Name of the proc to show information about.
        /// If specified, must be the name of a currently existing proc. If not
        /// specified, information about all procs will be returned.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>include_files</term>
        ///         <description>If set to <i>true</i>, the files that make up
        /// the proc will be returned. If set to <i>false</i>, the files will
        /// not be returned. Values: true, false.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowProcResponse showProc( string proc_name = "",
                                          IDictionary<string, string> options = null )
        {
            return showProc( new ShowProcRequest( proc_name, options ) );
        }


        /// <summary>Shows the statuses of running or completed proc instances.
        /// Results are grouped by run ID (as returned from <see
        /// cref="Kinetica.executeProc(ExecuteProcRequest)" />) and data
        /// segment ID (each invocation of the proc command on a data segment
        /// is assigned a data segment ID).</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowProcStatusResponse showProcStatus( ShowProcStatusRequest request_ )
        {
            ShowProcStatusResponse actualResponse_ = SubmitRequest<ShowProcStatusResponse>("/show/proc/status", request_, false);

            return actualResponse_;
        }


        /// <summary>Shows the statuses of running or completed proc instances.
        /// Results are grouped by run ID (as returned from <see
        /// cref="Kinetica.executeProc(string,IDictionary{string, string},IDictionary{string, byte[]},IList{string},IDictionary{string, IList{string}},IList{string},IDictionary{string, string})"
        /// />) and data segment ID (each invocation of the proc command on a
        /// data segment is assigned a data segment ID).</summary>
        /// 
        /// <param name="run_id">The run ID of a specific running or completed
        /// proc instance for which the status will be returned. If the run ID
        /// is not found, nothing will be returned. If not specified, the
        /// statuses of all running and completed proc instances will be
        /// returned.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>clear_complete</term>
        ///         <description>If set to <i>true</i>, if a proc instance has
        /// completed (either successfully or unsuccessfully) then its status
        /// will be cleared and no longer returned in subsequent calls. Values:
        /// true, false.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowProcStatusResponse showProcStatus( string run_id = "",
                                                      IDictionary<string, string> options = null )
        {
            return showProcStatus( new ShowProcStatusRequest( run_id, options ) );
        }


        /// <summary>Shows security information relating to users and/or roles.
        /// If the caller is not a system administrator, only information
        /// relating to the caller and their roles is returned.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSecurityResponse showSecurity( ShowSecurityRequest request_ )
        {
            ShowSecurityResponse actualResponse_ = SubmitRequest<ShowSecurityResponse>("/show/security", request_, false);

            return actualResponse_;
        }


        /// <summary>Shows security information relating to users and/or roles.
        /// If the caller is not a system administrator, only information
        /// relating to the caller and their roles is returned.</summary>
        /// 
        /// <param name="names">A list of names of users and/or roles about
        /// which security information is requested. If none are provided,
        /// information about all users and roles will be returned.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSecurityResponse showSecurity( IList<string> names,
                                                  IDictionary<string, string> options )
        {
            return showSecurity( new ShowSecurityRequest( names, options ) );
        }


        /// <summary>Returns server configuration and version related
        /// information to the caller. The admin tool uses it to present server
        /// related information to the user.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSystemPropertiesResponse showSystemProperties( ShowSystemPropertiesRequest request_ )
        {
            ShowSystemPropertiesResponse actualResponse_ = SubmitRequest<ShowSystemPropertiesResponse>("/show/system/properties", request_, false);

            return actualResponse_;
        }


        /// <summary>Returns server configuration and version related
        /// information to the caller. The admin tool uses it to present server
        /// related information to the user.</summary>
        /// 
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>properties</term>
        ///         <description>A list of comma separated names of properties
        /// requested. If not specified, all properties will be
        /// returned.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSystemPropertiesResponse showSystemProperties( IDictionary<string, string> options = null )
        {
            return showSystemProperties( new ShowSystemPropertiesRequest( options ) );
        }


        /// <summary>Provides server configuration and health related status to
        /// the caller. The admin tool uses it to present server related
        /// information to the user.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSystemStatusResponse showSystemStatus( ShowSystemStatusRequest request_ )
        {
            ShowSystemStatusResponse actualResponse_ = SubmitRequest<ShowSystemStatusResponse>("/show/system/status", request_, false);

            return actualResponse_;
        }


        /// <summary>Provides server configuration and health related status to
        /// the caller. The admin tool uses it to present server related
        /// information to the user.</summary>
        /// 
        /// <param name="options">Optional parameters, currently unused.
        /// </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSystemStatusResponse showSystemStatus( IDictionary<string, string> options = null )
        {
            return showSystemStatus( new ShowSystemStatusRequest( options ) );
        }


        /// <summary>Returns the last 100 database requests along with the
        /// request timing and internal job id. The admin tool uses it to
        /// present request timing information to the user.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSystemTimingResponse showSystemTiming( ShowSystemTimingRequest request_ )
        {
            ShowSystemTimingResponse actualResponse_ = SubmitRequest<ShowSystemTimingResponse>("/show/system/timing", request_, false);

            return actualResponse_;
        }


        /// <summary>Returns the last 100 database requests along with the
        /// request timing and internal job id. The admin tool uses it to
        /// present request timing information to the user.</summary>
        /// 
        /// <param name="options">Optional parameters, currently unused.
        /// </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowSystemTimingResponse showSystemTiming( IDictionary<string, string> options = null )
        {
            return showSystemTiming( new ShowSystemTimingRequest( options ) );
        }


        /// <summary>Retrieves detailed information about a table, view, or
        /// collection, specified in <paramref
        /// cref="ShowTableRequest.table_name" />. If the supplied <paramref
        /// cref="ShowTableRequest.table_name" /> is a collection, the call can
        /// return information about either the collection itself or the tables
        /// and views it contains. If <paramref
        /// cref="ShowTableRequest.table_name" /> is empty, information about
        /// all collections and top-level tables and views can be returned.
        /// <br />
        /// If the option <i>get_sizes</i> is set to <i>true</i>, then the
        /// sizes (objects and elements) of each table are returned (in
        /// <paramref cref="ShowTableResponse.sizes" /> and <paramref
        /// cref="ShowTableResponse.full_sizes" />), along with the total
        /// number of objects in the requested table (in <paramref
        /// cref="ShowTableResponse.total_size" /> and <paramref
        /// cref="ShowTableResponse.total_full_size" />).
        /// <br />
        /// For a collection, setting the <i>show_children</i> option to
        /// <i>false</i> returns only information about the collection itself;
        /// setting <i>show_children</i> to <i>true</i> returns a list of
        /// tables and views contained in the collection, along with their
        /// description, type id, schema, type label, type properties, and
        /// additional information including TTL.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTableResponse showTable( ShowTableRequest request_ )
        {
            ShowTableResponse actualResponse_ = SubmitRequest<ShowTableResponse>("/show/table", request_, false);


            for ( int i_ = 0; i_ < actualResponse_.type_ids.Count; ++i_ )
            {
                SetDecoderIfMissing( actualResponse_.type_ids[i_],
                                     actualResponse_.type_labels[i_],
                                     actualResponse_.type_schemas[i_],
                                     actualResponse_.properties[i_] );
            }

            return actualResponse_;
        }


        /// <summary>Retrieves detailed information about a table, view, or
        /// collection, specified in <paramref name="table_name" />. If the
        /// supplied <paramref name="table_name" /> is a collection, the call
        /// can return information about either the collection itself or the
        /// tables and views it contains. If <paramref name="table_name" /> is
        /// empty, information about all collections and top-level tables and
        /// views can be returned.
        /// <br />
        /// If the option <i>get_sizes</i> is set to <i>true</i>, then the
        /// sizes (objects and elements) of each table are returned (in
        /// <paramref cref="ShowTableResponse.sizes" /> and <paramref
        /// cref="ShowTableResponse.full_sizes" />), along with the total
        /// number of objects in the requested table (in <paramref
        /// cref="ShowTableResponse.total_size" /> and <paramref
        /// cref="ShowTableResponse.total_full_size" />).
        /// <br />
        /// For a collection, setting the <i>show_children</i> option to
        /// <i>false</i> returns only information about the collection itself;
        /// setting <i>show_children</i> to <i>true</i> returns a list of
        /// tables and views contained in the collection, along with their
        /// description, type id, schema, type label, type properties, and
        /// additional information including TTL.</summary>
        /// 
        /// <param name="table_name">Name of the table for which to retrieve
        /// the information. If blank, then information about all collections
        /// and top-level tables and views is returned.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>get_sizes</term>
        ///         <description>If <i>true</i> then the table sizes will be
        /// returned; blank, otherwise. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>show_children</term>
        ///         <description>If <paramref
        /// cref="ShowTableRequest.table_name" /> is a collection, then
        /// <i>true</i> will return information about the children of the
        /// collection, and <i>false</i> will return information about the
        /// collection itself. If <paramref cref="ShowTableRequest.table_name"
        /// /> is a table or view, <i>show_children</i> must be <i>false</i>.
        /// If <paramref cref="ShowTableRequest.table_name" /> is empty, then
        /// <i>show_children</i> must be <i>true</i>. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>no_error_if_not_exists</term>
        ///         <description>If <i>false</i> will return an error if the
        /// provided <paramref cref="ShowTableRequest.table_name" /> does not
        /// exist. If <i>true</i> then it will return an empty result. Values:
        /// true, false.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTableResponse showTable( string table_name,
                                            IDictionary<string, string> options = null )
        {
            return showTable( new ShowTableRequest( table_name, options ) );
        }


        /// <summary>Retrieves the user provided metadata for the specified
        /// tables.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTableMetadataResponse showTableMetadata( ShowTableMetadataRequest request_ )
        {
            ShowTableMetadataResponse actualResponse_ = SubmitRequest<ShowTableMetadataResponse>("/show/table/metadata", request_, false);

            return actualResponse_;
        }


        /// <summary>Retrieves the user provided metadata for the specified
        /// tables.</summary>
        /// 
        /// <param name="table_names">Tables whose metadata will be fetched.
        /// All provided tables must exist, or an error is returned.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTableMetadataResponse showTableMetadata( IList<string> table_names,
                                                            IDictionary<string, string> options = null )
        {
            return showTableMetadata( new ShowTableMetadataRequest( table_names, options ) );
        }


        /// <summary>Gets names of the tables whose type matches the given
        /// criteria. Each table has a particular type. This type is made out
        /// of the type label, schema of the table, and the semantic type of
        /// the table. This function allows a look up of the existing tables
        /// based on full or partial type information. The operation is
        /// synchronous.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTablesByTypeResponse showTablesByType( ShowTablesByTypeRequest request_ )
        {
            ShowTablesByTypeResponse actualResponse_ = SubmitRequest<ShowTablesByTypeResponse>("/show/tables/bytype", request_, false);

            return actualResponse_;
        }


        /// <summary>Gets names of the tables whose type matches the given
        /// criteria. Each table has a particular type. This type is made out
        /// of the type label, schema of the table, and the semantic type of
        /// the table. This function allows a look up of the existing tables
        /// based on full or partial type information. The operation is
        /// synchronous.</summary>
        /// 
        /// <param name="type_id">Type id returned by a call to /create/type.
        /// </param>
        /// <param name="label">Optional user supplied label which can be used
        /// instead of the type_id to retrieve all tables with the given label.
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTablesByTypeResponse showTablesByType( string type_id,
                                                          string label,
                                                          IDictionary<string, string> options = null )
        {
            return showTablesByType( new ShowTablesByTypeRequest( type_id, label, options ) );
        }


        /// <summary>Retrieves information regarding the specified triggers or
        /// all existing triggers currently active.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTriggersResponse showTriggers( ShowTriggersRequest request_ )
        {
            ShowTriggersResponse actualResponse_ = SubmitRequest<ShowTriggersResponse>("/show/triggers", request_, false);

            return actualResponse_;
        }


        /// <summary>Retrieves information regarding the specified triggers or
        /// all existing triggers currently active.</summary>
        /// 
        /// <param name="trigger_ids">List of IDs of the triggers whose
        /// information to be retrieved. Empty list means retrieve information
        /// on all active triggers.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTriggersResponse showTriggers( IList<string> trigger_ids,
                                                  IDictionary<string, string> options = null )
        {
            return showTriggers( new ShowTriggersRequest( trigger_ids, options ) );
        }


        /// <summary>Retrieves information for the specified data type. Given a
        /// type ID, the database returns the data type schema, the label, and
        /// the semantic type along with the type ID. If the user provides any
        /// combination of label and semantic type, then the database returns
        /// the pertinent information for all data types that match the input
        /// criteria.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTypesResponse showTypes( ShowTypesRequest request_ )
        {
            ShowTypesResponse actualResponse_ = SubmitRequest<ShowTypesResponse>("/show/types", request_, false);


            for ( int i_ = 0; i_ < actualResponse_.type_ids.Count; ++i_ )
            {
                SetDecoderIfMissing( actualResponse_.type_ids[i_],
                                     actualResponse_.labels[i_],
                                     actualResponse_.type_schemas[i_],
                                     actualResponse_.properties[i_] );
            }

            return actualResponse_;
        }


        /// <summary>Retrieves information for the specified data type. Given a
        /// type ID, the database returns the data type schema, the label, and
        /// the semantic type along with the type ID. If the user provides any
        /// combination of label and semantic type, then the database returns
        /// the pertinent information for all data types that match the input
        /// criteria.</summary>
        /// 
        /// <param name="type_id">Type Id returned in response to a call to
        /// /create/type.  </param>
        /// <param name="label">Option string that was supplied by user in a
        /// call to /create/type.  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public ShowTypesResponse showTypes( string type_id,
                                            string label,
                                            IDictionary<string, string> options = null )
        {
            return showTypes( new ShowTypesRequest( type_id, label, options ) );
        }


        /// <summary>Runs multiple predicate-based updates in a single call.
        /// With the list of given expressions, any matching record's column
        /// values will be updated as provided in <paramref
        /// cref="RawUpdateRecordsRequest.new_values_maps" />.  There is also
        /// an optional 'upsert' capability where if a particular predicate
        /// doesn't match any existing record, then a new record can be
        /// inserted.
        /// <br />
        /// Note that this operation can only be run on an original table and
        /// not on a collection or a result view.
        /// <br />
        /// This operation can update primary key values.  By default only
        /// 'pure primary key' predicates are allowed when updating primary key
        /// values. If the primary key for a table is the column 'attr1', then
        /// the operation will only accept predicates of the form: "attr1 ==
        /// 'foo'" if the attr1 column is being updated.  For a composite
        /// primary key (e.g. columns 'attr1' and 'attr2') then this operation
        /// will only accept predicates of the form: "(attr1 == 'foo') and
        /// (attr2 == 'bar')".  Meaning, all primary key columns must appear in
        /// an equality predicate in the expressions.  Furthermore each 'pure
        /// primary key' predicate must be unique within a given request.
        /// These restrictions can be removed by utilizing some available
        /// options through <paramref cref="RawUpdateRecordsRequest.options"
        /// />.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public UpdateRecordsResponse updateRecordsRaw( RawUpdateRecordsRequest request_ )
        {
            UpdateRecordsResponse actualResponse_ = SubmitRequest<UpdateRecordsResponse>("/update/records", request_, true);

            return actualResponse_;
        }


        /// <summary>Runs multiple predicate-based updates in a single call.
        /// With the list of given expressions, any matching record's column
        /// values will be updated as provided in <paramref
        /// cref="RawUpdateRecordsRequest.new_values_maps" />.  There is also
        /// an optional 'upsert' capability where if a particular predicate
        /// doesn't match any existing record, then a new record can be
        /// inserted.
        /// <br />
        /// Note that this operation can only be run on an original table and
        /// not on a collection or a result view.
        /// <br />
        /// This operation can update primary key values.  By default only
        /// 'pure primary key' predicates are allowed when updating primary key
        /// values. If the primary key for a table is the column 'attr1', then
        /// the operation will only accept predicates of the form: "attr1 ==
        /// 'foo'" if the attr1 column is being updated.  For a composite
        /// primary key (e.g. columns 'attr1' and 'attr2') then this operation
        /// will only accept predicates of the form: "(attr1 == 'foo') and
        /// (attr2 == 'bar')".  Meaning, all primary key columns must appear in
        /// an equality predicate in the expressions.  Furthermore each 'pure
        /// primary key' predicate must be unique within a given request.
        /// These restrictions can be removed by utilizing some available
        /// options through <paramref cref="RawUpdateRecordsRequest.options"
        /// />.</summary>
        /// 
        /// <typeparam name="T">The type of object being added.</typeparam>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public UpdateRecordsResponse updateRecords<T>( UpdateRecordsRequest<T> request_ )
        {
            RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest();
            actualRequest_.table_name = request_.table_name;
            actualRequest_.expressions = request_.expressions;
            actualRequest_.new_values_maps = request_.new_values_maps;
            foreach (var thisObj in request_.data) actualRequest_.records_to_insert.Add( AvroEncode( thisObj ) );
            actualRequest_.options = request_.options;
            UpdateRecordsResponse actualResponse_ = SubmitRequest<UpdateRecordsResponse>("/update/records", actualRequest_, true);

            return actualResponse_;
        }


        /// <summary>Runs multiple predicate-based updates in a single call.
        /// With the list of given expressions, any matching record's column
        /// values will be updated as provided in <paramref
        /// name="new_values_maps" />.  There is also an optional 'upsert'
        /// capability where if a particular predicate doesn't match any
        /// existing record, then a new record can be inserted.
        /// <br />
        /// Note that this operation can only be run on an original table and
        /// not on a collection or a result view.
        /// <br />
        /// This operation can update primary key values.  By default only
        /// 'pure primary key' predicates are allowed when updating primary key
        /// values. If the primary key for a table is the column 'attr1', then
        /// the operation will only accept predicates of the form: "attr1 ==
        /// 'foo'" if the attr1 column is being updated.  For a composite
        /// primary key (e.g. columns 'attr1' and 'attr2') then this operation
        /// will only accept predicates of the form: "(attr1 == 'foo') and
        /// (attr2 == 'bar')".  Meaning, all primary key columns must appear in
        /// an equality predicate in the expressions.  Furthermore each 'pure
        /// primary key' predicate must be unique within a given request.
        /// These restrictions can be removed by utilizing some available
        /// options through <paramref name="options" />.</summary>
        /// 
        /// <typeparam name="T">The type of object being added.</typeparam>
        /// 
        /// <param name="table_name">Table to be updated. Must be a currently
        /// existing table and not a collection or view.  </param>
        /// <param name="expressions">A list of the actual predicates, one for
        /// each update; format should follow the guidelines /filter.  </param>
        /// <param name="new_values_maps">List of new values for the matching
        /// records.  Each element is a map with (key, value) pairs where the
        /// keys are the names of the columns whose values are to be updated;
        /// the values are the new values.  The number of elements in the list
        /// should match the length of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.  </param>
        /// <param name="data">An *optional* list of new binary-avro encoded
        /// records to insert, one for each update.  If one of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" /> does not yield a
        /// matching record to be updated, then the corresponding element from
        /// this list will be added to the table.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>global_expression</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term>bypass_safety_checks</term>
        ///         <description>When set to 'true', all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>update_on_existing_pk</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists, as described in
        /// /insert/records. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>record_id</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public UpdateRecordsResponse updateRecords<T>( string table_name,
                                                       IList<string> expressions,
                                                       IList<IDictionary<string, string>> new_values_maps,
                                                       IList<T> data = null,
                                                       IDictionary<string, string> options = null )
        {
            return updateRecords<T>( new UpdateRecordsRequest<T>( table_name, expressions,
                                                                  new_values_maps, data,
                                                                  options ) );
        }


        /// <summary>Updates the view specified by <paramref
        /// cref="UpdateRecordsBySeriesRequest.table_name" /> to include full
        /// series (track) information from the <paramref
        /// cref="UpdateRecordsBySeriesRequest.world_table_name" /> for the
        /// series (tracks) present in the <paramref
        /// cref="UpdateRecordsBySeriesRequest.view_name" />.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public UpdateRecordsBySeriesResponse updateRecordsBySeries( UpdateRecordsBySeriesRequest request_ )
        {
            UpdateRecordsBySeriesResponse actualResponse_ = SubmitRequest<UpdateRecordsBySeriesResponse>("/update/records/byseries", request_, false);

            return actualResponse_;
        }


        /// <summary>Updates the view specified by <paramref name="table_name"
        /// /> to include full series (track) information from the <paramref
        /// name="world_table_name" /> for the series (tracks) present in the
        /// <paramref name="view_name" />.</summary>
        /// 
        /// <param name="table_name">Name of the view on which the update
        /// operation will be performed. Must be an existing view.  </param>
        /// <param name="world_table_name">Name of the table containing the
        /// complete series (track) information.  </param>
        /// <param name="view_name">Optional name of the view containing the
        /// series (tracks) which have to be updated.  </param>
        /// <param name="reserved"></param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public UpdateRecordsBySeriesResponse updateRecordsBySeries( string table_name,
                                                                    string world_table_name,
                                                                    string view_name = "",
                                                                    IList<string> reserved = null,
                                                                    IDictionary<string, string> options = null )
        {
            return updateRecordsBySeries( new UpdateRecordsBySeriesRequest( table_name,
                                                                            world_table_name,
                                                                            view_name,
                                                                            reserved,
                                                                            options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageResponse visualizeImage( VisualizeImageRequest request_ )
        {
            VisualizeImageResponse actualResponse_ = SubmitRequest<VisualizeImageResponse>("/visualize/image", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="table_names"></param>
        /// <param name="world_table_names"></param>
        /// <param name="x_column_name"></param>
        /// <param name="y_column_name"></param>
        /// <param name="track_ids"></param>
        /// <param name="min_x"></param>
        /// <param name="max_x"></param>
        /// <param name="min_y"></param>
        /// <param name="max_y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="projection">Values: EPSG:4326, PLATE_CARREE, 900913,
        /// EPSG:900913, 102100, EPSG:102100, 3857, EPSG:3857, WEB_MERCATOR.
        /// </param>
        /// <param name="bg_color"></param>
        /// <param name="style_options">
        /// <list type="bullet">
        ///     <item>
        ///         <term>do_points</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_shapes</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_tracks</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_symbology</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>pointcolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>pointsizes</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>pointshapes</term>
        ///         <description>Values: none, circle, square, diamond,
        /// hollowcircle, hollowsquare, hollowdiamond, SYMBOLCODE.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>shapelinewidths</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>shapelinecolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>shapefillcolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>tracklinewidths</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>tracklinecolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkersizes</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkercolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkershapes</term>
        ///         <description>Values: none, circle, square, diamond,
        /// hollowcircle, hollowsquare, hollowdiamond, SYMBOLCODE.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadcolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadsizes</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadshapes</term>
        ///         <description>Values: none, circle, square, diamond,
        /// hollowcircle, hollowsquare, hollowdiamond, SYMBOLCODE.
        /// </description>
        ///     </item>
        /// </list>
        /// </param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageResponse visualizeImage( IList<string> table_names,
                                                      IList<string> world_table_names,
                                                      string x_column_name,
                                                      string y_column_name,
                                                      IList<IList<string>> track_ids,
                                                      double min_x,
                                                      double max_x,
                                                      double min_y,
                                                      double max_y,
                                                      int width,
                                                      int height,
                                                      string projection,
                                                      long bg_color,
                                                      IDictionary<string, IList<string>> style_options,
                                                      IDictionary<string, string> options = null )
        {
            return visualizeImage( new VisualizeImageRequest( table_names,
                                                              world_table_names,
                                                              x_column_name,
                                                              y_column_name, track_ids,
                                                              min_x, max_x, min_y, max_y,
                                                              width, height, projection,
                                                              bg_color, style_options,
                                                              options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageClassbreakResponse visualizeImageClassbreak( VisualizeImageClassbreakRequest request_ )
        {
            VisualizeImageClassbreakResponse actualResponse_ = SubmitRequest<VisualizeImageClassbreakResponse>("/visualize/image/classbreak", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="table_names"></param>
        /// <param name="world_table_names"></param>
        /// <param name="x_column_name"></param>
        /// <param name="y_column_name"></param>
        /// <param name="track_ids"></param>
        /// <param name="cb_column_name1"></param>
        /// <param name="cb_vals1"></param>
        /// <param name="cb_column_name2"></param>
        /// <param name="cb_vals2"></param>
        /// <param name="min_x"></param>
        /// <param name="max_x"></param>
        /// <param name="min_y"></param>
        /// <param name="max_y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="projection">Values: EPSG:4326, PLATE_CARREE, 900913,
        /// EPSG:900913, 102100, EPSG:102100, 3857, EPSG:3857, WEB_MERCATOR.
        /// </param>
        /// <param name="bg_color"></param>
        /// <param name="style_options">
        /// <list type="bullet">
        ///     <item>
        ///         <term>do_points</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_shapes</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_tracks</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_symbology</term>
        ///         <description>Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>pointcolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>pointsizes</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>pointshapes</term>
        ///         <description>Values: none, circle, square, diamond,
        /// hollowcircle, hollowsquare, hollowdiamond, SYMBOLCODE.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>shapelinewidths</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>shapelinecolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>shapefillcolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>tracklinewidths</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>tracklinecolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkersizes</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkercolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkershapes</term>
        ///         <description>Values: none, circle, square, diamond,
        /// hollowcircle, hollowsquare, hollowdiamond, SYMBOLCODE.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadcolors</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadsizes</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadshapes</term>
        ///         <description>Values: none, circle, square, diamond,
        /// hollowcircle, hollowsquare, hollowdiamond, SYMBOLCODE.
        /// </description>
        ///     </item>
        /// </list>
        /// </param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageClassbreakResponse visualizeImageClassbreak( IList<string> table_names,
                                                                          IList<string> world_table_names,
                                                                          string x_column_name,
                                                                          string y_column_name,
                                                                          IList<IList<string>> track_ids,
                                                                          string cb_column_name1,
                                                                          IList<string> cb_vals1,
                                                                          IList<string> cb_column_name2,
                                                                          IList<IList<string>> cb_vals2,
                                                                          double min_x,
                                                                          double max_x,
                                                                          double min_y,
                                                                          double max_y,
                                                                          int width,
                                                                          int height,
                                                                          string projection,
                                                                          long bg_color,
                                                                          IDictionary<string, IList<string>> style_options,
                                                                          IDictionary<string, string> options = null )
        {
            return visualizeImageClassbreak( new VisualizeImageClassbreakRequest(
                                                                                  table_names,
                                                                                  world_table_names,
                                                                                  x_column_name,
                                                                                  y_column_name,
                                                                                  track_ids,
                                                                                  cb_column_name1,
                                                                                  cb_vals1,
                                                                                  cb_column_name2,
                                                                                  cb_vals2,
                                                                                  min_x,
                                                                                  max_x,
                                                                                  min_y,
                                                                                  max_y,
                                                                                  width,
                                                                                  height,
                                                                                  projection,
                                                                                  bg_color,
                                                                                  style_options,
                                                                                  options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageHeatmapResponse visualizeImageHeatmap( VisualizeImageHeatmapRequest request_ )
        {
            VisualizeImageHeatmapResponse actualResponse_ = SubmitRequest<VisualizeImageHeatmapResponse>("/visualize/image/heatmap", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="table_names"></param>
        /// <param name="x_column_name"></param>
        /// <param name="y_column_name"></param>
        /// <param name="value_column_name"></param>
        /// <param name="min_x"></param>
        /// <param name="max_x"></param>
        /// <param name="min_y"></param>
        /// <param name="max_y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="projection">Values: EPSG:4326, PLATE_CARREE, 900913,
        /// EPSG:900913, 102100, EPSG:102100, 3857, EPSG:3857, WEB_MERCATOR.
        /// </param>
        /// <param name="style_options">
        /// <list type="bullet">
        ///     <item>
        ///         <term>colormap</term>
        ///         <description>Values: jet, hot, hsv, gray, blues, greens,
        /// greys, oranges, purples, reds, viridis.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>blur_radius</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>bg_color</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>gradient_start_color</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>gradient_end_color</term>
        ///         <description></description>
        ///     </item>
        /// </list>
        /// </param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageHeatmapResponse visualizeImageHeatmap( IList<string> table_names,
                                                                    string x_column_name,
                                                                    string y_column_name,
                                                                    string value_column_name,
                                                                    double min_x,
                                                                    double max_x,
                                                                    double min_y,
                                                                    double max_y,
                                                                    int width,
                                                                    int height,
                                                                    string projection,
                                                                    IDictionary<string, string> style_options,
                                                                    IDictionary<string, string> options = null )
        {
            return visualizeImageHeatmap( new VisualizeImageHeatmapRequest( table_names,
                                                                            x_column_name,
                                                                            y_column_name,
                                                                            value_column_name,
                                                                            min_x, max_x,
                                                                            min_y, max_y,
                                                                            width, height,
                                                                            projection,
                                                                            style_options,
                                                                            options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageLabelsResponse visualizeImageLabels( VisualizeImageLabelsRequest request_ )
        {
            VisualizeImageLabelsResponse actualResponse_ = SubmitRequest<VisualizeImageLabelsResponse>("/visualize/image/labels", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="table_name"></param>
        /// <param name="x_column_name"></param>
        /// <param name="y_column_name"></param>
        /// <param name="x_offset"></param>
        /// <param name="y_offset"></param>
        /// <param name="text_string"></param>
        /// <param name="font"></param>
        /// <param name="text_color"></param>
        /// <param name="text_angle"></param>
        /// <param name="text_scale"></param>
        /// <param name="draw_box"></param>
        /// <param name="draw_leader"></param>
        /// <param name="line_width"></param>
        /// <param name="line_color"></param>
        /// <param name="fill_color"></param>
        /// <param name="leader_x_column_name"></param>
        /// <param name="leader_y_column_name"></param>
        /// <param name="min_x"></param>
        /// <param name="max_x"></param>
        /// <param name="min_y"></param>
        /// <param name="max_y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="projection">Values: EPSG:4326, PLATE_CARREE, 900913,
        /// EPSG:900913, 102100, EPSG:102100, 3857, EPSG:3857, WEB_MERCATOR.
        /// </param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeImageLabelsResponse visualizeImageLabels( string table_name,
                                                                  string x_column_name,
                                                                  string y_column_name,
                                                                  string x_offset,
                                                                  string y_offset,
                                                                  string text_string,
                                                                  string font,
                                                                  string text_color,
                                                                  string text_angle,
                                                                  string text_scale,
                                                                  string draw_box,
                                                                  string draw_leader,
                                                                  string line_width,
                                                                  string line_color,
                                                                  string fill_color,
                                                                  string leader_x_column_name,
                                                                  string leader_y_column_name,
                                                                  double min_x,
                                                                  double max_x,
                                                                  double min_y,
                                                                  double max_y,
                                                                  int width,
                                                                  int height,
                                                                  string projection = VisualizeImageLabelsRequest.Projection.PLATE_CARREE,
                                                                  IDictionary<string, string> options = null )
        {
            return visualizeImageLabels( new VisualizeImageLabelsRequest( table_name,
                                                                          x_column_name,
                                                                          y_column_name,
                                                                          x_offset,
                                                                          y_offset,
                                                                          text_string,
                                                                          font,
                                                                          text_color,
                                                                          text_angle,
                                                                          text_scale,
                                                                          draw_box,
                                                                          draw_leader,
                                                                          line_width,
                                                                          line_color,
                                                                          fill_color,
                                                                          leader_x_column_name,
                                                                          leader_y_column_name,
                                                                          min_x, max_x,
                                                                          min_y, max_y,
                                                                          width, height,
                                                                          projection,
                                                                          options ) );
        }


        /// <summary>Creates raster images of data in the given table based on
        /// provided input parameters. Numerous parameters are required to call
        /// this function. Some of the important parameters are the attributes
        /// of the generated images (<paramref
        /// cref="VisualizeVideoRequest.bg_color" />, <paramref
        /// cref="VisualizeVideoRequest.width" />, <paramref
        /// cref="VisualizeVideoRequest.height" />), the collection of table
        /// names on which this function is to be applied, for which shapes
        /// (point, polygon, tracks) the images are to be created and a user
        /// specified session key. This session key is later used to fetch the
        /// generated images. The operation is synchronous, meaning that a
        /// response will not be returned until the images for all the frames
        /// of the video are fully available.
        /// <br />
        /// Once the request has been processed then the generated video frames
        /// are available for download via WMS using STYLES=cached. In this
        /// request the LAYERS parameter should be populated with the session
        /// key passed in <paramref cref="VisualizeVideoRequest.session_key" />
        /// of the visualize video request and the FRAME parameter indicates
        /// which 0-based frame of the video should be returned. All other WMS
        /// parameters are ignored for this mode.
        /// <br />
        /// For instance, if a 20 frame video with the session key
        /// 'MY-SESSION-KEY' was generated, the first frame could be retrieved
        /// with the URL:
        /// <br />
        ///     <a href="../../../rest/wms_rest.html"
        /// target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0</a>
        /// <br />
        /// and the last frame could be retrieved with:
        /// <br />
        ///     <a href="../../../rest/wms_rest.html"
        /// target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19</a>
        /// <br />
        /// The response payload provides, among other things, the number of
        /// frames which were created.</summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeVideoResponse visualizeVideo( VisualizeVideoRequest request_ )
        {
            VisualizeVideoResponse actualResponse_ = SubmitRequest<VisualizeVideoResponse>("/visualize/video", request_, false);

            return actualResponse_;
        }


        /// <summary>Creates raster images of data in the given table based on
        /// provided input parameters. Numerous parameters are required to call
        /// this function. Some of the important parameters are the attributes
        /// of the generated images (<paramref name="bg_color" />, <paramref
        /// name="width" />, <paramref name="height" />), the collection of
        /// table names on which this function is to be applied, for which
        /// shapes (point, polygon, tracks) the images are to be created and a
        /// user specified session key. This session key is later used to fetch
        /// the generated images. The operation is synchronous, meaning that a
        /// response will not be returned until the images for all the frames
        /// of the video are fully available.
        /// <br />
        /// Once the request has been processed then the generated video frames
        /// are available for download via WMS using STYLES=cached. In this
        /// request the LAYERS parameter should be populated with the session
        /// key passed in <paramref name="session_key" /> of the visualize
        /// video request and the FRAME parameter indicates which 0-based frame
        /// of the video should be returned. All other WMS parameters are
        /// ignored for this mode.
        /// <br />
        /// For instance, if a 20 frame video with the session key
        /// 'MY-SESSION-KEY' was generated, the first frame could be retrieved
        /// with the URL:
        /// <br />
        ///     <a href="../../../rest/wms_rest.html"
        /// target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0</a>
        /// <br />
        /// and the last frame could be retrieved with:
        /// <br />
        ///     <a href="../../../rest/wms_rest.html"
        /// target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19</a>
        /// <br />
        /// The response payload provides, among other things, the number of
        /// frames which were created.</summary>
        /// 
        /// <param name="table_names">Names of the tables containing the data
        /// for various layers of the resulting video.  </param>
        /// <param name="world_table_names">Optional name of the tables
        /// containing the data for the entire track when the <paramref
        /// cref="VisualizeVideoRequest.table_names" /> contains only part of
        /// the track data, but the entire track has to be rendered. The number
        /// of tables should match the number of tables in the <paramref
        /// cref="VisualizeVideoRequest.table_names" />  </param>
        /// <param name="track_ids">Tracks from the <paramref
        /// cref="VisualizeVideoRequest.table_names" /> to be rendered.
        /// </param>
        /// <param name="x_column_name">Name of the column containing the x
        /// coordinates.  </param>
        /// <param name="y_column_name">Name of the column containing the y
        /// coordinates.  </param>
        /// <param name="min_x">Lower bound for the x values.  </param>
        /// <param name="max_x">Upper bound for the x values.  </param>
        /// <param name="min_y">Lower bound for the y values.  </param>
        /// <param name="max_y">Upper bound for the y values.  </param>
        /// <param name="width">Width of the generated image.  </param>
        /// <param name="height">Height of the generated image.  </param>
        /// <param name="projection">Spatial Reference System (i.e. EPSG Code).
        /// Values: EPSG:4326, PLATE_CARREE, 900913, EPSG:900913, 102100,
        /// EPSG:102100, 3857, EPSG:3857, WEB_MERCATOR.
        ///   </param>
        /// <param name="bg_color">Background color of the generated image.
        /// </param>
        /// <param name="time_intervals"></param>
        /// <param name="video_style"></param>
        /// <param name="session_key">User Provided session key that is later
        /// used to retrieve the generated video from the WMS.  </param>
        /// <param name="style_options">Styling options for the image.
        /// <list type="bullet">
        ///     <item>
        ///         <term>do_points</term>
        ///         <description>Rasterize point data toggle. Values: true,
        /// false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_shapes</term>
        ///         <description>Rasterize shapes toggle. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>do_tracks</term>
        ///         <description>Rasterize tracks toggle. Values: true, false.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>pointcolors</term>
        ///         <description>RGB color value in hex for the
        /// points.</description>
        ///     </item>
        ///     <item>
        ///         <term>pointsizes</term>
        ///         <description>Size of points.</description>
        ///     </item>
        ///     <item>
        ///         <term>pointshapes</term>
        ///         <description>Shape of the point. Values: none, circle,
        /// square, diamond, hollowcircle, hollowsquare, hollowdiamond,
        /// SYMBOLCODE.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>shapelinewidths</term>
        ///         <description>Width of the lines.</description>
        ///     </item>
        ///     <item>
        ///         <term>shapelinecolors</term>
        ///         <description>RGB color values in hex for the
        /// line.</description>
        ///     </item>
        ///     <item>
        ///         <term>shapefillcolors</term>
        ///         <description>RGB color values in hex for the fill color of
        /// the shapes. Use '-1' for no fill.</description>
        ///     </item>
        ///     <item>
        ///         <term>tracklinewidths</term>
        ///         <description>Width of the track lines. '0' implies do not
        /// draw track lines.</description>
        ///     </item>
        ///     <item>
        ///         <term>tracklinecolors</term>
        ///         <description>RGB color values for the track
        /// lines.</description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkersizes</term>
        ///         <description>Size of the track point markers.</description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkercolors</term>
        ///         <description>Color of the track point
        /// markers.</description>
        ///     </item>
        ///     <item>
        ///         <term>trackmarkershapes</term>
        ///         <description>Shape of track point markers. Values: none,
        /// circle, square, diamond, hollowcircle, hollowsquare, hollowdiamond,
        /// SYMBOLCODE.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadcolors</term>
        ///         <description>Color of track head markers.</description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadsizes</term>
        ///         <description>Size of track head markers.</description>
        ///     </item>
        ///     <item>
        ///         <term>trackheadshapes</term>
        ///         <description>Shape of track head markers. Values: none,
        /// circle, square, diamond, hollowcircle, hollowsquare, hollowdiamond,
        /// SYMBOLCODE.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeVideoResponse visualizeVideo( IList<string> table_names,
                                                      IList<string> world_table_names,
                                                      IList<IList<string>> track_ids,
                                                      string x_column_name,
                                                      string y_column_name,
                                                      double min_x,
                                                      double max_x,
                                                      double min_y,
                                                      double max_y,
                                                      int width,
                                                      int height,
                                                      string projection,
                                                      long bg_color,
                                                      IList<IList<double>> time_intervals,
                                                      string video_style,
                                                      string session_key,
                                                      IDictionary<string, IList<string>> style_options,
                                                      IDictionary<string, string> options = null )
        {
            return visualizeVideo( new VisualizeVideoRequest( table_names,
                                                              world_table_names,
                                                              track_ids, x_column_name,
                                                              y_column_name, min_x, max_x,
                                                              min_y, max_y, width, height,
                                                              projection, bg_color,
                                                              time_intervals, video_style,
                                                              session_key, style_options,
                                                              options ) );
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="request_">Request object containing the parameters for
        /// the operation.</param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeVideoHeatmapResponse visualizeVideoHeatmap( VisualizeVideoHeatmapRequest request_ )
        {
            VisualizeVideoHeatmapResponse actualResponse_ = SubmitRequest<VisualizeVideoHeatmapResponse>("/visualize/video/heatmap", request_, false);

            return actualResponse_;
        }


        /// <summary>@private
        /// </summary>
        /// 
        /// <param name="table_names"></param>
        /// <param name="x_column_name"></param>
        /// <param name="y_column_name"></param>
        /// <param name="min_x"></param>
        /// <param name="max_x"></param>
        /// <param name="min_y"></param>
        /// <param name="max_y"></param>
        /// <param name="time_intervals"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="projection">Values: EPSG:4326, PLATE_CARREE, 900913,
        /// EPSG:900913, 102100, EPSG:102100, 3857, EPSG:3857, WEB_MERCATOR.
        /// </param>
        /// <param name="video_style"></param>
        /// <param name="session_key"></param>
        /// <param name="style_options">
        /// <list type="bullet">
        ///     <item>
        ///         <term>colormap</term>
        ///         <description>Values: jet, hot, hsv, gray, blues, greens,
        /// greys, oranges, purples, reds.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>blur_radius</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>bg_color</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>gradient_start_color</term>
        ///         <description></description>
        ///     </item>
        ///     <item>
        ///         <term>gradient_end_color</term>
        ///         <description></description>
        ///     </item>
        /// </list>
        /// </param>
        /// <param name="options"></param>
        /// 
        /// <returns>Response object containing the result of the
        /// operation.</returns>
        /// 
        public VisualizeVideoHeatmapResponse visualizeVideoHeatmap( IList<string> table_names,
                                                                    string x_column_name,
                                                                    string y_column_name,
                                                                    double min_x,
                                                                    double max_x,
                                                                    double min_y,
                                                                    double max_y,
                                                                    IList<IList<double>> time_intervals,
                                                                    int width,
                                                                    int height,
                                                                    string projection,
                                                                    string video_style,
                                                                    string session_key,
                                                                    IDictionary<string, string> style_options,
                                                                    IDictionary<string, string> options = null )
        {
            return visualizeVideoHeatmap( new VisualizeVideoHeatmapRequest( table_names,
                                                                            x_column_name,
                                                                            y_column_name,
                                                                            min_x, max_x,
                                                                            min_y, max_y,
                                                                            time_intervals,
                                                                            width, height,
                                                                            projection,
                                                                            video_style,
                                                                            session_key,
                                                                            style_options,
                                                                            options ) );
        }


    }  // end class Kinetica
}  // end namespace kinetica

