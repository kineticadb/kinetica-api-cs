/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

using System.Collections.Generic;



namespace kinetica
{

    /// <summary>A set of parameters for /aggregate/groupby.
    /// <br />
    /// Calculates unique combinations (groups) of values for the given columns
    /// in a given table/view/collection and computes aggregates on each unique
    /// combination. This is somewhat analogous to an SQL-style SELECT...GROUP
    /// BY. Any column(s) can be grouped on, but only non-string (i.e. numeric)
    /// columns may be used for computing aggregates. The results can be paged
    /// via the <member name="offset" /> and <member name="limit" />
    /// parameters. For example, to get 10 groups with the largest counts the
    /// inputs would be: limit=10, options={"sort_order":"descending",
    /// "sort_by":"value"}. <member name="options" /> can be used to customize
    /// behavior of this call e.g. filtering or sorting the results. To group
    /// by 'x' and 'y' and compute the number of objects within each group, use
    /// column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
    /// each group, use column_names=['x','y','count(*)','sum(z)']. Available
    /// aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
    /// 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop',
    /// 'var_samp', 'arg_min', 'arg_max' and 'count_distinct'. The response is
    /// returned as a dynamic schema. For details see: <a
    /// href="../../../../../concepts/dynamic_schemas.html"
    /// target="_top">dynamic schemas documentation</a>. If the 'result_table'
    /// option is provided then the results are stored in a table with the name
    /// given in the option and the results are not returned in the
    /// response.</summary>
    public class AggregateGroupByRequest : KineticaData
    {

        /// <summary>Specifies the encoding for returned records. Values:
        /// binary, json.
        /// <br />
        /// A set of string constants for the parameter <member name="encoding"
        /// />.</summary>
        public struct Encoding
        {

            /// <summary>Indicates that the returned records should be binary
            /// encoded.</summary>
            public const string BINARY = "binary";

            /// <summary>Indicates that the returned records should be json
            /// encoded.</summary>
            public const string JSON = "json";
        } // end struct Encoding


        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection which is to contain the
        /// table specified in 'result_table', otherwise the table will be a
        /// top-level table. If the collection does not allow duplicate types
        /// and it contains a table of the same type as the given one, then
        /// this table creation request will fail. Additionally this option is
        /// invalid if @input{table_name} is a collection.</description>
        ///     </item>
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Filter expression to apply to the table prior
        /// to computing the aggregate group by.</description>
        ///     </item>
        ///     <item>
        ///         <term>having</term>
        ///         <description>Filter expression to apply to the aggregated
        /// results.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted - ascending or descending. Values: ascending,
        /// descending.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>sort_by</term>
        ///         <description>String determining how the results are sorted.
        /// Values: key, value.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>result_table</term>
        ///         <description>The name of the table used to store the
        /// results. Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// Column names (group-by and aggregate fields) need to be given
        /// aliases e.g. ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
        /// present, no results are returned in the response.  This option is
        /// not available if one of the grouping attributes is an unrestricted
        /// string (i.e.; not charN) type.</description>
        ///     </item>
        ///     <item>
        ///         <term>ttl</term>
        ///         <description>Sets the TTL of the table specified in
        /// 'result_table'. The value must be the desired TTL in
        /// minutes.</description>
        ///     </item>
        /// </list>
        /// <br />
        /// A set of string constants for the parameter <member name="options"
        /// />.</summary>
        public struct Options
        {

            /// <summary>Name of a collection which is to contain the table
            /// specified in 'result_table', otherwise the table will be a
            /// top-level table. If the collection does not allow duplicate
            /// types and it contains a table of the same type as the given
            /// one, then this table creation request will fail. Additionally
            /// this option is invalid if @input{table_name} is a
            /// collection.</summary>
            public const string COLLECTION_NAME = "collection_name";

            /// <summary>Filter expression to apply to the table prior to
            /// computing the aggregate group by.</summary>
            public const string EXPRESSION = "expression";

            /// <summary>Filter expression to apply to the aggregated
            /// results.</summary>
            public const string HAVING = "having";

            /// <summary>String indicating how the returned values should be
            /// sorted - ascending or descending. Values: ascending,
            /// descending.
            /// </summary>
            public const string SORT_ORDER = "sort_order";

            /// <summary>Indicates that the returned values should be sorted in
            /// ascending order.</summary>
            public const string ASCENDING = "ascending";

            /// <summary>Indicates that the returned values should be sorted in
            /// descending order.</summary>
            public const string DESCENDING = "descending";

            /// <summary>String determining how the results are sorted. Values:
            /// key, value.
            /// </summary>
            public const string SORT_BY = "sort_by";

            /// <summary>Indicates that the returned values should be sorted by
            /// key</summary>
            public const string KEY = "key";

            /// <summary>Indicates that the returned values should be sorted by
            /// value</summary>
            public const string VALUE = "value";

            /// <summary>The name of the table used to store the results. Has
            /// the same naming restrictions as <a
            /// href="../../../../../concepts/tables.html"
            /// target="_top">tables</a>. Column names (group-by and aggregate
            /// fields) need to be given aliases e.g. ["FChar256 as fchar256",
            /// "sum(FDouble) as sfd"].  If present, no results are returned in
            /// the response.  This option is not available if one of the
            /// grouping attributes is an unrestricted string (i.e.; not charN)
            /// type.</summary>
            public const string RESULT_TABLE = "result_table";

            /// <summary>Sets the TTL of the table specified in 'result_table'.
            /// The value must be the desired TTL in minutes.</summary>
            public const string TTL = "ttl";
        } // end struct Options


        /// <summary>Name of the table on which the operation will be
        /// performed. Must be an existing table/view/collection.  </summary>
        public string table_name { get; set; }

        /// <summary>List of one or more column names, expressions, and
        /// aggregate expressions. Must include at least one 'grouping' column
        /// or expression.  If no aggregate is included, count(*) will be
        /// computed as a default.  </summary>
        public IList<string> column_names { get; set; } = new List<string>();

        /// <summary>A positive integer indicating the number of initial
        /// results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </summary>
        public long offset { get; set; }

        /// <summary>A positive integer indicating the maximum number of
        /// results to be returned Or END_OF_SET (-9999) to indicate that the
        /// max number of results should be returned.  </summary>
        public long limit { get; set; } = 1000;

        /// <summary>Specifies the encoding for returned records. Values:
        /// binary, json.
        ///   </summary>
        public string encoding { get; set; } = Encoding.BINARY;

        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection which is to contain the
        /// table specified in 'result_table', otherwise the table will be a
        /// top-level table. If the collection does not allow duplicate types
        /// and it contains a table of the same type as the given one, then
        /// this table creation request will fail. Additionally this option is
        /// invalid if @input{table_name} is a collection.</description>
        ///     </item>
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Filter expression to apply to the table prior
        /// to computing the aggregate group by.</description>
        ///     </item>
        ///     <item>
        ///         <term>having</term>
        ///         <description>Filter expression to apply to the aggregated
        /// results.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted - ascending or descending. Values: ascending,
        /// descending.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>sort_by</term>
        ///         <description>String determining how the results are sorted.
        /// Values: key, value.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>result_table</term>
        ///         <description>The name of the table used to store the
        /// results. Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// Column names (group-by and aggregate fields) need to be given
        /// aliases e.g. ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
        /// present, no results are returned in the response.  This option is
        /// not available if one of the grouping attributes is an unrestricted
        /// string (i.e.; not charN) type.</description>
        ///     </item>
        ///     <item>
        ///         <term>ttl</term>
        ///         <description>Sets the TTL of the table specified in
        /// 'result_table'. The value must be the desired TTL in
        /// minutes.</description>
        ///     </item>
        /// </list>
        ///   </summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs an AggregateGroupByRequest object with default
        /// parameters.</summary>
        public AggregateGroupByRequest() { }

        /// <summary>Constructs an AggregateGroupByRequest object with the
        /// specified parameters.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the operation
        /// will be performed. Must be an existing table/view/collection.
        /// </param>
        /// <param name="column_names">List of one or more column names,
        /// expressions, and aggregate expressions. Must include at least one
        /// 'grouping' column or expression.  If no aggregate is included,
        /// count(*) will be computed as a default.  </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of results to be returned Or END_OF_SET (-9999) to indicate
        /// that the max number of results should be returned.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection which is to contain the
        /// table specified in 'result_table', otherwise the table will be a
        /// top-level table. If the collection does not allow duplicate types
        /// and it contains a table of the same type as the given one, then
        /// this table creation request will fail. Additionally this option is
        /// invalid if @input{table_name} is a collection.</description>
        ///     </item>
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Filter expression to apply to the table prior
        /// to computing the aggregate group by.</description>
        ///     </item>
        ///     <item>
        ///         <term>having</term>
        ///         <description>Filter expression to apply to the aggregated
        /// results.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted - ascending or descending. Values: ascending,
        /// descending.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>sort_by</term>
        ///         <description>String determining how the results are sorted.
        /// Values: key, value.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>result_table</term>
        ///         <description>The name of the table used to store the
        /// results. Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// Column names (group-by and aggregate fields) need to be given
        /// aliases e.g. ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
        /// present, no results are returned in the response.  This option is
        /// not available if one of the grouping attributes is an unrestricted
        /// string (i.e.; not charN) type.</description>
        ///     </item>
        ///     <item>
        ///         <term>ttl</term>
        ///         <description>Sets the TTL of the table specified in
        /// 'result_table'. The value must be the desired TTL in
        /// minutes.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        public AggregateGroupByRequest( string table_name,
                                        IList<string> column_names,
                                        long offset,
                                        long limit = 1000,
                                        IDictionary<string, string> options = null)
        {
            this.table_name = table_name ?? "";
            this.column_names = column_names ?? new List<string>();
            this.offset = offset;
            this.limit = limit;
            this.encoding = Encoding.BINARY;
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor


        /// <summary>Constructs an AggregateGroupByRequest object with the
        /// specified parameters.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the operation
        /// will be performed. Must be an existing table/view/collection.
        /// </param>
        /// <param name="column_names">List of one or more column names,
        /// expressions, and aggregate expressions. Must include at least one
        /// 'grouping' column or expression.  If no aggregate is included,
        /// count(*) will be computed as a default.  </param>
        /// <param name="offset">A positive integer indicating the number of
        /// initial results to skip (this can be useful for paging through the
        /// results).  The minimum allowed value is 0. The maximum allowed
        /// value is MAX_INT. </param>
        /// <param name="limit">A positive integer indicating the maximum
        /// number of results to be returned Or END_OF_SET (-9999) to indicate
        /// that the max number of results should be returned.  </param>
        /// <param name="encoding">Specifies the encoding for returned records.
        /// Values: binary, json.
        ///   </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>collection_name</term>
        ///         <description>Name of a collection which is to contain the
        /// table specified in 'result_table', otherwise the table will be a
        /// top-level table. If the collection does not allow duplicate types
        /// and it contains a table of the same type as the given one, then
        /// this table creation request will fail. Additionally this option is
        /// invalid if @input{table_name} is a collection.</description>
        ///     </item>
        ///     <item>
        ///         <term>expression</term>
        ///         <description>Filter expression to apply to the table prior
        /// to computing the aggregate group by.</description>
        ///     </item>
        ///     <item>
        ///         <term>having</term>
        ///         <description>Filter expression to apply to the aggregated
        /// results.</description>
        ///     </item>
        ///     <item>
        ///         <term>sort_order</term>
        ///         <description>String indicating how the returned values
        /// should be sorted - ascending or descending. Values: ascending,
        /// descending.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>sort_by</term>
        ///         <description>String determining how the results are sorted.
        /// Values: key, value.
        /// </description>
        ///     </item>
        ///     <item>
        ///         <term>result_table</term>
        ///         <description>The name of the table used to store the
        /// results. Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// Column names (group-by and aggregate fields) need to be given
        /// aliases e.g. ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
        /// present, no results are returned in the response.  This option is
        /// not available if one of the grouping attributes is an unrestricted
        /// string (i.e.; not charN) type.</description>
        ///     </item>
        ///     <item>
        ///         <term>ttl</term>
        ///         <description>Sets the TTL of the table specified in
        /// 'result_table'. The value must be the desired TTL in
        /// minutes.</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        public AggregateGroupByRequest( string table_name,
                                        IList<string> column_names,
                                        long offset,
                                        long limit = 1000,
                                        string encoding = null,
                                        IDictionary<string, string> options = null)
        {
            this.table_name = table_name ?? "";
            this.column_names = column_names ?? new List<string>();
            this.offset = offset;
            this.limit = limit;
            this.encoding = encoding ?? Encoding.BINARY;
            this.options = options ?? new Dictionary<string, string>();
        } // end full constructor

    } // end class AggregateGroupByRequest



    /// <summary>A set of results returned by /aggregate/groupby.</summary>
    public class RawAggregateGroupByResponse : KineticaData
    {

        /// <summary>Avro schema of <member name="binary_encoded_response" />
        /// or <member name="json_encoded_response" />.  </summary>
        public string response_schema_str { get; set; }

        /// <summary>Avro binary encoded response.  </summary>
        public byte[] binary_encoded_response { get; set; }

        /// <summary>Avro JSON encoded response.  </summary>
        public string json_encoded_response { get; set; }

        /// <summary>Total/Filtered number of records.  </summary>
        public long total_number_of_records { get; set; }

        /// <summary>Too many records. Returned a partial set.  </summary>
        public bool has_more_records { get; set; }

    } // end class RawAggregateGroupByResponse



    /// <summary>A set of results returned by /aggregate/groupby.</summary>
    public class AggregateGroupByResponse : KineticaData
    {

        /// <summary>Avro binary encoded response.  </summary>
        public IList<KineticaRecord> data { get; set; } = new List<KineticaRecord>();

        /// <summary>Total/Filtered number of records.  </summary>
        public long total_number_of_records { get; set; }

        /// <summary>Too many records. Returned a partial set.  </summary>
        public bool has_more_records { get; set; }

    } // end class AggregateGroupByResponse




}  // end namespace kinetica
