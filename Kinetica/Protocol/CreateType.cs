/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

using System.Collections.Generic;



namespace kinetica
{

    /// <summary>A set of parameters for /create/type.
    /// <br />
    /// Creates a new type describing the layout or schema of a table. The type
    /// definition is a JSON string describing the fields (i.e. columns) of the
    /// type. Each field consists of a name and a data type. Supported data
    /// types are: double, float, int, long, string, and bytes. In addition one
    /// or more properties can be specified for each column which customize the
    /// memory usage and query availability of that column.  Note that some
    /// properties are mutually exclusive--i.e. they cannot be specified for
    /// any given column simultaneously.  One example of mutually exclusive
    /// properties are <i>data</i> and <i>store_only</i>.
    /// <br />
    /// To set a *primary key* on one or more columns include the property
    /// 'primary_key' on the desired column_names. If a primary key is
    /// specified, then a uniqueness constraint is enforced, in that only a
    /// single object can exist with a given primary key. When /insert/records
    /// data into a table with a primary key, depending on the parameters in
    /// the request, incoming objects with primary keys that match existing
    /// objects will either overwrite (i.e. update) the existing object or will
    /// be skipped and not added into the set.
    /// <br />
    /// Example of a type definition with some of the parameters::
    /// <br />
    ///         {"type":"record",
    ///         "name":"point",
    ///         "fields":[{"name":"msg_id","type":"string"},
    ///                         {"name":"x","type":"double"},
    ///                         {"name":"y","type":"double"},
    ///                         {"name":"TIMESTAMP","type":"double"},
    ///                         {"name":"source","type":"string"},
    ///                         {"name":"group_id","type":"string"},
    ///                         {"name":"OBJECT_ID","type":"string"}]
    ///         }
    /// <br />
    /// Properties::
    /// <br />
    ///         {"group_id":["store_only"],
    ///         "msg_id":["store_only","text_search"]
    ///         }</summary>
    public class CreateTypeRequest : KineticaData
    {

        /// <summary>Each key-value pair specifies the properties to use for a
        /// given column where the key is the column name.  All keys used must
        /// be relevant column names for the given table.  Specifying any
        /// property overrides the default properties for that column (which is
        /// based on the column's data type).
        /// A set of string constants for the parameter <member
        /// name="properties" />.</summary>
        public struct Properties
        {

            /// <summary>Default property for all numeric and string type
            /// columns; makes the column available for GPU queries.</summary>
            public const string DATA = "data";

            /// <summary>Valid only for 'string' columns. Enables full text
            /// search for string columns. Can be set independently of *data*
            /// and *store_only*.</summary>
            public const string TEXT_SEARCH = "text_search";

            /// <summary>Persist the column value but do not make it available
            /// to queries (e.g. /filter/bybox)-i.e. it is mutually exclusive
            /// to the 'data' property. Any 'bytes' type column must have a
            /// 'store_only' property. This property reduces system memory
            /// usage.</summary>
            public const string STORE_ONLY = "store_only";

            /// <summary>Works in conjunction with the 'data' property for
            /// string columns. This property reduces system disk usage by
            /// disabling reverse string lookups. Queries like /filter,
            /// /filter/bylist, and /filter/byvalue work as usual but
            /// /aggregate/unique, /aggregate/groupby and /get/records/bycolumn
            /// are not allowed on columns with this property.</summary>
            public const string DISK_OPTIMIZED = "disk_optimized";

            /// <summary>Valid only for 'long' columns. Indicates that this
            /// field represents a timestamp and will be provided in
            /// milliseconds since the Unix epoch: 00:00:00 Jan 1 1970.  Dates
            /// represented by a timestamp must fall between the year 1000 and
            /// the year 2900.</summary>
            public const string TIMESTAMP = "timestamp";

            /// <summary>Valid only for 'string' columns.  It represents a SQL
            /// type NUMERIC(19, 4) data type.  There can be up to 15 digits
            /// before the decimal point and up to four digits in the
            /// fractional part.  The value can be positive or negative
            /// (indicated by a minus sign at the beginning).  This property is
            /// mutually exclusive with the 'text_search' property.</summary>
            public const string DECIMAL = "decimal";

            /// <summary>Valid only for 'string' columns.  Indicates that this
            /// field represents a date and will be provided in the format
            /// 'YYYY-MM-DD'.  The allowable range is 1000-01-01 through
            /// 2900-01-01.</summary>
            public const string DATE = "date";

            /// <summary>Valid only for 'string' columns.  Indicates that this
            /// field represents a time-of-day and will be provided in the
            /// format 'HH:MM:SS.mmm'.  The allowable range is 00:00:00.000
            /// through 23:59:59.999.</summary>
            public const string TIME = "time";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 1 character. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR1 = "char1";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 2 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR2 = "char2";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 4 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR4 = "char4";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 8 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR8 = "char8";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 16 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR16 = "char16";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 32 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR32 = "char32";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 64 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR64 = "char64";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 128 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR128 = "char128";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns. Strings with this
            /// property must be no longer than 256 characters. This property
            /// cannot be combined with *text_search*</summary>
            public const string CHAR256 = "char256";

            /// <summary>This property provides optimized memory and query
            /// performance for int columns. Ints with this property must be
            /// between -128 and +127 (inclusive)</summary>
            public const string INT8 = "int8";

            /// <summary>This property provides optimized memory and query
            /// performance for int columns. Ints with this property must be
            /// between -32768 and +32767 (inclusive)</summary>
            public const string INT16 = "int16";

            /// <summary>This property provides optimized memory, disk and
            /// query performance for string columns representing IPv4
            /// addresses (i.e. 192.168.1.1). Strings with this property must
            /// be of the form: A.B.C.D where A, B, C and D are in the range of
            /// 0-255.</summary>
            public const string IPV4 = "ipv4";

            /// <summary>This property indicates that this column will be part
            /// of (or the entire) primary key.</summary>
            public const string PRIMARY_KEY = "primary_key";

            /// <summary>This property indicates that this column will be part
            /// of (or the entire) shard key.</summary>
            public const string SHARD_KEY = "shard_key";

            /// <summary>This property indicates that this column is nullable.
            /// However, setting this property is insufficient for making the
            /// column nullable.  The user must declare the type of the column
            /// as a union between its regular type and 'null' in the avro
            /// schema for the record type in <member name="type_definition"
            /// />.  For example, if a column is of type integer and is
            /// nullable, then the entry for the column in the avro schema must
            /// be: ['int', 'null'].
            /// <br />
            /// The Java and C++ APIs have built-in convenience for bypassing
            /// setting the avro schema by hand.  For those two languages, one
            /// can use this property as usual and not have to worry about the
            /// avro schema for the record.</summary>
            public const string NULLABLE = "nullable";
        } // end struct Properties


        /// <summary>a JSON string describing the columns of the type to be
        /// registered.  </summary>
        public string type_definition { get; set; }

        /// <summary>A user-defined description string which can be used to
        /// differentiate between tables and types with otherwise identical
        /// schemas.  </summary>
        public string label { get; set; }

        /// <summary>Each key-value pair specifies the properties to use for a
        /// given column where the key is the column name.  All keys used must
        /// be relevant column names for the given table.  Specifying any
        /// property overrides the default properties for that column (which is
        /// based on the column's data type).  </summary>
        public IDictionary<string, IList<string>> properties { get; set; } = new Dictionary<string, IList<string>>();

        /// <summary>Optional parameters.  </summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs a CreateTypeRequest object with default
        /// parameters.</summary>
        public CreateTypeRequest() { }

        /// <summary>Constructs a CreateTypeRequest object with the specified
        /// parameters.</summary>
        /// 
        /// <param name="type_definition">a JSON string describing the columns
        /// of the type to be registered.  </param>
        /// <param name="label">A user-defined description string which can be
        /// used to differentiate between tables and types with otherwise
        /// identical schemas.  </param>
        /// <param name="properties">Each key-value pair specifies the
        /// properties to use for a given column where the key is the column
        /// name.  All keys used must be relevant column names for the given
        /// table.  Specifying any property overrides the default properties
        /// for that column (which is based on the column's data type).
        /// </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        public CreateTypeRequest( string type_definition,
                                  string label,
                                  IDictionary<string, IList<string>> properties = null,
                                  IDictionary<string, string> options = null)
        {
            this.type_definition = type_definition ?? "";
            this.label = label ?? "";
            this.properties = properties ?? new Dictionary<string, IList<string>>();
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor

    } // end class CreateTypeRequest



    /// <summary>A set of results returned by /create/type.</summary>
    public class CreateTypeResponse : KineticaData
    {

        /// <summary>An identifier representing the created type. This type_id
        /// can be used in subsequent calls to /create/table  </summary>
        public string type_id { get; set; }

        /// <summary>Value of <paramref
        /// cref="CreateTypeRequest.type_definition" />.  </summary>
        public string type_definition { get; set; }

        /// <summary>Value of <paramref cref="CreateTypeRequest.label" />.
        /// </summary>
        public string label { get; set; }

        /// <summary>Value of <paramref cref="CreateTypeRequest.properties" />.
        /// </summary>
        public IDictionary<string, IList<string>> properties { get; set; } = new Dictionary<string, IList<string>>();

    } // end class CreateTypeResponse




}  // end namespace kinetica
