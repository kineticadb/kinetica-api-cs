/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

using System.Collections.Generic;



namespace kinetica
{

    /// <summary>A set of parameters for /filter/bystring.
    /// <br />
    /// Calculates which objects from a table, collection, or view match a
    /// string expression for the given string columns. The 'mode' may be:
    /// <br />
    /// * search : full text search query with wildcards and boolean operators,
    /// e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no column
    /// can be specified in <member name="column_names" />; all string columns
    /// of the table that have text search enabled will be searched. Also, the
    /// first character of a search term cannot be a wildcard (* or ?), and
    /// search terms cannot be any of the following:  "a", "an", "and", "are",
    /// "as", "at", "be", "but", "by", "for", "if", "in", "into", "is", "it",
    /// "no", "not", "of", "on", "or", "such", "that", "the", "their", "then",
    /// "there", "these", "they", "this", "to", "was", "will", "with".
    ///     Search query types:
    ///         * Multiple search terms
    ///             ex. perfect union - will match any record containing
    /// "perfect", "union", or both.
    ///         * Exact phrases
    ///             ex. "Perfect Union" - will only match the exact phrase
    /// "Perfect Union"
    ///         * Boolean (NOT, AND, OR, parentheses. OR assumed if no operator
    /// specified)
    ///             ex. justice AND tranquility - will match only those records
    /// containing both justice and tranquility
    ///         * Zero or more char wildcard - (specified with '*')
    ///             ex, est*is* - will match any records containing a word that
    /// starts with "est" and ends with "sh", such as "establish",
    /// "establishable", and "establishment"
    ///         * Exactly one char wildcard - (specified with ?)
    ///             ex. est???is* - will only match strings that start with
    /// "est", followed by exactly three letters, followed by "is", followed by
    /// one more letter.  This would only match "establish"
    ///         * Fuzzy search (term~)
    ///             ex. rear~ will match rear,fear,bear,read,etc.
    ///         * Proximity - match two words within a specified distance of
    /// eachother
    ///             ex. "Union Tranquility"~10 will match any record that has
    /// the words Union and Tranquility within 10 words of eachother
    ///         * Range - inclusive [<term1> TO <term2>] and exclusive {<term1>
    /// TO <term2>}.  Note: This is a string search, so numbers will be seen as
    /// a string of numeric characters, not as a number.  Ex. 2 > 123
    ///             ex. [100 TO 200] will find all strings between 100 and 200
    /// inclusive.
    ///             ex. {alpha to beta} will find all strings between alpha and
    /// beta, but not the words alpha or beta
    ///         * escaping special characters - Special characters are escaped
    /// with a backslash(\), special characters are: + - && || ! ( ) { } [ ] ^
    /// " ~ * ? : \
    /// <br />
    /// * equals: exact whole-string match (accelerated)
    /// * contains: partial substring match (not accelerated).  If the column
    /// is a string type (non-charN) and the number of records is too large, it
    /// will return 0.
    /// * starts_with: strings that start with the given expression (not
    /// accelerated), If the column is a string type (non-charN) and the number
    /// of records is too large, it will return 0.
    /// * regex: full regular expression search (not accelerated). If the
    /// column is a string type (non-charN) and the number of records is too
    /// large, it will return 0.
    /// <br />
    /// The options 'case_sensitive' can be used to modify the behavior for all
    /// modes except 'search'</summary>
    public class FilterByStringRequest : KineticaData
    {

        /// <summary>The string filtering mode to apply. See above for details.
        /// Values: search, equals, contains, starts_with, regex.
        /// <br />
        /// A set of string constants for the parameter <member name="mode"
        /// />.</summary>
        public struct Mode
        {
            public const string SEARCH = "search";
            public const string EQUALS = "equals";
            public const string CONTAINS = "contains";
            public const string STARTS_WITH = "starts_with";
            public const string REGEX = "regex";
        } // end struct Mode


        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>case_sensitive</term>
        ///         <description>If 'false' then string filtering will ignore
        /// case. Does not apply to 'search' mode. Values: true, false.
        /// </description>
        ///     </item>
        /// </list>
        /// <br />
        /// A set of string constants for the parameter <member name="options"
        /// />.</summary>
        public struct Options
        {

            /// <summary>If 'false' then string filtering will ignore case.
            /// Does not apply to 'search' mode. Values: true, false.
            /// </summary>
            public const string CASE_SENSITIVE = "case_sensitive";
            public const string TRUE = "true";
            public const string FALSE = "false";
        } // end struct Options


        /// <summary>Name of the table on which the filter operation will be
        /// performed.  Must be an existing table, collection or view.
        /// </summary>
        public string table_name { get; set; }

        /// <summary>If provided, then this will be the name of the view
        /// containing the results. Has the same naming restrictions as <a
        /// href="../../../../concepts/tables.html" target="_top">tables</a>.
        /// </summary>
        public string view_name { get; set; } = "";

        /// <summary>The expression with which to filter the table.  </summary>
        public string expression { get; set; }

        /// <summary>The string filtering mode to apply. See above for details.
        /// Values: search, equals, contains, starts_with, regex.
        ///   </summary>
        public string mode { get; set; }

        /// <summary>List of columns on which to apply the filter. Ignored for
        /// 'search' mode.  </summary>
        public IList<string> column_names { get; set; } = new List<string>();

        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>case_sensitive</term>
        ///         <description>If 'false' then string filtering will ignore
        /// case. Does not apply to 'search' mode. Values: true, false.
        /// </description>
        ///     </item>
        /// </list>
        ///   </summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs a FilterByStringRequest object with default
        /// parameters.</summary>
        public FilterByStringRequest() { }

        /// <summary>Constructs a FilterByStringRequest object with the
        /// specified parameters.</summary>
        /// 
        /// <param name="table_name">Name of the table on which the filter
        /// operation will be performed.  Must be an existing table, collection
        /// or view.  </param>
        /// <param name="view_name">If provided, then this will be the name of
        /// the view containing the results. Has the same naming restrictions
        /// as <a href="../../../../concepts/tables.html"
        /// target="_top">tables</a>.  </param>
        /// <param name="expression">The expression with which to filter the
        /// table.  </param>
        /// <param name="mode">The string filtering mode to apply. See above
        /// for details. Values: search, equals, contains, starts_with, regex.
        ///   </param>
        /// <param name="column_names">List of columns on which to apply the
        /// filter. Ignored for 'search' mode.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term>case_sensitive</term>
        ///         <description>If 'false' then string filtering will ignore
        /// case. Does not apply to 'search' mode. Values: true, false.
        /// </description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        public FilterByStringRequest( string table_name,
                                      string view_name,
                                      string expression,
                                      string mode,
                                      IList<string> column_names,
                                      IDictionary<string, string> options = null)
        {
            this.table_name = table_name ?? "";
            this.view_name = view_name ?? "";
            this.expression = expression ?? "";
            this.mode = mode ?? "";
            this.column_names = column_names ?? new List<string>();
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor

    } // end class FilterByStringRequest



    /// <summary>A set of results returned by /filter/bystring.</summary>
    public class FilterByStringResponse : KineticaData
    {

        /// <summary>The number of records that passed the string filter.
        /// </summary>
        public long count { get; set; }

    } // end class FilterByStringResponse




}  // end namespace kinetica
