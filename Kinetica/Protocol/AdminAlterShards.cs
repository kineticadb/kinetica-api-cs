/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

using System.Collections.Generic;



namespace kinetica
{

    /// <summary>A set of parameters for <see
    /// cref="Kinetica.adminAlterShards(long,bool,IList{int},IList{int},IList{int},IList{int},IList{IList{int}},IDictionary{string, string})"
    /// />.
    /// <br />
    /// Specify the mapping of the shards to the various ranks in the cluster.
    /// In most cases, it should be sufficient to let the system automatically
    /// distribute the shards evenly across the available ranks. However, this
    /// endpoint can be used to move shards for various administrative reasons,
    /// say in case of heterogeneous node clusters.  It should be noted that
    /// the system may reassign the shards the when the number of nodes in the
    /// cluster changes or the cluster is rebalanced.</summary>
    public class AdminAlterShardsRequest : KineticaData
    {
        public long version { get; set; }

        /// <summary>Set to true when only the shards being moved are specified
        /// in the request.  The index must indicate the shards being moved.
        /// </summary>
        public bool use_index { get; set; }

        /// <summary>node to which the shard will be moved.  </summary>
        public IList<int> rank { get; set; } = new List<int>();

        /// <summary>Toms to which the shard will be moved.   </summary>
        public IList<int> tom { get; set; } = new List<int>();

        /// <summary>the shard which is being moved.  When use_index is set to
        /// true, size of this array must equal the size of rank/tom array.
        /// </summary>
        public IList<int> index { get; set; } = new List<int>();

        /// <summary>List of rank_tom integers, for which backup toms are
        /// defined  </summary>
        public IList<int> backup_map_list { get; set; } = new List<int>();

        /// <summary>List of the backup rank_tom(s) for each rank_tom in
        /// backup_map_list  </summary>
        public IList<IList<int>> backup_map_values { get; set; } = new List<IList<int>>();

        /// <summary>Optional parameters.  </summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs an AdminAlterShardsRequest object with default
        /// parameters.</summary>
        public AdminAlterShardsRequest() { }

        /// <summary>Constructs an AdminAlterShardsRequest object with the
        /// specified parameters.</summary>
        /// 
        /// <param name="version"></param>
        /// <param name="use_index">Set to true when only the shards being
        /// moved are specified in the request.  The index must indicate the
        /// shards being moved.  </param>
        /// <param name="rank">node to which the shard will be moved.  </param>
        /// <param name="tom">Toms to which the shard will be moved.   </param>
        /// <param name="index">the shard which is being moved.  When use_index
        /// is set to true, size of this array must equal the size of rank/tom
        /// array.  </param>
        /// <param name="backup_map_list">List of rank_tom integers, for which
        /// backup toms are defined  </param>
        /// <param name="backup_map_values">List of the backup rank_tom(s) for
        /// each rank_tom in backup_map_list  </param>
        /// <param name="options">Optional parameters.  </param>
        /// 
        public AdminAlterShardsRequest( long version,
                                        bool use_index,
                                        IList<int> rank,
                                        IList<int> tom,
                                        IList<int> index,
                                        IList<int> backup_map_list,
                                        IList<IList<int>> backup_map_values,
                                        IDictionary<string, string> options = null)
        {
            this.version = version;
            this.use_index = use_index;
            this.rank = rank ?? new List<int>();
            this.tom = tom ?? new List<int>();
            this.index = index ?? new List<int>();
            this.backup_map_list = backup_map_list ?? new List<int>();
            this.backup_map_values = backup_map_values ?? new List<IList<int>>();
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor

    } // end class AdminAlterShardsRequest



    /// <summary>A set of results returned by <see
    /// cref="Kinetica.adminAlterShards(long,bool,IList{int},IList{int},IList{int},IList{int},IList{IList{int}},IDictionary{string, string})"
    /// />.</summary>
    public class AdminAlterShardsResponse : KineticaData
    {
        public long version { get; set; }

    } // end class AdminAlterShardsResponse




}  // end namespace kinetica
