/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

using System.Collections.Generic;



namespace kinetica
{

    /// <summary>A set of parameters for <see
    /// cref="Kinetica.solveGraph(string,IList{string},IList{string},string,IList{string},IList{string},string,IDictionary{string, string})"
    /// />.
    /// <br />
    /// Solves an existing graph for a type of problem (e.g., shortest path,
    /// page rank, travelling salesman, etc.) using source nodes, destination
    /// nodes, and
    /// additional, optional weights and restrictions.
    /// <br />
    /// IMPORTANT: It's highly recommended that you review the
    /// <a href="../../graph_solver/network_graph_solver.html"
    /// target="_top">Network Graphs & Solvers</a>
    /// concepts documentation, the
    /// <a href="../../graph_solver/examples/graph_rest_guide.html"
    /// target="_top">Graph REST Tutorial</a>,
    /// and/or some
    /// <a href="../../graph_solver/examples.html#match-graph"
    /// target="_top">/match/graph examples</a>
    /// before using this endpoint.</summary>
    public class SolveGraphRequest : KineticaData
    {

        /// <summary>The type of solver to use for the graph.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>:</term>
        ///         <description>Solves for the optimal (shortest) path based
        /// on weights and restrictions from one source to destinations nodes.
        /// Also known as the Dijkstra solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PAGE_RANK">PAGE_RANK</see>:</term>
        ///         <description>Solves for the probability of each destination
        /// node being visited based on the links of the graph topology.
        /// Weights are not required to use this solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PROBABILITY_RANK">PROBABILITY_RANK</see>:</term>
        ///         <description>Solves for the transitional probability
        /// (Hidden Markov) for each node based on the weights (probability
        /// assigned over given edges).</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.CENTRALITY">CENTRALITY</see>:</term>
        ///         <description>Solves for the degree of a node to depict how
        /// many pairs of individuals that would have to go through the node to
        /// reach one another in the minimum number of hops. Also known as
        /// betweenness.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.MULTIPLE_ROUTING">MULTIPLE_ROUTING</see>:</term>
        ///         <description>Solves for finding the minimum cost cumulative
        /// path for a round-trip starting from the given source and visiting
        /// each given destination node once then returning to the source. Also
        /// known as the travelling salesman problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.INVERSE_SHORTEST_PATH">INVERSE_SHORTEST_PATH</see>:</term>
        ///         <description>Solves for finding the optimal path cost for
        /// each destination node to route to the source node. Also known as
        /// inverse Dijkstra or the service man routing problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.BACKHAUL_ROUTING">BACKHAUL_ROUTING</see>:</term>
        ///         <description>Solves for optimal routes that connect remote
        /// asset nodes to the fixed (backbone) asset nodes.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.ALLPATHS">ALLPATHS</see>:</term>
        ///         <description>Solves for paths that would give costs between
        /// max and min solution radia - Make sure to limit by the
        /// 'max_solution_targets' option. Min cost shoudl be >= shortest_path
        /// cost.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>.
        /// A set of string constants for the parameter <see cref="solver_type"
        /// />.</summary>
        public struct SolverType
        {

            /// <summary>Solves for the optimal (shortest) path based on
            /// weights and restrictions from one source to destinations nodes.
            /// Also known as the Dijkstra solver.</summary>
            public const string SHORTEST_PATH = "SHORTEST_PATH";

            /// <summary>Solves for the probability of each destination node
            /// being visited based on the links of the graph topology. Weights
            /// are not required to use this solver.</summary>
            public const string PAGE_RANK = "PAGE_RANK";

            /// <summary>Solves for the transitional probability (Hidden
            /// Markov) for each node based on the weights (probability
            /// assigned over given edges).</summary>
            public const string PROBABILITY_RANK = "PROBABILITY_RANK";

            /// <summary>Solves for the degree of a node to depict how many
            /// pairs of individuals that would have to go through the node to
            /// reach one another in the minimum number of hops. Also known as
            /// betweenness.</summary>
            public const string CENTRALITY = "CENTRALITY";

            /// <summary>Solves for finding the minimum cost cumulative path
            /// for a round-trip starting from the given source and visiting
            /// each given destination node once then returning to the source.
            /// Also known as the travelling salesman problem.</summary>
            public const string MULTIPLE_ROUTING = "MULTIPLE_ROUTING";

            /// <summary>Solves for finding the optimal path cost for each
            /// destination node to route to the source node. Also known as
            /// inverse Dijkstra or the service man routing problem.</summary>
            public const string INVERSE_SHORTEST_PATH = "INVERSE_SHORTEST_PATH";

            /// <summary>Solves for optimal routes that connect remote asset
            /// nodes to the fixed (backbone) asset nodes.</summary>
            public const string BACKHAUL_ROUTING = "BACKHAUL_ROUTING";

            /// <summary>Solves for paths that would give costs between max and
            /// min solution radia - Make sure to limit by the
            /// 'max_solution_targets' option. Min cost shoudl be >=
            /// shortest_path cost.</summary>
            public const string ALLPATHS = "ALLPATHS";
        } // end struct SolverType


        /// <summary>Additional parameters
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_RADIUS">MAX_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
        /// solution cost radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MIN_SOLUTION_RADIUS">MIN_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Applicable only when
        /// <i>max_solution_radius</i> is set. Sets the minimum solution cost
        /// radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_TARGETS">MAX_SOLUTION_TARGETS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum number
        /// of solution targets, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs no more than n number of nodes sorted by ascending cost
        /// where n is equal to the setting value. If set to 0, the setting is
        /// ignored.  The default value is '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.EXPORT_SOLVE_RESULTS">EXPORT_SOLVE_RESULTS</see>:</term>
        ///         <description>Returns solution results inside the <member
        /// name="result_per_destination_node" /> array in the response if set
        /// to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.REMOVE_PREVIOUS_RESTRICTIONS">REMOVE_PREVIOUS_RESTRICTIONS</see>:</term>
        ///         <description>Ignore the restrictions applied to the graph
        /// during the creation stage and only use the restrictions specified
        /// in this request if set to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RESTRICTION_THRESHOLD_VALUE">RESTRICTION_THRESHOLD_VALUE</see>:</term>
        ///         <description>Value-based restriction comparison. Any node
        /// or edge with a RESTRICTIONS_VALUECOMPARED value greater than the
        /// <i>restriction_threshold_value</i> will not be included in the
        /// solution.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.UNIFORM_WEIGHTS">UNIFORM_WEIGHTS</see>:</term>
        ///         <description>When specified, assigns the given value to all
        /// the edges in the graph. Note that weights provided in <paramref
        /// cref="SolveGraphRequest.weights_on_edges" /> will override this
        /// value.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.LEFT_TURN_PENALTY">LEFT_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'left turn' if the 'add_turn' option parameter of
        /// the /create/graph was invoked at graph creation.  The default value
        /// is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RIGHT_TURN_PENALTY">RIGHT_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as' right turn' if the 'add_turn' option parameter
        /// of the /create/graph was invoked at graph creation.  The default
        /// value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.INTERSECTION_PENALTY">INTERSECTION_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'intersection' if the 'add_turn' option parameter
        /// of the /create/graph was invoked at graph creation.  The default
        /// value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.SHARP_TURN_PENALTY">SHARP_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'sharp turn' or 'u-turn' if the 'add_turn' option
        /// parameter of the /create/graph was invoked at graph creation.  The
        /// default value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.NUM_BEST_PATHS">NUM_BEST_PATHS</see>:</term>
        ///         <description>For <i>MULTIPLE_ROUTING</i> solvers only; sets
        /// the number of shortest paths computed from each node. This is the
        /// heuristic criterion. Default value of zero allows the number to be
        /// computed automatically by the solver. The user may want to override
        /// this parameter to speed-up the solver.  The default value is
        /// '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_NUM_COMBINATIONS">MAX_NUM_COMBINATIONS</see>:</term>
        ///         <description>For <i>MULTIPLE_ROUTING</i> solvers only; sets
        /// the cap on the combinatorial sequences generated. If the default
        /// value of two millions is overridden to a lesser value, it can
        /// potentially speed up the solver.  The default value is
        /// '2000000'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.ACCURATE_SNAPS">ACCURATE_SNAPS</see>:</term>
        ///         <description>Valid for single source destination pair
        /// solves if points are described in NODE_WKTPOINT identifier types:
        /// When true (default), it snaps to the nearest node of the graph;
        /// otherwise, it searches for the closest entity that could be an
        /// edge. For the latter case (false), the solver modifies the
        /// resulting cost with the weights proportional to the ratio of the
        /// snap location within the edge. This may be an over-kill when the
        /// performance is considered and the difference is well less than 1
        /// percent. In batch runs, since the performance is of utmost
        /// importance, the option is always considered 'false'.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.OUTPUT_EDGE_PATH">OUTPUT_EDGE_PATH</see>:</term>
        ///         <description>If true then concatenated edge ids will be
        /// added as the EDGE path column of the solution table for each source
        /// and target pair in shortest path solves.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.OUTPUT_WKT_PATH">OUTPUT_WKT_PATH</see>:</term>
        ///         <description>If true then concatenated wkt line segments
        /// will be added as the Wktroute column of the solution table for each
        /// source and target pair in shortest path solves.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</description>
        ///     </item>
        /// </list>
        /// The default value is an empty {@link Dictionary}.
        /// A set of string constants for the parameter <see cref="options"
        /// />.</summary>
        public struct Options
        {

            /// <summary>For <i>SHORTEST_PATH</i> and
            /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
            /// solution cost radius, which ignores the <see
            /// cref="destination_nodes" /> list and instead outputs the nodes
            /// within the radius sorted by ascending cost. If set to '0.0',
            /// the setting is ignored.  The default value is '0.0'.</summary>
            public const string MAX_SOLUTION_RADIUS = "max_solution_radius";

            /// <summary>For <i>SHORTEST_PATH</i> and
            /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Applicable only when
            /// <i>max_solution_radius</i> is set. Sets the minimum solution
            /// cost radius, which ignores the <see cref="destination_nodes" />
            /// list and instead outputs the nodes within the radius sorted by
            /// ascending cost. If set to '0.0', the setting is ignored.  The
            /// default value is '0.0'.</summary>
            public const string MIN_SOLUTION_RADIUS = "min_solution_radius";

            /// <summary>For <i>SHORTEST_PATH</i> and
            /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
            /// number of solution targets, which ignores the <see
            /// cref="destination_nodes" /> list and instead outputs no more
            /// than n number of nodes sorted by ascending cost where n is
            /// equal to the setting value. If set to 0, the setting is
            /// ignored.  The default value is '0'.</summary>
            public const string MAX_SOLUTION_TARGETS = "max_solution_targets";

            /// <summary>Returns solution results inside the <member
            /// name="result_per_destination_node" /> array in the response if
            /// set to <i>true</i>.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</summary>
            public const string EXPORT_SOLVE_RESULTS = "export_solve_results";
            public const string TRUE = "true";
            public const string FALSE = "false";

            /// <summary>Ignore the restrictions applied to the graph during
            /// the creation stage and only use the restrictions specified in
            /// this request if set to <i>true</i>.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</summary>
            public const string REMOVE_PREVIOUS_RESTRICTIONS = "remove_previous_restrictions";

            /// <summary>Value-based restriction comparison. Any node or edge
            /// with a RESTRICTIONS_VALUECOMPARED value greater than the
            /// <i>restriction_threshold_value</i> will not be included in the
            /// solution.</summary>
            public const string RESTRICTION_THRESHOLD_VALUE = "restriction_threshold_value";

            /// <summary>When specified, assigns the given value to all the
            /// edges in the graph. Note that weights provided in <see
            /// cref="weights_on_edges" /> will override this value.</summary>
            public const string UNIFORM_WEIGHTS = "uniform_weights";

            /// <summary>This will add an additonal weight over the edges
            /// labelled as 'left turn' if the 'add_turn' option parameter of
            /// the <see
            /// cref="Kinetica.createGraph(string,bool,IList{string},IList{string},IList{string},IList{string},IDictionary{string, string})"
            /// /> was invoked at graph creation.  The default value is
            /// '0.0'.</summary>
            public const string LEFT_TURN_PENALTY = "left_turn_penalty";

            /// <summary>This will add an additonal weight over the edges
            /// labelled as' right turn' if the 'add_turn' option parameter of
            /// the <see
            /// cref="Kinetica.createGraph(string,bool,IList{string},IList{string},IList{string},IList{string},IDictionary{string, string})"
            /// /> was invoked at graph creation.  The default value is
            /// '0.0'.</summary>
            public const string RIGHT_TURN_PENALTY = "right_turn_penalty";

            /// <summary>This will add an additonal weight over the edges
            /// labelled as 'intersection' if the 'add_turn' option parameter
            /// of the <see
            /// cref="Kinetica.createGraph(string,bool,IList{string},IList{string},IList{string},IList{string},IDictionary{string, string})"
            /// /> was invoked at graph creation.  The default value is
            /// '0.0'.</summary>
            public const string INTERSECTION_PENALTY = "intersection_penalty";

            /// <summary>This will add an additonal weight over the edges
            /// labelled as 'sharp turn' or 'u-turn' if the 'add_turn' option
            /// parameter of the <see
            /// cref="Kinetica.createGraph(string,bool,IList{string},IList{string},IList{string},IList{string},IDictionary{string, string})"
            /// /> was invoked at graph creation.  The default value is
            /// '0.0'.</summary>
            public const string SHARP_TURN_PENALTY = "sharp_turn_penalty";

            /// <summary>For <i>MULTIPLE_ROUTING</i> solvers only; sets the
            /// number of shortest paths computed from each node. This is the
            /// heuristic criterion. Default value of zero allows the number to
            /// be computed automatically by the solver. The user may want to
            /// override this parameter to speed-up the solver.  The default
            /// value is '0'.</summary>
            public const string NUM_BEST_PATHS = "num_best_paths";

            /// <summary>For <i>MULTIPLE_ROUTING</i> solvers only; sets the cap
            /// on the combinatorial sequences generated. If the default value
            /// of two millions is overridden to a lesser value, it can
            /// potentially speed up the solver.  The default value is
            /// '2000000'.</summary>
            public const string MAX_NUM_COMBINATIONS = "max_num_combinations";

            /// <summary>Valid for single source destination pair solves if
            /// points are described in NODE_WKTPOINT identifier types: When
            /// true (default), it snaps to the nearest node of the graph;
            /// otherwise, it searches for the closest entity that could be an
            /// edge. For the latter case (false), the solver modifies the
            /// resulting cost with the weights proportional to the ratio of
            /// the snap location within the edge. This may be an over-kill
            /// when the performance is considered and the difference is well
            /// less than 1 percent. In batch runs, since the performance is of
            /// utmost importance, the option is always considered 'false'.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</summary>
            public const string ACCURATE_SNAPS = "accurate_snaps";

            /// <summary>If true then concatenated edge ids will be added as
            /// the EDGE path column of the solution table for each source and
            /// target pair in shortest path solves.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</summary>
            public const string OUTPUT_EDGE_PATH = "output_edge_path";

            /// <summary>If true then concatenated wkt line segments will be
            /// added as the Wktroute column of the solution table for each
            /// source and target pair in shortest path solves.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</summary>
            public const string OUTPUT_WKT_PATH = "output_wkt_path";
        } // end struct Options


        /// <summary>Name of the graph resource to solve.  </summary>
        public string graph_name { get; set; }

        /// <summary>Additional weights to apply to the edges of an existing
        /// graph. Weights must be specified using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS WEIGHTS_EDGE_ID',
        /// expressions, e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or
        /// raw values, e.g., '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'. Any
        /// provided weights will be added (in the case of
        /// 'WEIGHTS_VALUESPECIFIED') to or multiplied with (in the case of
        /// 'WEIGHTS_FACTORSPECIFIED') the existing weight(s). If using raw
        /// values in an identifier combination, the number of values specified
        /// must match across the combination.  The default value is an empty
        /// {@link List}.</summary>
        public IList<string> weights_on_edges { get; set; } = new List<string>();

        /// <summary>Additional restrictions to apply to the nodes/edges of an
        /// existing graph. Restrictions must be specified using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS
        /// RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
        /// RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0, 0, 0, 1} AS
        /// RESTRICTIONS_ONOFFCOMPARED'. If using raw values in an identifier
        /// combination, the number of values specified must match across the
        /// combination. If <i>remove_previous_restrictions</i> is set to
        /// <i>true</i>, any provided restrictions will replace the existing
        /// restrictions. If <i>remove_previous_restrictions</i> is set to
        /// <i>false</i>, any provided restrictions will be added (in the case
        /// of 'RESTRICTIONS_VALUECOMPARED') to or replaced (in the case of
        /// 'RESTRICTIONS_ONOFFCOMPARED').  The default value is an empty
        /// {@link List}.</summary>
        public IList<string> restrictions { get; set; } = new List<string>();

        /// <summary>The type of solver to use for the graph.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>:</term>
        ///         <description>Solves for the optimal (shortest) path based
        /// on weights and restrictions from one source to destinations nodes.
        /// Also known as the Dijkstra solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PAGE_RANK">PAGE_RANK</see>:</term>
        ///         <description>Solves for the probability of each destination
        /// node being visited based on the links of the graph topology.
        /// Weights are not required to use this solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PROBABILITY_RANK">PROBABILITY_RANK</see>:</term>
        ///         <description>Solves for the transitional probability
        /// (Hidden Markov) for each node based on the weights (probability
        /// assigned over given edges).</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.CENTRALITY">CENTRALITY</see>:</term>
        ///         <description>Solves for the degree of a node to depict how
        /// many pairs of individuals that would have to go through the node to
        /// reach one another in the minimum number of hops. Also known as
        /// betweenness.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.MULTIPLE_ROUTING">MULTIPLE_ROUTING</see>:</term>
        ///         <description>Solves for finding the minimum cost cumulative
        /// path for a round-trip starting from the given source and visiting
        /// each given destination node once then returning to the source. Also
        /// known as the travelling salesman problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.INVERSE_SHORTEST_PATH">INVERSE_SHORTEST_PATH</see>:</term>
        ///         <description>Solves for finding the optimal path cost for
        /// each destination node to route to the source node. Also known as
        /// inverse Dijkstra or the service man routing problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.BACKHAUL_ROUTING">BACKHAUL_ROUTING</see>:</term>
        ///         <description>Solves for optimal routes that connect remote
        /// asset nodes to the fixed (backbone) asset nodes.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.ALLPATHS">ALLPATHS</see>:</term>
        ///         <description>Solves for paths that would give costs between
        /// max and min solution radia - Make sure to limit by the
        /// 'max_solution_targets' option. Min cost shoudl be >= shortest_path
        /// cost.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>.
        /// </summary>
        public string solver_type { get; set; } = SolverType.SHORTEST_PATH;

        /// <summary>It can be one of the nodal identifiers - e.g:
        /// 'NODE_WKTPOINT' for source nodes. For <i>BACKHAUL_ROUTING</i>, this
        /// list depicts the fixed assets.  The default value is an empty
        /// {@link List}.</summary>
        public IList<string> source_nodes { get; set; } = new List<string>();

        /// <summary>It can be one of the nodal identifiers - e.g:
        /// 'NODE_WKTPOINT' for destination (target) nodes. For
        /// <i>BACKHAUL_ROUTING</i>, this list depicts the remote assets.  The
        /// default value is an empty {@link List}.</summary>
        public IList<string> destination_nodes { get; set; } = new List<string>();

        /// <summary>Name of the table to store the solution, in
        /// [schema_name.]table_name format, using standard <a
        /// href="../../concepts/tables.html#table-name-resolution"
        /// target="_top">name resolution rules</a>.  The default value is
        /// 'graph_solutions'.</summary>
        public string solution_table { get; set; } = "graph_solutions";

        /// <summary>Additional parameters
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_RADIUS">MAX_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
        /// solution cost radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MIN_SOLUTION_RADIUS">MIN_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Applicable only when
        /// <i>max_solution_radius</i> is set. Sets the minimum solution cost
        /// radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_TARGETS">MAX_SOLUTION_TARGETS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum number
        /// of solution targets, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs no more than n number of nodes sorted by ascending cost
        /// where n is equal to the setting value. If set to 0, the setting is
        /// ignored.  The default value is '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.EXPORT_SOLVE_RESULTS">EXPORT_SOLVE_RESULTS</see>:</term>
        ///         <description>Returns solution results inside the <member
        /// name="result_per_destination_node" /> array in the response if set
        /// to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.REMOVE_PREVIOUS_RESTRICTIONS">REMOVE_PREVIOUS_RESTRICTIONS</see>:</term>
        ///         <description>Ignore the restrictions applied to the graph
        /// during the creation stage and only use the restrictions specified
        /// in this request if set to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RESTRICTION_THRESHOLD_VALUE">RESTRICTION_THRESHOLD_VALUE</see>:</term>
        ///         <description>Value-based restriction comparison. Any node
        /// or edge with a RESTRICTIONS_VALUECOMPARED value greater than the
        /// <i>restriction_threshold_value</i> will not be included in the
        /// solution.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.UNIFORM_WEIGHTS">UNIFORM_WEIGHTS</see>:</term>
        ///         <description>When specified, assigns the given value to all
        /// the edges in the graph. Note that weights provided in <paramref
        /// cref="SolveGraphRequest.weights_on_edges" /> will override this
        /// value.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.LEFT_TURN_PENALTY">LEFT_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'left turn' if the 'add_turn' option parameter of
        /// the /create/graph was invoked at graph creation.  The default value
        /// is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RIGHT_TURN_PENALTY">RIGHT_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as' right turn' if the 'add_turn' option parameter
        /// of the /create/graph was invoked at graph creation.  The default
        /// value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.INTERSECTION_PENALTY">INTERSECTION_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'intersection' if the 'add_turn' option parameter
        /// of the /create/graph was invoked at graph creation.  The default
        /// value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.SHARP_TURN_PENALTY">SHARP_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'sharp turn' or 'u-turn' if the 'add_turn' option
        /// parameter of the /create/graph was invoked at graph creation.  The
        /// default value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.NUM_BEST_PATHS">NUM_BEST_PATHS</see>:</term>
        ///         <description>For <i>MULTIPLE_ROUTING</i> solvers only; sets
        /// the number of shortest paths computed from each node. This is the
        /// heuristic criterion. Default value of zero allows the number to be
        /// computed automatically by the solver. The user may want to override
        /// this parameter to speed-up the solver.  The default value is
        /// '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_NUM_COMBINATIONS">MAX_NUM_COMBINATIONS</see>:</term>
        ///         <description>For <i>MULTIPLE_ROUTING</i> solvers only; sets
        /// the cap on the combinatorial sequences generated. If the default
        /// value of two millions is overridden to a lesser value, it can
        /// potentially speed up the solver.  The default value is
        /// '2000000'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.ACCURATE_SNAPS">ACCURATE_SNAPS</see>:</term>
        ///         <description>Valid for single source destination pair
        /// solves if points are described in NODE_WKTPOINT identifier types:
        /// When true (default), it snaps to the nearest node of the graph;
        /// otherwise, it searches for the closest entity that could be an
        /// edge. For the latter case (false), the solver modifies the
        /// resulting cost with the weights proportional to the ratio of the
        /// snap location within the edge. This may be an over-kill when the
        /// performance is considered and the difference is well less than 1
        /// percent. In batch runs, since the performance is of utmost
        /// importance, the option is always considered 'false'.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.OUTPUT_EDGE_PATH">OUTPUT_EDGE_PATH</see>:</term>
        ///         <description>If true then concatenated edge ids will be
        /// added as the EDGE path column of the solution table for each source
        /// and target pair in shortest path solves.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.OUTPUT_WKT_PATH">OUTPUT_WKT_PATH</see>:</term>
        ///         <description>If true then concatenated wkt line segments
        /// will be added as the Wktroute column of the solution table for each
        /// source and target pair in shortest path solves.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</description>
        ///     </item>
        /// </list>
        /// The default value is an empty {@link Dictionary}.</summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs a SolveGraphRequest object with default
        /// parameters.</summary>
        public SolveGraphRequest() { }

        /// <summary>Constructs a SolveGraphRequest object with the specified
        /// parameters.</summary>
        /// 
        /// <param name="graph_name">Name of the graph resource to solve.
        /// </param>
        /// <param name="weights_on_edges">Additional weights to apply to the
        /// edges of an existing graph. Weights must be specified using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS WEIGHTS_EDGE_ID',
        /// expressions, e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or
        /// raw values, e.g., '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'. Any
        /// provided weights will be added (in the case of
        /// 'WEIGHTS_VALUESPECIFIED') to or multiplied with (in the case of
        /// 'WEIGHTS_FACTORSPECIFIED') the existing weight(s). If using raw
        /// values in an identifier combination, the number of values specified
        /// must match across the combination.  The default value is an empty
        /// {@link List}.</param>
        /// <param name="restrictions">Additional restrictions to apply to the
        /// nodes/edges of an existing graph. Restrictions must be specified
        /// using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS
        /// RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
        /// RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0, 0, 0, 1} AS
        /// RESTRICTIONS_ONOFFCOMPARED'. If using raw values in an identifier
        /// combination, the number of values specified must match across the
        /// combination. If <i>remove_previous_restrictions</i> is set to
        /// <i>true</i>, any provided restrictions will replace the existing
        /// restrictions. If <i>remove_previous_restrictions</i> is set to
        /// <i>false</i>, any provided restrictions will be added (in the case
        /// of 'RESTRICTIONS_VALUECOMPARED') to or replaced (in the case of
        /// 'RESTRICTIONS_ONOFFCOMPARED').  The default value is an empty
        /// {@link List}.</param>
        /// <param name="solver_type">The type of solver to use for the graph.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>:</term>
        ///         <description>Solves for the optimal (shortest) path based
        /// on weights and restrictions from one source to destinations nodes.
        /// Also known as the Dijkstra solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PAGE_RANK">PAGE_RANK</see>:</term>
        ///         <description>Solves for the probability of each destination
        /// node being visited based on the links of the graph topology.
        /// Weights are not required to use this solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PROBABILITY_RANK">PROBABILITY_RANK</see>:</term>
        ///         <description>Solves for the transitional probability
        /// (Hidden Markov) for each node based on the weights (probability
        /// assigned over given edges).</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.CENTRALITY">CENTRALITY</see>:</term>
        ///         <description>Solves for the degree of a node to depict how
        /// many pairs of individuals that would have to go through the node to
        /// reach one another in the minimum number of hops. Also known as
        /// betweenness.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.MULTIPLE_ROUTING">MULTIPLE_ROUTING</see>:</term>
        ///         <description>Solves for finding the minimum cost cumulative
        /// path for a round-trip starting from the given source and visiting
        /// each given destination node once then returning to the source. Also
        /// known as the travelling salesman problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.INVERSE_SHORTEST_PATH">INVERSE_SHORTEST_PATH</see>:</term>
        ///         <description>Solves for finding the optimal path cost for
        /// each destination node to route to the source node. Also known as
        /// inverse Dijkstra or the service man routing problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.BACKHAUL_ROUTING">BACKHAUL_ROUTING</see>:</term>
        ///         <description>Solves for optimal routes that connect remote
        /// asset nodes to the fixed (backbone) asset nodes.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.ALLPATHS">ALLPATHS</see>:</term>
        ///         <description>Solves for paths that would give costs between
        /// max and min solution radia - Make sure to limit by the
        /// 'max_solution_targets' option. Min cost shoudl be >= shortest_path
        /// cost.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>.
        /// </param>
        /// <param name="source_nodes">It can be one of the nodal identifiers -
        /// e.g: 'NODE_WKTPOINT' for source nodes. For <i>BACKHAUL_ROUTING</i>,
        /// this list depicts the fixed assets.  The default value is an empty
        /// {@link List}.</param>
        /// <param name="destination_nodes">It can be one of the nodal
        /// identifiers - e.g: 'NODE_WKTPOINT' for destination (target) nodes.
        /// For <i>BACKHAUL_ROUTING</i>, this list depicts the remote assets.
        /// The default value is an empty {@link List}.</param>
        /// <param name="solution_table">Name of the table to store the
        /// solution, in [schema_name.]table_name format, using standard <a
        /// href="../../concepts/tables.html#table-name-resolution"
        /// target="_top">name resolution rules</a>.  The default value is
        /// 'graph_solutions'.</param>
        /// <param name="options">Additional parameters
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_RADIUS">MAX_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
        /// solution cost radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MIN_SOLUTION_RADIUS">MIN_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Applicable only when
        /// <i>max_solution_radius</i> is set. Sets the minimum solution cost
        /// radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_TARGETS">MAX_SOLUTION_TARGETS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum number
        /// of solution targets, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> list and instead
        /// outputs no more than n number of nodes sorted by ascending cost
        /// where n is equal to the setting value. If set to 0, the setting is
        /// ignored.  The default value is '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.EXPORT_SOLVE_RESULTS">EXPORT_SOLVE_RESULTS</see>:</term>
        ///         <description>Returns solution results inside the <member
        /// name="result_per_destination_node" /> array in the response if set
        /// to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.REMOVE_PREVIOUS_RESTRICTIONS">REMOVE_PREVIOUS_RESTRICTIONS</see>:</term>
        ///         <description>Ignore the restrictions applied to the graph
        /// during the creation stage and only use the restrictions specified
        /// in this request if set to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RESTRICTION_THRESHOLD_VALUE">RESTRICTION_THRESHOLD_VALUE</see>:</term>
        ///         <description>Value-based restriction comparison. Any node
        /// or edge with a RESTRICTIONS_VALUECOMPARED value greater than the
        /// <i>restriction_threshold_value</i> will not be included in the
        /// solution.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.UNIFORM_WEIGHTS">UNIFORM_WEIGHTS</see>:</term>
        ///         <description>When specified, assigns the given value to all
        /// the edges in the graph. Note that weights provided in <paramref
        /// cref="SolveGraphRequest.weights_on_edges" /> will override this
        /// value.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.LEFT_TURN_PENALTY">LEFT_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'left turn' if the 'add_turn' option parameter of
        /// the /create/graph was invoked at graph creation.  The default value
        /// is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RIGHT_TURN_PENALTY">RIGHT_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as' right turn' if the 'add_turn' option parameter
        /// of the /create/graph was invoked at graph creation.  The default
        /// value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.INTERSECTION_PENALTY">INTERSECTION_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'intersection' if the 'add_turn' option parameter
        /// of the /create/graph was invoked at graph creation.  The default
        /// value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.SHARP_TURN_PENALTY">SHARP_TURN_PENALTY</see>:</term>
        ///         <description>This will add an additonal weight over the
        /// edges labelled as 'sharp turn' or 'u-turn' if the 'add_turn' option
        /// parameter of the /create/graph was invoked at graph creation.  The
        /// default value is '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.NUM_BEST_PATHS">NUM_BEST_PATHS</see>:</term>
        ///         <description>For <i>MULTIPLE_ROUTING</i> solvers only; sets
        /// the number of shortest paths computed from each node. This is the
        /// heuristic criterion. Default value of zero allows the number to be
        /// computed automatically by the solver. The user may want to override
        /// this parameter to speed-up the solver.  The default value is
        /// '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_NUM_COMBINATIONS">MAX_NUM_COMBINATIONS</see>:</term>
        ///         <description>For <i>MULTIPLE_ROUTING</i> solvers only; sets
        /// the cap on the combinatorial sequences generated. If the default
        /// value of two millions is overridden to a lesser value, it can
        /// potentially speed up the solver.  The default value is
        /// '2000000'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.ACCURATE_SNAPS">ACCURATE_SNAPS</see>:</term>
        ///         <description>Valid for single source destination pair
        /// solves if points are described in NODE_WKTPOINT identifier types:
        /// When true (default), it snaps to the nearest node of the graph;
        /// otherwise, it searches for the closest entity that could be an
        /// edge. For the latter case (false), the solver modifies the
        /// resulting cost with the weights proportional to the ratio of the
        /// snap location within the edge. This may be an over-kill when the
        /// performance is considered and the difference is well less than 1
        /// percent. In batch runs, since the performance is of utmost
        /// importance, the option is always considered 'false'.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.OUTPUT_EDGE_PATH">OUTPUT_EDGE_PATH</see>:</term>
        ///         <description>If true then concatenated edge ids will be
        /// added as the EDGE path column of the solution table for each source
        /// and target pair in shortest path solves.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.OUTPUT_WKT_PATH">OUTPUT_WKT_PATH</see>:</term>
        ///         <description>If true then concatenated wkt line segments
        /// will be added as the Wktroute column of the solution table for each
        /// source and target pair in shortest path solves.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see>.</description>
        ///     </item>
        /// </list>
        /// The default value is an empty {@link Dictionary}.</param>
        /// 
        public SolveGraphRequest( string graph_name,
                                  IList<string> weights_on_edges = null,
                                  IList<string> restrictions = null,
                                  string solver_type = null,
                                  IList<string> source_nodes = null,
                                  IList<string> destination_nodes = null,
                                  string solution_table = null,
                                  IDictionary<string, string> options = null)
        {
            this.graph_name = graph_name ?? "";
            this.weights_on_edges = weights_on_edges ?? new List<string>();
            this.restrictions = restrictions ?? new List<string>();
            this.solver_type = solver_type ?? SolverType.SHORTEST_PATH;
            this.source_nodes = source_nodes ?? new List<string>();
            this.destination_nodes = destination_nodes ?? new List<string>();
            this.solution_table = solution_table ?? "graph_solutions";
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor

    } // end class SolveGraphRequest



    /// <summary>A set of results returned by <see
    /// cref="Kinetica.solveGraph(string,IList{string},IList{string},string,IList{string},IList{string},string,IDictionary{string, string})"
    /// />.</summary>
    public class SolveGraphResponse : KineticaData
    {

        /// <summary>Indicates a successful solution.  </summary>
        public bool result { get; set; }

        /// <summary>Cost or Pagerank (based on solver type) for each
        /// destination node requested. Only populated if
        /// <i>export_solve_results</i> is set to <i>true</i>.  </summary>
        public IList<float> result_per_destination_node { get; set; } = new List<float>();

        /// <summary>Additional information.  </summary>
        public IDictionary<string, string> info { get; set; } = new Dictionary<string, string>();

    } // end class SolveGraphResponse




}  // end namespace kinetica
