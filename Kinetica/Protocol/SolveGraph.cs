/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

using System.Collections.Generic;



namespace kinetica
{

    /// <summary>A set of parameters for <see
    /// cref="Kinetica.solveGraph(string,IList{string},IList{string},string,long,IList{long},string,string,IList{string},string,IDictionary{string, string})"
    /// />.
    /// <br />
    /// Solves an existing graph for a type of problem (e.g., shortest path,
    /// page rank, travelling salesman, etc.) using source nodes, destination
    /// nodes, and additional, optional weights and restrictions. See <a
    /// href="../../graph_solver/network_graph_solver.html"
    /// target="_top">Network Graph Solvers</a> for more information.</summary>
    public class SolveGraphRequest : KineticaData
    {

        /// <summary>The type of solver to use for the graph.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>:</term>
        ///         <description>Solves for the optimal (shortest) path based
        /// on weights and restrictions from one source to destinations nodes.
        /// Also known as the Dijkstra solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PAGE_RANK">PAGE_RANK</see>:</term>
        ///         <description>Solves for the probability of each destination
        /// node being visited based on the links of the graph
        /// topology.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.CENTRALITY">CENTRALITY</see>:</term>
        ///         <description>Solves for the degree of a node to depict how
        /// many pairs of individuals that would have to go through the node to
        /// reach one another in the minimum number of hops. Also known as
        /// betweenness.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.MULTIPLE_ROUTING">MULTIPLE_ROUTING</see>:</term>
        ///         <description>Solves for finding the minimum cost cumulative
        /// path for a round-trip starting from the given source and visiting
        /// each given destination node once then returning to the source. Also
        /// known as the travelling salesman problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.INVERSE_SHORTEST_PATH">INVERSE_SHORTEST_PATH</see>:</term>
        ///         <description>Solves for finding the optimal path cost for
        /// each destination node to route to the source node. Also known as
        /// inverse Dijkstra or the service man routing problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.BACKHAUL_ROUTING">BACKHAUL_ROUTING</see>:</term>
        ///         <description>Solves for optimal routes that connect remote
        /// asset nodes to the fixed (backbone) asset nodes. When
        /// <i>BACKHAUL_ROUTING</i> is invoked, the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> or <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> array is used for
        /// both fixed and remote asset nodes and the <paramref
        /// cref="SolveGraphRequest.source_node_id" /> represents the number of
        /// fixed asset nodes contained in <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> / <paramref
        /// cref="SolveGraphRequest.destination_node_ids" />.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>.
        /// A set of string constants for the parameter <see cref="solver_type"
        /// />.</summary>
        public struct SolverType
        {

            /// <summary>Solves for the optimal (shortest) path based on
            /// weights and restrictions from one source to destinations nodes.
            /// Also known as the Dijkstra solver.</summary>
            public const string SHORTEST_PATH = "SHORTEST_PATH";

            /// <summary>Solves for the probability of each destination node
            /// being visited based on the links of the graph
            /// topology.</summary>
            public const string PAGE_RANK = "PAGE_RANK";

            /// <summary>Solves for the degree of a node to depict how many
            /// pairs of individuals that would have to go through the node to
            /// reach one another in the minimum number of hops. Also known as
            /// betweenness.</summary>
            public const string CENTRALITY = "CENTRALITY";

            /// <summary>Solves for finding the minimum cost cumulative path
            /// for a round-trip starting from the given source and visiting
            /// each given destination node once then returning to the source.
            /// Also known as the travelling salesman problem.</summary>
            public const string MULTIPLE_ROUTING = "MULTIPLE_ROUTING";

            /// <summary>Solves for finding the optimal path cost for each
            /// destination node to route to the source node. Also known as
            /// inverse Dijkstra or the service man routing problem.</summary>
            public const string INVERSE_SHORTEST_PATH = "INVERSE_SHORTEST_PATH";

            /// <summary>Solves for optimal routes that connect remote asset
            /// nodes to the fixed (backbone) asset nodes. When
            /// <i>BACKHAUL_ROUTING</i> is invoked, the <see
            /// cref="destination_nodes" /> or <see cref="destination_node_ids"
            /// /> array is used for both fixed and remote asset nodes and the
            /// <see cref="source_node_id" /> represents the number of fixed
            /// asset nodes contained in <see cref="destination_nodes" /> /
            /// <see cref="destination_node_ids" />.</summary>
            public const string BACKHAUL_ROUTING = "BACKHAUL_ROUTING";
        } // end struct SolverType


        /// <summary>Source and destination node identifier type.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_ID">NODE_ID</see>:</term>
        ///         <description>The graph's nodes were identified as integers,
        /// e.g., 1234.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_WKTPOINT">NODE_WKTPOINT</see>:</term>
        ///         <description>The graph's nodes were identified as
        /// geospatial coordinates, e.g., 'POINT(1.0 2.0)'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_NAME">NODE_NAME</see>:</term>
        ///         <description>The graph's nodes were identified as strings,
        /// e.g., 'Arlington'.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.NodeType.NODE_ID">NODE_ID</see>.
        /// A set of string constants for the parameter <see cref="node_type"
        /// />.</summary>
        public struct NodeType
        {

            /// <summary>The graph's nodes were identified as integers, e.g.,
            /// 1234.</summary>
            public const string NODE_ID = "NODE_ID";

            /// <summary>The graph's nodes were identified as geospatial
            /// coordinates, e.g., 'POINT(1.0 2.0)'.</summary>
            public const string NODE_WKTPOINT = "NODE_WKTPOINT";

            /// <summary>The graph's nodes were identified as strings, e.g.,
            /// 'Arlington'.</summary>
            public const string NODE_NAME = "NODE_NAME";
        } // end struct NodeType


        /// <summary>Additional parameters
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_RADIUS">MAX_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
        /// solution cost radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_TARGETS">MAX_SOLUTION_TARGETS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum number
        /// of solution targets, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> list and instead
        /// outputs no more than n number of nodes sorted by ascending cost
        /// where n is equal to the setting value. If set to 0, the setting is
        /// ignored.  The default value is '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.EXPORT_SOLVE_RESULTS">EXPORT_SOLVE_RESULTS</see>:</term>
        ///         <description>Returns solution results inside the <member
        /// name="result_per_destination_node" /> array in the response if set
        /// to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.REMOVE_PREVIOUS_RESTRICTIONS">REMOVE_PREVIOUS_RESTRICTIONS</see>:</term>
        ///         <description>Ignore the restrictions applied to the graph
        /// during the creation stage and only use the restrictions specified
        /// in this request if set to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RESTRICTION_THRESHOLD_VALUE">RESTRICTION_THRESHOLD_VALUE</see>:</term>
        ///         <description>Value-based restriction comparison. Any node
        /// or edge with a RESTRICTIONS_VALUECOMPARED value greater than the
        /// <i>restriction_threshold_value</i> will not be included in the
        /// solution.</description>
        ///     </item>
        /// </list>
        /// The default value is an empty {@link Dictionary}.
        /// A set of string constants for the parameter <see cref="options"
        /// />.</summary>
        public struct Options
        {

            /// <summary>For <i>SHORTEST_PATH</i> and
            /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
            /// solution cost radius, which ignores the <see
            /// cref="destination_node_ids" /> list and instead outputs the
            /// nodes within the radius sorted by ascending cost. If set to
            /// '0.0', the setting is ignored.  The default value is
            /// '0.0'.</summary>
            public const string MAX_SOLUTION_RADIUS = "max_solution_radius";

            /// <summary>For <i>SHORTEST_PATH</i> and
            /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
            /// number of solution targets, which ignores the <see
            /// cref="destination_node_ids" /> list and instead outputs no more
            /// than n number of nodes sorted by ascending cost where n is
            /// equal to the setting value. If set to 0, the setting is
            /// ignored.  The default value is '0'.</summary>
            public const string MAX_SOLUTION_TARGETS = "max_solution_targets";

            /// <summary>Returns solution results inside the <member
            /// name="result_per_destination_node" /> array in the response if
            /// set to <i>true</i>.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</summary>
            public const string EXPORT_SOLVE_RESULTS = "export_solve_results";
            public const string TRUE = "true";
            public const string FALSE = "false";

            /// <summary>Ignore the restrictions applied to the graph during
            /// the creation stage and only use the restrictions specified in
            /// this request if set to <i>true</i>.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</summary>
            public const string REMOVE_PREVIOUS_RESTRICTIONS = "remove_previous_restrictions";

            /// <summary>Value-based restriction comparison. Any node or edge
            /// with a RESTRICTIONS_VALUECOMPARED value greater than the
            /// <i>restriction_threshold_value</i> will not be included in the
            /// solution.</summary>
            public const string RESTRICTION_THRESHOLD_VALUE = "restriction_threshold_value";
        } // end struct Options


        /// <summary>Name of the graph resource to solve.  </summary>
        public string graph_name { get; set; }

        /// <summary>Additional weights to apply to the edges of an existing
        /// graph. Weights must be specified using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS WEIGHTS_EDGE_ID', or
        /// expressions, e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED'. Any
        /// provided weights will be added (in the case of
        /// 'WEIGHTS_VALUESPECIFIED') to or multiplied with (in the case of
        /// 'WEIGHTS_FACTORSPECIFIED') the existing weight(s).  The default
        /// value is an empty {@link List}.</summary>
        public IList<string> weights_on_edges { get; set; } = new List<string>();

        /// <summary>Additional restrictions to apply to the nodes/edges of an
        /// existing graph. Restrictions must be specified using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS
        /// RESTRICTIONS_EDGE_ID', or expressions, e.g., 'column/2 AS
        /// RESTRICTIONS_VALUECOMPARED'. If <i>remove_previous_restrictions</i>
        /// is set to <i>true</i>, any provided restrictions will replace the
        /// existing restrictions. If <i>remove_previous_restrictions</i> is
        /// set to <i>false</i>, any provided weights will be added (in the
        /// case of 'RESTRICTIONS_VALUECOMPARED') to or replaced (in the case
        /// of 'RESTRICTIONS_ONOFFCOMPARED').  The default value is an empty
        /// {@link List}.</summary>
        public IList<string> restrictions { get; set; } = new List<string>();

        /// <summary>The type of solver to use for the graph.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>:</term>
        ///         <description>Solves for the optimal (shortest) path based
        /// on weights and restrictions from one source to destinations nodes.
        /// Also known as the Dijkstra solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PAGE_RANK">PAGE_RANK</see>:</term>
        ///         <description>Solves for the probability of each destination
        /// node being visited based on the links of the graph
        /// topology.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.CENTRALITY">CENTRALITY</see>:</term>
        ///         <description>Solves for the degree of a node to depict how
        /// many pairs of individuals that would have to go through the node to
        /// reach one another in the minimum number of hops. Also known as
        /// betweenness.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.MULTIPLE_ROUTING">MULTIPLE_ROUTING</see>:</term>
        ///         <description>Solves for finding the minimum cost cumulative
        /// path for a round-trip starting from the given source and visiting
        /// each given destination node once then returning to the source. Also
        /// known as the travelling salesman problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.INVERSE_SHORTEST_PATH">INVERSE_SHORTEST_PATH</see>:</term>
        ///         <description>Solves for finding the optimal path cost for
        /// each destination node to route to the source node. Also known as
        /// inverse Dijkstra or the service man routing problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.BACKHAUL_ROUTING">BACKHAUL_ROUTING</see>:</term>
        ///         <description>Solves for optimal routes that connect remote
        /// asset nodes to the fixed (backbone) asset nodes. When
        /// <i>BACKHAUL_ROUTING</i> is invoked, the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> or <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> array is used for
        /// both fixed and remote asset nodes and the <paramref
        /// cref="SolveGraphRequest.source_node_id" /> represents the number of
        /// fixed asset nodes contained in <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> / <paramref
        /// cref="SolveGraphRequest.destination_node_ids" />.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>.
        /// </summary>
        public string solver_type { get; set; } = SolverType.SHORTEST_PATH;

        /// <summary>If <paramref cref="SolveGraphRequest.node_type" /> is
        /// <i>NODE_ID</i>, the node ID (integer) of the source (starting
        /// point) for the graph solution. If the <paramref
        /// cref="SolveGraphRequest.solver_type" /> is set to
        /// <i>BACKHAUL_ROUTING</i>, this number represents the number of fixed
        /// asset nodes contained in <paramref
        /// cref="SolveGraphRequest.destination_nodes" />, e.g., if <paramref
        /// cref="SolveGraphRequest.source_node_id" /> is set to 24, the first
        /// 24 nodes listed in <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> / <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> are the fixed
        /// asset nodes and the rest of the nodes in the array are remote
        /// assets.  </summary>
        public long source_node_id { get; set; }

        /// <summary>List of destination node indices, or indices for
        /// pageranks. If the <paramref cref="SolveGraphRequest.solver_type" />
        /// is set to <i>BACKHAUL_ROUTING</i>, it is the list of all fixed and
        /// remote asset nodes.  The default value is an empty {@link
        /// List}.</summary>
        public IList<long> destination_node_ids { get; set; } = new List<long>();

        /// <summary>Source and destination node identifier type.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_ID">NODE_ID</see>:</term>
        ///         <description>The graph's nodes were identified as integers,
        /// e.g., 1234.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_WKTPOINT">NODE_WKTPOINT</see>:</term>
        ///         <description>The graph's nodes were identified as
        /// geospatial coordinates, e.g., 'POINT(1.0 2.0)'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_NAME">NODE_NAME</see>:</term>
        ///         <description>The graph's nodes were identified as strings,
        /// e.g., 'Arlington'.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.NodeType.NODE_ID">NODE_ID</see>.
        /// </summary>
        public string node_type { get; set; } = NodeType.NODE_ID;

        /// <summary>If <paramref cref="SolveGraphRequest.node_type" /> is
        /// <i>NODE_WKTPOINT</i> or <i>NODE_NAME</i>, the node (string) of the
        /// source (starting point) for the graph solution.  The default value
        /// is ''.</summary>
        public string source_node { get; set; } = "";

        /// <summary>If <paramref cref="SolveGraphRequest.node_type" /> is
        /// <i>NODE_WKTPOINT</i> or <i>NODE_NAME</i>, the list of destination
        /// node or page rank indices (strings) for the graph solution. If the
        /// <paramref cref="SolveGraphRequest.solver_type" /> is set to
        /// <i>BACKHAUL_ROUTING</i>, it is the list of all fixed and remote
        /// asset nodes. The string type should be consistent with the
        /// <paramref cref="SolveGraphRequest.node_type" /> parameter.  The
        /// default value is an empty {@link List}.</summary>
        public IList<string> destination_nodes { get; set; } = new List<string>();

        /// <summary>Name of the table to store the solution.  The default
        /// value is 'graph_solutions'.</summary>
        public string solution_table { get; set; } = "graph_solutions";

        /// <summary>Additional parameters
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_RADIUS">MAX_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
        /// solution cost radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_TARGETS">MAX_SOLUTION_TARGETS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum number
        /// of solution targets, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> list and instead
        /// outputs no more than n number of nodes sorted by ascending cost
        /// where n is equal to the setting value. If set to 0, the setting is
        /// ignored.  The default value is '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.EXPORT_SOLVE_RESULTS">EXPORT_SOLVE_RESULTS</see>:</term>
        ///         <description>Returns solution results inside the <member
        /// name="result_per_destination_node" /> array in the response if set
        /// to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.REMOVE_PREVIOUS_RESTRICTIONS">REMOVE_PREVIOUS_RESTRICTIONS</see>:</term>
        ///         <description>Ignore the restrictions applied to the graph
        /// during the creation stage and only use the restrictions specified
        /// in this request if set to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RESTRICTION_THRESHOLD_VALUE">RESTRICTION_THRESHOLD_VALUE</see>:</term>
        ///         <description>Value-based restriction comparison. Any node
        /// or edge with a RESTRICTIONS_VALUECOMPARED value greater than the
        /// <i>restriction_threshold_value</i> will not be included in the
        /// solution.</description>
        ///     </item>
        /// </list>
        /// The default value is an empty {@link Dictionary}.</summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs a SolveGraphRequest object with default
        /// parameters.</summary>
        public SolveGraphRequest() { }

        /// <summary>Constructs a SolveGraphRequest object with the specified
        /// parameters.</summary>
        /// 
        /// <param name="graph_name">Name of the graph resource to solve.
        /// </param>
        /// <param name="weights_on_edges">Additional weights to apply to the
        /// edges of an existing graph. Weights must be specified using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS WEIGHTS_EDGE_ID', or
        /// expressions, e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED'. Any
        /// provided weights will be added (in the case of
        /// 'WEIGHTS_VALUESPECIFIED') to or multiplied with (in the case of
        /// 'WEIGHTS_FACTORSPECIFIED') the existing weight(s).  The default
        /// value is an empty {@link List}.</param>
        /// <param name="restrictions">Additional restrictions to apply to the
        /// nodes/edges of an existing graph. Restrictions must be specified
        /// using <a
        /// href="../../graph_solver/network_graph_solver.html#identifiers"
        /// target="_top">identifiers</a>; identifiers are grouped as <a
        /// href="../../graph_solver/network_graph_solver.html#id-combos"
        /// target="_top">combinations</a>. Identifiers can be used with
        /// existing column names, e.g., 'table.column AS
        /// RESTRICTIONS_EDGE_ID', or expressions, e.g., 'column/2 AS
        /// RESTRICTIONS_VALUECOMPARED'. If <i>remove_previous_restrictions</i>
        /// is set to <i>true</i>, any provided restrictions will replace the
        /// existing restrictions. If <i>remove_previous_restrictions</i> is
        /// set to <i>false</i>, any provided weights will be added (in the
        /// case of 'RESTRICTIONS_VALUECOMPARED') to or replaced (in the case
        /// of 'RESTRICTIONS_ONOFFCOMPARED').  The default value is an empty
        /// {@link List}.</param>
        /// <param name="solver_type">The type of solver to use for the graph.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>:</term>
        ///         <description>Solves for the optimal (shortest) path based
        /// on weights and restrictions from one source to destinations nodes.
        /// Also known as the Dijkstra solver.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.PAGE_RANK">PAGE_RANK</see>:</term>
        ///         <description>Solves for the probability of each destination
        /// node being visited based on the links of the graph
        /// topology.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.CENTRALITY">CENTRALITY</see>:</term>
        ///         <description>Solves for the degree of a node to depict how
        /// many pairs of individuals that would have to go through the node to
        /// reach one another in the minimum number of hops. Also known as
        /// betweenness.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.MULTIPLE_ROUTING">MULTIPLE_ROUTING</see>:</term>
        ///         <description>Solves for finding the minimum cost cumulative
        /// path for a round-trip starting from the given source and visiting
        /// each given destination node once then returning to the source. Also
        /// known as the travelling salesman problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.INVERSE_SHORTEST_PATH">INVERSE_SHORTEST_PATH</see>:</term>
        ///         <description>Solves for finding the optimal path cost for
        /// each destination node to route to the source node. Also known as
        /// inverse Dijkstra or the service man routing problem.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.SolverType.BACKHAUL_ROUTING">BACKHAUL_ROUTING</see>:</term>
        ///         <description>Solves for optimal routes that connect remote
        /// asset nodes to the fixed (backbone) asset nodes. When
        /// <i>BACKHAUL_ROUTING</i> is invoked, the <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> or <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> array is used for
        /// both fixed and remote asset nodes and the <paramref
        /// cref="SolveGraphRequest.source_node_id" /> represents the number of
        /// fixed asset nodes contained in <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> / <paramref
        /// cref="SolveGraphRequest.destination_node_ids" />.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.SolverType.SHORTEST_PATH">SHORTEST_PATH</see>.
        /// </param>
        /// <param name="source_node_id">If <paramref
        /// cref="SolveGraphRequest.node_type" /> is <i>NODE_ID</i>, the node
        /// ID (integer) of the source (starting point) for the graph solution.
        /// If the <paramref cref="SolveGraphRequest.solver_type" /> is set to
        /// <i>BACKHAUL_ROUTING</i>, this number represents the number of fixed
        /// asset nodes contained in <paramref
        /// cref="SolveGraphRequest.destination_nodes" />, e.g., if <paramref
        /// cref="SolveGraphRequest.source_node_id" /> is set to 24, the first
        /// 24 nodes listed in <paramref
        /// cref="SolveGraphRequest.destination_nodes" /> / <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> are the fixed
        /// asset nodes and the rest of the nodes in the array are remote
        /// assets.  </param>
        /// <param name="destination_node_ids">List of destination node
        /// indices, or indices for pageranks. If the <paramref
        /// cref="SolveGraphRequest.solver_type" /> is set to
        /// <i>BACKHAUL_ROUTING</i>, it is the list of all fixed and remote
        /// asset nodes.  The default value is an empty {@link List}.</param>
        /// <param name="node_type">Source and destination node identifier
        /// type.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_ID">NODE_ID</see>:</term>
        ///         <description>The graph's nodes were identified as integers,
        /// e.g., 1234.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_WKTPOINT">NODE_WKTPOINT</see>:</term>
        ///         <description>The graph's nodes were identified as
        /// geospatial coordinates, e.g., 'POINT(1.0 2.0)'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.NodeType.NODE_NAME">NODE_NAME</see>:</term>
        ///         <description>The graph's nodes were identified as strings,
        /// e.g., 'Arlington'.</description>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.NodeType.NODE_ID">NODE_ID</see>.  </param>
        /// <param name="source_node">If <paramref
        /// cref="SolveGraphRequest.node_type" /> is <i>NODE_WKTPOINT</i> or
        /// <i>NODE_NAME</i>, the node (string) of the source (starting point)
        /// for the graph solution.  The default value is ''.</param>
        /// <param name="destination_nodes">If <paramref
        /// cref="SolveGraphRequest.node_type" /> is <i>NODE_WKTPOINT</i> or
        /// <i>NODE_NAME</i>, the list of destination node or page rank indices
        /// (strings) for the graph solution. If the <paramref
        /// cref="SolveGraphRequest.solver_type" /> is set to
        /// <i>BACKHAUL_ROUTING</i>, it is the list of all fixed and remote
        /// asset nodes. The string type should be consistent with the
        /// <paramref cref="SolveGraphRequest.node_type" /> parameter.  The
        /// default value is an empty {@link List}.</param>
        /// <param name="solution_table">Name of the table to store the
        /// solution.  The default value is 'graph_solutions'.</param>
        /// <param name="options">Additional parameters
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_RADIUS">MAX_SOLUTION_RADIUS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum
        /// solution cost radius, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> list and instead
        /// outputs the nodes within the radius sorted by ascending cost. If
        /// set to '0.0', the setting is ignored.  The default value is
        /// '0.0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.MAX_SOLUTION_TARGETS">MAX_SOLUTION_TARGETS</see>:</term>
        ///         <description>For <i>SHORTEST_PATH</i> and
        /// <i>INVERSE_SHORTEST_PATH</i> solvers only. Sets the maximum number
        /// of solution targets, which ignores the <paramref
        /// cref="SolveGraphRequest.destination_node_ids" /> list and instead
        /// outputs no more than n number of nodes sorted by ascending cost
        /// where n is equal to the setting value. If set to 0, the setting is
        /// ignored.  The default value is '0'.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.EXPORT_SOLVE_RESULTS">EXPORT_SOLVE_RESULTS</see>:</term>
        ///         <description>Returns solution results inside the <member
        /// name="result_per_destination_node" /> array in the response if set
        /// to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.REMOVE_PREVIOUS_RESTRICTIONS">REMOVE_PREVIOUS_RESTRICTIONS</see>:</term>
        ///         <description>Ignore the restrictions applied to the graph
        /// during the creation stage and only use the restrictions specified
        /// in this request if set to <i>true</i>.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="SolveGraphRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="SolveGraphRequest.Options.RESTRICTION_THRESHOLD_VALUE">RESTRICTION_THRESHOLD_VALUE</see>:</term>
        ///         <description>Value-based restriction comparison. Any node
        /// or edge with a RESTRICTIONS_VALUECOMPARED value greater than the
        /// <i>restriction_threshold_value</i> will not be included in the
        /// solution.</description>
        ///     </item>
        /// </list>
        /// The default value is an empty {@link Dictionary}.</param>
        /// 
        public SolveGraphRequest( string graph_name,
                                  IList<string> weights_on_edges,
                                  IList<string> restrictions,
                                  string solver_type,
                                  long source_node_id,
                                  IList<long> destination_node_ids = null,
                                  string node_type = null,
                                  string source_node = null,
                                  IList<string> destination_nodes = null,
                                  string solution_table = null,
                                  IDictionary<string, string> options = null)
        {
            this.graph_name = graph_name ?? "";
            this.weights_on_edges = weights_on_edges ?? new List<string>();
            this.restrictions = restrictions ?? new List<string>();
            this.solver_type = solver_type ?? SolverType.SHORTEST_PATH;
            this.source_node_id = source_node_id;
            this.destination_node_ids = destination_node_ids ?? new List<long>();
            this.node_type = node_type ?? NodeType.NODE_ID;
            this.source_node = source_node ?? "";
            this.destination_nodes = destination_nodes ?? new List<string>();
            this.solution_table = solution_table ?? "graph_solutions";
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor

    } // end class SolveGraphRequest



    /// <summary>A set of results returned by <see
    /// cref="Kinetica.solveGraph(string,IList{string},IList{string},string,long,IList{long},string,string,IList{string},string,IDictionary{string, string})"
    /// />.</summary>
    public class SolveGraphResponse : KineticaData
    {

        /// <summary>Indicates a successful solution.  </summary>
        public bool result { get; set; }

        /// <summary>Cost or Pagerank (based on solver type) for each
        /// destination node requested. Only populated if
        /// <i>export_solve_results</i> is set to <i>true</i>.  </summary>
        public IList<float> result_per_destination_node { get; set; } = new List<float>();

        /// <summary>Additional information.  </summary>
        public IDictionary<string, string> info { get; set; } = new Dictionary<string, string>();

    } // end class SolveGraphResponse




}  // end namespace kinetica
