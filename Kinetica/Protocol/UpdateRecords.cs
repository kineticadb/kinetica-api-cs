/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

using System.Collections.Generic;



namespace kinetica
{

    /// <summary>A set of parameters for <see
    /// cref="Kinetica.updateRecords{T}(string,IList{string},IList{IDictionary{string, string}},IList{T},IDictionary{string, string})"
    /// />.
    /// <br />
    /// Runs multiple predicate-based updates in a single call.  With the list
    /// of given expressions, any matching record's column values will be
    /// updated as provided in <see cref="new_values_maps" />.  There is also
    /// an optional 'upsert' capability where if a particular predicate doesn't
    /// match any existing record, then a new record can be inserted.
    /// <br />
    /// Note that this operation can only be run on an original table and not
    /// on a collection or a result view.
    /// <br />
    /// This operation can update primary key values.  By default only 'pure
    /// primary key' predicates are allowed when updating primary key values.
    /// If the primary key for a table is the column 'attr1', then the
    /// operation will only accept predicates of the form: "attr1 == 'foo'" if
    /// the attr1 column is being updated.  For a composite primary key (e.g.
    /// columns 'attr1' and 'attr2') then this operation will only accept
    /// predicates of the form: "(attr1 == 'foo') and (attr2 == 'bar')".
    /// Meaning, all primary key columns must appear in an equality predicate
    /// in the expressions.  Furthermore each 'pure primary key' predicate must
    /// be unique within a given request.  These restrictions can be removed by
    /// utilizing some available options through <see cref="options"
    /// />.</summary>
    public class RawUpdateRecordsRequest : KineticaData
    {

        /// <summary>Identifies which of <paramref
        /// cref="RawUpdateRecordsRequest.records_to_insert" /> and <paramref
        /// cref="RawUpdateRecordsRequest.records_to_insert_str" /> should be
        /// used.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.BINARY">BINARY</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.JSON">JSON</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.BINARY">BINARY</see>.
        /// A set of string constants for the parameter <see
        /// cref="record_encoding" />.</summary>
        public struct RecordEncoding
        {
            public const string BINARY = "binary";
            public const string JSON = "json";
        } // end struct RecordEncoding


        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.GLOBAL_EXPRESSION">GLOBAL_EXPRESSION</see>:</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.BYPASS_SAFETY_CHECKS">BYPASS_SAFETY_CHECKS</see>:</term>
        ///         <description>When set to <i>true</i>, all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.UPDATE_ON_EXISTING_PK">UPDATE_ON_EXISTING_PK</see>:</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists as described in
        /// /insert/records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.USE_EXPRESSIONS_IN_NEW_VALUES_MAPS">USE_EXPRESSIONS_IN_NEW_VALUES_MAPS</see>:</term>
        ///         <description>When set to <i>true</i>, all new values in
        /// <paramref cref="RawUpdateRecordsRequest.new_values_maps" /> are
        /// considered as expression values. When set to <i>false</i>, all new
        /// values in <paramref cref="RawUpdateRecordsRequest.new_values_maps"
        /// /> are considered as constants.  NOTE:  When <i>true</i>, string
        /// constants will need to be quoted to avoid being evaluated as
        /// expressions.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.RECORD_ID">RECORD_ID</see>:</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        /// <br />
        /// A set of string constants for the parameter <see cref="options"
        /// />.</summary>
        public struct Options
        {

            /// <summary>An optional global expression to reduce the search
            /// space of the predicates listed in <see cref="expressions"
            /// />.</summary>
            public const string GLOBAL_EXPRESSION = "global_expression";

            /// <summary>When set to <i>true</i>, all predicates are available
            /// for primary key updates.  Keep in mind that it is possible to
            /// destroy data in this case, since a single predicate may match
            /// multiple objects (potentially all of records of a table), and
            /// then updating all of those records to have the same primary key
            /// will, due to the primary key uniqueness constraints,
            /// effectively delete all but one of those updated records.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</summary>
            public const string BYPASS_SAFETY_CHECKS = "bypass_safety_checks";
            public const string TRUE = "true";
            public const string FALSE = "false";

            /// <summary>Can be used to customize behavior when the updated
            /// primary key value already exists as described in <see
            /// cref="Kinetica.insertRecords{T}(string,IList{T},IDictionary{string, string})"
            /// />.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</summary>
            public const string UPDATE_ON_EXISTING_PK = "update_on_existing_pk";

            /// <summary>When set to <i>true</i>, all new values in <see
            /// cref="new_values_maps" /> are considered as expression values.
            /// When set to <i>false</i>, all new values in <see
            /// cref="new_values_maps" /> are considered as constants.  NOTE:
            /// When <i>true</i>, string constants will need to be quoted to
            /// avoid being evaluated as expressions.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</summary>
            public const string USE_EXPRESSIONS_IN_NEW_VALUES_MAPS = "use_expressions_in_new_values_maps";

            /// <summary>ID of a single record to be updated (returned in the
            /// call to <see
            /// cref="Kinetica.insertRecords{T}(string,IList{T},IDictionary{string, string})"
            /// /> or <see
            /// cref="Kinetica.getRecordsFromCollection{T}(string,long,long,IDictionary{string, string})"
            /// />).</summary>
            public const string RECORD_ID = "record_id";
        } // end struct Options


        /// <summary>Table to be updated. Must be a currently existing table
        /// and not a collection or view.  </summary>
        public string table_name { get; set; }

        /// <summary>A list of the actual predicates, one for each update;
        /// format should follow the guidelines /filter.  </summary>
        public IList<string> expressions { get; set; } = new List<string>();

        /// <summary>List of new values for the matching records.  Each element
        /// is a map with (key, value) pairs where the keys are the names of
        /// the columns whose values are to be updated; the values are the new
        /// values.  The number of elements in the list should match the length
        /// of <paramref cref="RawUpdateRecordsRequest.expressions" />.
        /// </summary>
        public IList<IDictionary<string, string>> new_values_maps { get; set; } = new List<IDictionary<string, string>>();

        /// <summary>An *optional* list of new binary-avro encoded records to
        /// insert, one for each update.  If one of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" /> does not yield a
        /// matching record to be updated, then the corresponding element from
        /// this list will be added to the table.  </summary>
        public IList<byte[]> records_to_insert { get; set; } = new List<byte[]>();

        /// <summary>An optional list of new json-avro encoded objects to
        /// insert, one for each update, to be added to the set if the
        /// particular update did not affect any objects.  </summary>
        public IList<string> records_to_insert_str { get; set; } = new List<string>();

        /// <summary>Identifies which of <paramref
        /// cref="RawUpdateRecordsRequest.records_to_insert" /> and <paramref
        /// cref="RawUpdateRecordsRequest.records_to_insert_str" /> should be
        /// used.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.BINARY">BINARY</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.JSON">JSON</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.BINARY">BINARY</see>.
        /// </summary>
        public string record_encoding { get; set; } = RecordEncoding.BINARY;

        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.GLOBAL_EXPRESSION">GLOBAL_EXPRESSION</see>:</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.BYPASS_SAFETY_CHECKS">BYPASS_SAFETY_CHECKS</see>:</term>
        ///         <description>When set to <i>true</i>, all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.UPDATE_ON_EXISTING_PK">UPDATE_ON_EXISTING_PK</see>:</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists as described in
        /// /insert/records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.USE_EXPRESSIONS_IN_NEW_VALUES_MAPS">USE_EXPRESSIONS_IN_NEW_VALUES_MAPS</see>:</term>
        ///         <description>When set to <i>true</i>, all new values in
        /// <paramref cref="RawUpdateRecordsRequest.new_values_maps" /> are
        /// considered as expression values. When set to <i>false</i>, all new
        /// values in <paramref cref="RawUpdateRecordsRequest.new_values_maps"
        /// /> are considered as constants.  NOTE:  When <i>true</i>, string
        /// constants will need to be quoted to avoid being evaluated as
        /// expressions.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.RECORD_ID">RECORD_ID</see>:</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        ///   </summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs a RawUpdateRecordsRequest object with default
        /// parameters.</summary>
        public RawUpdateRecordsRequest() { }

        /// <summary>Constructs a RawUpdateRecordsRequest object with the
        /// specified parameters.</summary>
        /// 
        /// <param name="table_name">Table to be updated. Must be a currently
        /// existing table and not a collection or view.  </param>
        /// <param name="expressions">A list of the actual predicates, one for
        /// each update; format should follow the guidelines /filter.  </param>
        /// <param name="new_values_maps">List of new values for the matching
        /// records.  Each element is a map with (key, value) pairs where the
        /// keys are the names of the columns whose values are to be updated;
        /// the values are the new values.  The number of elements in the list
        /// should match the length of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.  </param>
        /// <param name="records_to_insert">An *optional* list of new
        /// binary-avro encoded records to insert, one for each update.  If one
        /// of <paramref cref="RawUpdateRecordsRequest.expressions" /> does not
        /// yield a matching record to be updated, then the corresponding
        /// element from this list will be added to the table.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.GLOBAL_EXPRESSION">GLOBAL_EXPRESSION</see>:</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.BYPASS_SAFETY_CHECKS">BYPASS_SAFETY_CHECKS</see>:</term>
        ///         <description>When set to <i>true</i>, all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.UPDATE_ON_EXISTING_PK">UPDATE_ON_EXISTING_PK</see>:</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists as described in
        /// /insert/records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.USE_EXPRESSIONS_IN_NEW_VALUES_MAPS">USE_EXPRESSIONS_IN_NEW_VALUES_MAPS</see>:</term>
        ///         <description>When set to <i>true</i>, all new values in
        /// <paramref cref="RawUpdateRecordsRequest.new_values_maps" /> are
        /// considered as expression values. When set to <i>false</i>, all new
        /// values in <paramref cref="RawUpdateRecordsRequest.new_values_maps"
        /// /> are considered as constants.  NOTE:  When <i>true</i>, string
        /// constants will need to be quoted to avoid being evaluated as
        /// expressions.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.RECORD_ID">RECORD_ID</see>:</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        public RawUpdateRecordsRequest( string table_name,
                                        IList<string> expressions,
                                        IList<IDictionary<string, string>> new_values_maps,
                                        IList<byte[]> records_to_insert = null,
                                        IDictionary<string, string> options = null)
        {
            this.table_name = table_name ?? "";
            this.expressions = expressions ?? new List<string>();
            this.new_values_maps = new_values_maps ?? new List<IDictionary<string, string>>();
            this.records_to_insert = records_to_insert ?? new List<byte[]>();
            this.records_to_insert_str = new List<string>();
            this.record_encoding = RecordEncoding.BINARY;
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor


        /// <summary>Constructs a RawUpdateRecordsRequest object with the
        /// specified parameters.</summary>
        /// 
        /// <param name="table_name">Table to be updated. Must be a currently
        /// existing table and not a collection or view.  </param>
        /// <param name="expressions">A list of the actual predicates, one for
        /// each update; format should follow the guidelines /filter.  </param>
        /// <param name="new_values_maps">List of new values for the matching
        /// records.  Each element is a map with (key, value) pairs where the
        /// keys are the names of the columns whose values are to be updated;
        /// the values are the new values.  The number of elements in the list
        /// should match the length of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.  </param>
        /// <param name="records_to_insert">An *optional* list of new
        /// binary-avro encoded records to insert, one for each update.  If one
        /// of <paramref cref="RawUpdateRecordsRequest.expressions" /> does not
        /// yield a matching record to be updated, then the corresponding
        /// element from this list will be added to the table.  </param>
        /// <param name="records_to_insert_str">An optional list of new
        /// json-avro encoded objects to insert, one for each update, to be
        /// added to the set if the particular update did not affect any
        /// objects.  </param>
        /// <param name="record_encoding">Identifies which of <paramref
        /// cref="RawUpdateRecordsRequest.records_to_insert" /> and <paramref
        /// cref="RawUpdateRecordsRequest.records_to_insert_str" /> should be
        /// used.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.BINARY">BINARY</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.JSON">JSON</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.RecordEncoding.BINARY">BINARY</see>.
        /// </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.GLOBAL_EXPRESSION">GLOBAL_EXPRESSION</see>:</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.BYPASS_SAFETY_CHECKS">BYPASS_SAFETY_CHECKS</see>:</term>
        ///         <description>When set to <i>true</i>, all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.UPDATE_ON_EXISTING_PK">UPDATE_ON_EXISTING_PK</see>:</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists as described in
        /// /insert/records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.USE_EXPRESSIONS_IN_NEW_VALUES_MAPS">USE_EXPRESSIONS_IN_NEW_VALUES_MAPS</see>:</term>
        ///         <description>When set to <i>true</i>, all new values in
        /// <paramref cref="RawUpdateRecordsRequest.new_values_maps" /> are
        /// considered as expression values. When set to <i>false</i>, all new
        /// values in <paramref cref="RawUpdateRecordsRequest.new_values_maps"
        /// /> are considered as constants.  NOTE:  When <i>true</i>, string
        /// constants will need to be quoted to avoid being evaluated as
        /// expressions.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.RECORD_ID">RECORD_ID</see>:</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        public RawUpdateRecordsRequest( string table_name,
                                        IList<string> expressions,
                                        IList<IDictionary<string, string>> new_values_maps,
                                        IList<byte[]> records_to_insert = null,
                                        IList<string> records_to_insert_str = null,
                                        string record_encoding = null,
                                        IDictionary<string, string> options = null)
        {
            this.table_name = table_name ?? "";
            this.expressions = expressions ?? new List<string>();
            this.new_values_maps = new_values_maps ?? new List<IDictionary<string, string>>();
            this.records_to_insert = records_to_insert ?? new List<byte[]>();
            this.records_to_insert_str = records_to_insert_str ?? new List<string>();
            this.record_encoding = record_encoding ?? RecordEncoding.BINARY;
            this.options = options ?? new Dictionary<string, string>();
        } // end full constructor

    } // end class RawUpdateRecordsRequest



    /// <summary>A set of parameters for <see
    /// cref="Kinetica.updateRecords{T}(string,IList{string},IList{IDictionary{string, string}},IList{T},IDictionary{string, string})"
    /// />.
    /// <br />
    /// Runs multiple predicate-based updates in a single call.  With the list
    /// of given expressions, any matching record's column values will be
    /// updated as provided in <see cref="new_values_maps" />.  There is also
    /// an optional 'upsert' capability where if a particular predicate doesn't
    /// match any existing record, then a new record can be inserted.
    /// <br />
    /// Note that this operation can only be run on an original table and not
    /// on a collection or a result view.
    /// <br />
    /// This operation can update primary key values.  By default only 'pure
    /// primary key' predicates are allowed when updating primary key values.
    /// If the primary key for a table is the column 'attr1', then the
    /// operation will only accept predicates of the form: "attr1 == 'foo'" if
    /// the attr1 column is being updated.  For a composite primary key (e.g.
    /// columns 'attr1' and 'attr2') then this operation will only accept
    /// predicates of the form: "(attr1 == 'foo') and (attr2 == 'bar')".
    /// Meaning, all primary key columns must appear in an equality predicate
    /// in the expressions.  Furthermore each 'pure primary key' predicate must
    /// be unique within a given request.  These restrictions can be removed by
    /// utilizing some available options through <see cref="options"
    /// />.</summary>
    /// 
    /// <typeparam name="T">The type of object being processed.</typeparam>
    /// 
    public class UpdateRecordsRequest<T> : KineticaData
    {

        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.GLOBAL_EXPRESSION">GLOBAL_EXPRESSION</see>:</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.BYPASS_SAFETY_CHECKS">BYPASS_SAFETY_CHECKS</see>:</term>
        ///         <description>When set to <i>true</i>, all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.UPDATE_ON_EXISTING_PK">UPDATE_ON_EXISTING_PK</see>:</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists as described in
        /// /insert/records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.USE_EXPRESSIONS_IN_NEW_VALUES_MAPS">USE_EXPRESSIONS_IN_NEW_VALUES_MAPS</see>:</term>
        ///         <description>When set to <i>true</i>, all new values in
        /// <paramref cref="RawUpdateRecordsRequest.new_values_maps" /> are
        /// considered as expression values. When set to <i>false</i>, all new
        /// values in <paramref cref="RawUpdateRecordsRequest.new_values_maps"
        /// /> are considered as constants.  NOTE:  When <i>true</i>, string
        /// constants will need to be quoted to avoid being evaluated as
        /// expressions.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.RECORD_ID">RECORD_ID</see>:</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        /// <br />
        /// A set of string constants for the parameter <see cref="options"
        /// />.</summary>
        public struct Options
        {

            /// <summary>An optional global expression to reduce the search
            /// space of the predicates listed in <see cref="expressions"
            /// />.</summary>
            public const string GLOBAL_EXPRESSION = "global_expression";

            /// <summary>When set to <i>true</i>, all predicates are available
            /// for primary key updates.  Keep in mind that it is possible to
            /// destroy data in this case, since a single predicate may match
            /// multiple objects (potentially all of records of a table), and
            /// then updating all of those records to have the same primary key
            /// will, due to the primary key uniqueness constraints,
            /// effectively delete all but one of those updated records.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</summary>
            public const string BYPASS_SAFETY_CHECKS = "bypass_safety_checks";
            public const string TRUE = "true";
            public const string FALSE = "false";

            /// <summary>Can be used to customize behavior when the updated
            /// primary key value already exists as described in <see
            /// cref="Kinetica.insertRecords{T}(string,IList{T},IDictionary{string, string})"
            /// />.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</summary>
            public const string UPDATE_ON_EXISTING_PK = "update_on_existing_pk";

            /// <summary>When set to <i>true</i>, all new values in <see
            /// cref="new_values_maps" /> are considered as expression values.
            /// When set to <i>false</i>, all new values in <see
            /// cref="new_values_maps" /> are considered as constants.  NOTE:
            /// When <i>true</i>, string constants will need to be quoted to
            /// avoid being evaluated as expressions.
            /// Supported values:
            /// <list type="bullet">
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
            ///     </item>
            ///     <item>
            ///         <term><see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
            ///     </item>
            /// </list>
            /// The default value is <see
            /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</summary>
            public const string USE_EXPRESSIONS_IN_NEW_VALUES_MAPS = "use_expressions_in_new_values_maps";

            /// <summary>ID of a single record to be updated (returned in the
            /// call to <see
            /// cref="Kinetica.insertRecords{T}(string,IList{T},IDictionary{string, string})"
            /// /> or <see
            /// cref="Kinetica.getRecordsFromCollection{T}(string,long,long,IDictionary{string, string})"
            /// />).</summary>
            public const string RECORD_ID = "record_id";
        } // end struct Options


        /// <summary>Table to be updated. Must be a currently existing table
        /// and not a collection or view.  </summary>
        public string table_name { get; set; }

        /// <summary>A list of the actual predicates, one for each update;
        /// format should follow the guidelines /filter.  </summary>
        public IList<string> expressions { get; set; } = new List<string>();

        /// <summary>List of new values for the matching records.  Each element
        /// is a map with (key, value) pairs where the keys are the names of
        /// the columns whose values are to be updated; the values are the new
        /// values.  The number of elements in the list should match the length
        /// of <paramref cref="RawUpdateRecordsRequest.expressions" />.
        /// </summary>
        public IList<IDictionary<string, string>> new_values_maps { get; set; } = new List<IDictionary<string, string>>();

        /// <summary>An *optional* list of new binary-avro encoded records to
        /// insert, one for each update.  If one of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" /> does not yield a
        /// matching record to be updated, then the corresponding element from
        /// this list will be added to the table.  </summary>
        public IList<T> data { get; set; } = new List<T>();

        /// <summary>Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.GLOBAL_EXPRESSION">GLOBAL_EXPRESSION</see>:</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.BYPASS_SAFETY_CHECKS">BYPASS_SAFETY_CHECKS</see>:</term>
        ///         <description>When set to <i>true</i>, all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.UPDATE_ON_EXISTING_PK">UPDATE_ON_EXISTING_PK</see>:</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists as described in
        /// /insert/records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.USE_EXPRESSIONS_IN_NEW_VALUES_MAPS">USE_EXPRESSIONS_IN_NEW_VALUES_MAPS</see>:</term>
        ///         <description>When set to <i>true</i>, all new values in
        /// <paramref cref="RawUpdateRecordsRequest.new_values_maps" /> are
        /// considered as expression values. When set to <i>false</i>, all new
        /// values in <paramref cref="RawUpdateRecordsRequest.new_values_maps"
        /// /> are considered as constants.  NOTE:  When <i>true</i>, string
        /// constants will need to be quoted to avoid being evaluated as
        /// expressions.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.RECORD_ID">RECORD_ID</see>:</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        ///   </summary>
        public IDictionary<string, string> options { get; set; } = new Dictionary<string, string>();


        /// <summary>Constructs an UpdateRecordsRequest object with default
        /// parameters.</summary>
        public UpdateRecordsRequest() { }

        /// <summary>Constructs an UpdateRecordsRequest object with the
        /// specified parameters.</summary>
        /// 
        /// <param name="table_name">Table to be updated. Must be a currently
        /// existing table and not a collection or view.  </param>
        /// <param name="expressions">A list of the actual predicates, one for
        /// each update; format should follow the guidelines /filter.  </param>
        /// <param name="new_values_maps">List of new values for the matching
        /// records.  Each element is a map with (key, value) pairs where the
        /// keys are the names of the columns whose values are to be updated;
        /// the values are the new values.  The number of elements in the list
        /// should match the length of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.  </param>
        /// <param name="data">An *optional* list of new binary-avro encoded
        /// records to insert, one for each update.  If one of <paramref
        /// cref="RawUpdateRecordsRequest.expressions" /> does not yield a
        /// matching record to be updated, then the corresponding element from
        /// this list will be added to the table.  </param>
        /// <param name="options">Optional parameters.
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.GLOBAL_EXPRESSION">GLOBAL_EXPRESSION</see>:</term>
        ///         <description>An optional global expression to reduce the
        /// search space of the predicates listed in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.BYPASS_SAFETY_CHECKS">BYPASS_SAFETY_CHECKS</see>:</term>
        ///         <description>When set to <i>true</i>, all predicates are
        /// available for primary key updates.  Keep in mind that it is
        /// possible to destroy data in this case, since a single predicate may
        /// match multiple objects (potentially all of records of a table), and
        /// then updating all of those records to have the same primary key
        /// will, due to the primary key uniqueness constraints, effectively
        /// delete all but one of those updated records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.UPDATE_ON_EXISTING_PK">UPDATE_ON_EXISTING_PK</see>:</term>
        ///         <description>Can be used to customize behavior when the
        /// updated primary key value already exists as described in
        /// /insert/records.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.USE_EXPRESSIONS_IN_NEW_VALUES_MAPS">USE_EXPRESSIONS_IN_NEW_VALUES_MAPS</see>:</term>
        ///         <description>When set to <i>true</i>, all new values in
        /// <paramref cref="RawUpdateRecordsRequest.new_values_maps" /> are
        /// considered as expression values. When set to <i>false</i>, all new
        /// values in <paramref cref="RawUpdateRecordsRequest.new_values_maps"
        /// /> are considered as constants.  NOTE:  When <i>true</i>, string
        /// constants will need to be quoted to avoid being evaluated as
        /// expressions.
        /// Supported values:
        /// <list type="bullet">
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.TRUE">TRUE</see></term>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see></term>
        ///     </item>
        /// </list>
        /// The default value is <see
        /// cref="RawUpdateRecordsRequest.Options.FALSE">FALSE</see>.</description>
        ///     </item>
        ///     <item>
        ///         <term><see
        /// cref="RawUpdateRecordsRequest.Options.RECORD_ID">RECORD_ID</see>:</term>
        ///         <description>ID of a single record to be updated (returned
        /// in the call to /insert/records or
        /// /get/records/fromcollection).</description>
        ///     </item>
        /// </list>
        ///   </param>
        /// 
        public UpdateRecordsRequest( string table_name,
                                     IList<string> expressions,
                                     IList<IDictionary<string, string>> new_values_maps,
                                     IList<T> data = null,
                                     IDictionary<string, string> options = null)
        {
            this.table_name = table_name ?? "";
            this.expressions = expressions ?? new List<string>();
            this.new_values_maps = new_values_maps ?? new List<IDictionary<string, string>>();
            this.data = data ?? new List<T>();
            this.options = options ?? new Dictionary<string, string>();
        } // end constructor

    } // end class UpdateRecordsRequest



    /// <summary>A set of results returned by <see
    /// cref="Kinetica.updateRecords{T}(string,IList{string},IList{IDictionary{string, string}},IList{T},IDictionary{string, string})"
    /// />.</summary>
    public class UpdateRecordsResponse : KineticaData
    {

        /// <summary>Total number of records updated.  </summary>
        public long count_updated { get; set; }

        /// <summary>Total number of records updated per predicate in <paramref
        /// cref="RawUpdateRecordsRequest.expressions" />.  </summary>
        public IList<long> counts_updated { get; set; } = new List<long>();

        /// <summary>Total number of records inserted (due to expressions not
        /// matching any existing records).  </summary>
        public long count_inserted { get; set; }

        /// <summary>Total number of records inserted per predicate in
        /// <paramref cref="RawUpdateRecordsRequest.expressions" /> (will be
        /// either 0 or 1 for each expression).  </summary>
        public IList<long> counts_inserted { get; set; } = new List<long>();

        /// <summary>Additional information.  </summary>
        public IDictionary<string, string> info { get; set; } = new Dictionary<string, string>();

    } // end class UpdateRecordsResponse




}  // end namespace kinetica
